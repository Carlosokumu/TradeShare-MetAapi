'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('promise.any');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Connection URL and request managing client
 */
class DomainClient {

  /**
   * Constructs domain client instance
   * @param {HttpClient} httpClient HTTP client
   * @param {String} token authorization token
   * @param {String} domain domain to connect to, default is agiliumtrade.agiliumtrade.ai
   */
  constructor(httpClient, token, domain = 'agiliumtrade.agiliumtrade.ai') {
    this._httpClient = httpClient;
    this._domain = domain;
    this._token = token;
    this._urlCache = null;
    this._regionCache = [];
    this._regionIndex = 0;
  }

  /**
   * Returns domain client domain
   * @returns {String} client domain
   */
  get domain() {
    return this._domain;
  }

  /**
   * Returns domain client token
   * @returns {String} client token
   */
  get token() {
    return this._token;
  }

  /**
   * Sends a CopyFactory API request
   * @param {Object} opts options request options
   * @param {Boolean} isExtendedTimeout whether to run the request with an extended timeout
   * @returns {Object|String|any} request result
   */
  async requestCopyFactory(opts, isExtendedTimeout = false) {
    await this._updateHost();
    try {
      return await this._httpClient.request((0, _assign2.default)({}, opts, {
        url: this._urlCache.url + opts.url
      }), isExtendedTimeout);
    } catch (err) {
      if (!['ConflictError', 'InternalError', 'ApiError', 'TimeoutError'].includes(err.name)) {
        throw err;
      } else {
        if (this._regionCache.length === this._regionIndex + 1) {
          throw err;
        } else {
          this._regionIndex++;
          return await this.requestCopyFactory(opts, isExtendedTimeout);
        }
      }
    }
  }

  /**
   * Sends an http request
   * @param {Object} opts options request options
   * @returns {Object|String|any} request result
   */
  request(opts) {
    return this._httpClient.request(opts);
  }

  /**
   * Sends a signal client request
   * @param {Object} opts options request options 
   * @param {Object} host signal client host data
   * @param {String} accountId account id
   * @returns {Object|String|any} request result
   */
  async requestSignal(opts, host, accountId) {
    this._updateAccountRegions(host, accountId);
    try {
      return await (0, _promise2.default)(host.regions.map(region => {
        return this._httpClient.requestWithFailover((0, _assign2.default)({}, opts, {
          url: `${host.host}.${region}.${host.domain}` + opts.url,
          headers: {
            'auth-token': this._token
          }
        }));
      }));
    } catch (error) {
      throw error.errors[0];
    }
  }

  /**
   * Returns CopyFactory host for signal client requests
   * @param {String[]} regions subscriber regions
   * @returns {String} signal client CopyFactory host
   */
  async getSignalClientHost(regions) {
    await this._updateHost();
    return {
      host: 'https://copyfactory-api-v1',
      regions,
      lastUpdated: Date.now(),
      domain: this._urlCache.domain
    };
  }

  /**
   * Account request info
   * @typedef {Object} AccountInfo
   * @property {String} id primary account id
   * @property {String[]} regions account available regions
   */

  /**
   * Returns account data by id
   * @param {String} accountId account id
   * @returns {AccountInfo} account data
   */
  async getAccountInfo(accountId) {
    const getAccount = async id => {
      const accountOpts = {
        url: `https://mt-provisioning-api-v1.${this.domain}/users/current/accounts/${id}`,
        method: 'GET',
        headers: {
          'auth-token': this.token
        },
        json: true
      };
      return await this._httpClient.requestWithFailover(accountOpts);
    };

    let accountData = await getAccount(accountId);
    let primaryAccountId = '';
    if (accountData.primaryAccountId) {
      primaryAccountId = accountData.primaryAccountId;
      accountData = await getAccount(primaryAccountId);
    } else {
      primaryAccountId = accountData._id;
    }

    let regions = [accountData.region].concat(accountData.accountReplicas && accountData.accountReplicas.map(replica => replica.region) || []);
    return {
      id: primaryAccountId,
      regions
    };
  }

  async _updateHost() {
    if (!this._urlCache || this._urlCache.lastUpdated < Date.now() - 1000 * 60 * 10) {
      await this._updateRegions();
      const urlSettings = await this._httpClient.request({
        url: `https://mt-provisioning-api-v1.${this._domain}/users/current/servers/mt-client-api`,
        method: 'GET',
        headers: {
          'auth-token': this._token
        },
        json: true
      });
      this._urlCache = {
        url: `https://copyfactory-api-v1.${this._regionCache[this._regionIndex]}.${urlSettings.domain}`,
        domain: urlSettings.domain,
        lastUpdated: Date.now()
      };
    } else {
      this._urlCache = {
        url: `https://copyfactory-api-v1.${this._regionCache[this._regionIndex]}.${this._urlCache.domain}`,
        domain: this._urlCache.domain,
        lastUpdated: Date.now()
      };
    }
  }

  async _updateRegions() {
    this._regionIndex = 0;
    this._regionCache = await this._httpClient.request({
      url: `https://mt-provisioning-api-v1.${this._domain}/users/current/regions`,
      method: 'GET',
      headers: {
        'auth-token': this._token
      },
      json: true
    });
  }

  async _updateAccountRegions(host, accountId) {
    if (host.lastUpdated < Date.now() - 1000 * 60 * 10) {
      const accountData = await this.getAccountInfo(accountId);
      host.lastUpdated = Date.now();
      host.regions = accountData.regions;
    }
  }

}
exports.default = DomainClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jbGllbnRzL2RvbWFpbi5jbGllbnQuZXM2Il0sIm5hbWVzIjpbIkRvbWFpbkNsaWVudCIsImNvbnN0cnVjdG9yIiwiaHR0cENsaWVudCIsInRva2VuIiwiZG9tYWluIiwiX2h0dHBDbGllbnQiLCJfZG9tYWluIiwiX3Rva2VuIiwiX3VybENhY2hlIiwiX3JlZ2lvbkNhY2hlIiwiX3JlZ2lvbkluZGV4IiwicmVxdWVzdENvcHlGYWN0b3J5Iiwib3B0cyIsImlzRXh0ZW5kZWRUaW1lb3V0IiwiX3VwZGF0ZUhvc3QiLCJyZXF1ZXN0IiwidXJsIiwiZXJyIiwiaW5jbHVkZXMiLCJuYW1lIiwibGVuZ3RoIiwicmVxdWVzdFNpZ25hbCIsImhvc3QiLCJhY2NvdW50SWQiLCJfdXBkYXRlQWNjb3VudFJlZ2lvbnMiLCJyZWdpb25zIiwibWFwIiwicmVnaW9uIiwicmVxdWVzdFdpdGhGYWlsb3ZlciIsImhlYWRlcnMiLCJlcnJvciIsImVycm9ycyIsImdldFNpZ25hbENsaWVudEhvc3QiLCJsYXN0VXBkYXRlZCIsIkRhdGUiLCJub3ciLCJnZXRBY2NvdW50SW5mbyIsImdldEFjY291bnQiLCJpZCIsImFjY291bnRPcHRzIiwibWV0aG9kIiwianNvbiIsImFjY291bnREYXRhIiwicHJpbWFyeUFjY291bnRJZCIsIl9pZCIsImNvbmNhdCIsImFjY291bnRSZXBsaWNhcyIsInJlcGxpY2EiLCJfdXBkYXRlUmVnaW9ucyIsInVybFNldHRpbmdzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBOzs7Ozs7QUFFQTs7O0FBR2UsTUFBTUEsWUFBTixDQUFtQjs7QUFFaEM7Ozs7OztBQU1BQyxjQUFZQyxVQUFaLEVBQXdCQyxLQUF4QixFQUErQkMsU0FBUyw4QkFBeEMsRUFBd0U7QUFDdEUsU0FBS0MsV0FBTCxHQUFtQkgsVUFBbkI7QUFDQSxTQUFLSSxPQUFMLEdBQWVGLE1BQWY7QUFDQSxTQUFLRyxNQUFMLEdBQWNKLEtBQWQ7QUFDQSxTQUFLSyxT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IGFueSBmcm9tICdwcm9taXNlLmFueSc7XG5cbi8qKlxuICogQ29ubmVjdGlvbiBVUkwgYW5kIHJlcXVlc3QgbWFuYWdpbmcgY2xpZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbWFpbkNsaWVudCB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgZG9tYWluIGNsaWVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0h0dHBDbGllbnR9IGh0dHBDbGllbnQgSFRUUCBjbGllbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIGF1dGhvcml6YXRpb24gdG9rZW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBkb21haW4gdG8gY29ubmVjdCB0bywgZGVmYXVsdCBpcyBhZ2lsaXVtdHJhZGUuYWdpbGl1bXRyYWRlLmFpXG4gICAqL1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50LCB0b2tlbiwgZG9tYWluID0gJ2FnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWknKSB7XG4gICAgdGhpcy5faHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgdGhpcy5fZG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMuX3Rva2VuID0gdG9rZW47XG4gICAgdGhpcy5fdXJsQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuX3JlZ2lvbkNhY2hlID0gW107XG4gICAgdGhpcy5fcmVnaW9uSW5kZXggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZG9tYWluIGNsaWVudCBkb21haW5cbiAgICogQHJldHVybnMge1N0cmluZ30gY2xpZW50IGRvbWFpblxuICAgKi9cbiAgZ2V0IGRvbWFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tYWluO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZG9tYWluIGNsaWVudCB0b2tlblxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBjbGllbnQgdG9rZW5cbiAgICovXG4gIGdldCB0b2tlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBDb3B5RmFjdG9yeSBBUEkgcmVxdWVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBvcHRpb25zIHJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRXh0ZW5kZWRUaW1lb3V0IHdoZXRoZXIgdG8gcnVuIHRoZSByZXF1ZXN0IHdpdGggYW4gZXh0ZW5kZWQgdGltZW91dFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fFN0cmluZ3xhbnl9IHJlcXVlc3QgcmVzdWx0XG4gICAqL1xuICBhc3luYyByZXF1ZXN0Q29weUZhY3Rvcnkob3B0cywgaXNFeHRlbmRlZFRpbWVvdXQgPSBmYWxzZSkge1xuICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUhvc3QoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2h0dHBDbGllbnQucmVxdWVzdChPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICAgIHVybDogdGhpcy5fdXJsQ2FjaGUudXJsICsgb3B0cy51cmxcbiAgICAgIH0pLCBpc0V4dGVuZGVkVGltZW91dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZighWydDb25mbGljdEVycm9yJywgJ0ludGVybmFsRXJyb3InLCAnQXBpRXJyb3InLCAnVGltZW91dEVycm9yJ10uaW5jbHVkZXMoZXJyLm5hbWUpKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKHRoaXMuX3JlZ2lvbkNhY2hlLmxlbmd0aCA9PT0gdGhpcy5fcmVnaW9uSW5kZXggKyAxKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlZ2lvbkluZGV4Kys7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdENvcHlGYWN0b3J5KG9wdHMsIGlzRXh0ZW5kZWRUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGh0dHAgcmVxdWVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBvcHRpb25zIHJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fFN0cmluZ3xhbnl9IHJlcXVlc3QgcmVzdWx0XG4gICAqL1xuICByZXF1ZXN0KG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5faHR0cENsaWVudC5yZXF1ZXN0KG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgc2lnbmFsIGNsaWVudCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbnMgcmVxdWVzdCBvcHRpb25zIFxuICAgKiBAcGFyYW0ge09iamVjdH0gaG9zdCBzaWduYWwgY2xpZW50IGhvc3QgZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8YW55fSByZXF1ZXN0IHJlc3VsdFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdFNpZ25hbChvcHRzLCBob3N0LCBhY2NvdW50SWQpIHtcbiAgICB0aGlzLl91cGRhdGVBY2NvdW50UmVnaW9ucyhob3N0LCBhY2NvdW50SWQpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYW55KGhvc3QucmVnaW9ucy5tYXAocmVnaW9uID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2h0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICAgICAgdXJsOiBgJHtob3N0Lmhvc3R9LiR7cmVnaW9ufS4ke2hvc3QuZG9tYWlufWAgKyBvcHRzLnVybCxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnYXV0aC10b2tlbic6IHRoaXMuX3Rva2VuXG4gICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvci5lcnJvcnNbMF07IFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIENvcHlGYWN0b3J5IGhvc3QgZm9yIHNpZ25hbCBjbGllbnQgcmVxdWVzdHNcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gcmVnaW9ucyBzdWJzY3JpYmVyIHJlZ2lvbnNcbiAgICogQHJldHVybnMge1N0cmluZ30gc2lnbmFsIGNsaWVudCBDb3B5RmFjdG9yeSBob3N0XG4gICAqL1xuICBhc3luYyBnZXRTaWduYWxDbGllbnRIb3N0KHJlZ2lvbnMpIHtcbiAgICBhd2FpdCB0aGlzLl91cGRhdGVIb3N0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvc3Q6ICdodHRwczovL2NvcHlmYWN0b3J5LWFwaS12MScsXG4gICAgICByZWdpb25zLFxuICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCksXG4gICAgICBkb21haW46IHRoaXMuX3VybENhY2hlLmRvbWFpblxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWNjb3VudCByZXF1ZXN0IGluZm9cbiAgICogQHR5cGVkZWYge09iamVjdH0gQWNjb3VudEluZm9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGlkIHByaW1hcnkgYWNjb3VudCBpZFxuICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSByZWdpb25zIGFjY291bnQgYXZhaWxhYmxlIHJlZ2lvbnNcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWNjb3VudCBkYXRhIGJ5IGlkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcmV0dXJucyB7QWNjb3VudEluZm99IGFjY291bnQgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm8oYWNjb3VudElkKSB7XG4gICAgY29uc3QgZ2V0QWNjb3VudCA9IGFzeW5jIChpZCkgPT4ge1xuICAgICAgY29uc3QgYWNjb3VudE9wdHMgPSB7XG4gICAgICAgIHVybDogYGh0dHBzOi8vbXQtcHJvdmlzaW9uaW5nLWFwaS12MS4ke3RoaXMuZG9tYWlufS91c2Vycy9jdXJyZW50L2FjY291bnRzLyR7aWR9YCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdhdXRoLXRva2VuJzogdGhpcy50b2tlblxuICAgICAgICB9LFxuICAgICAgICBqc29uOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2h0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihhY2NvdW50T3B0cyk7XG4gICAgfTtcblxuICAgIGxldCBhY2NvdW50RGF0YSA9IGF3YWl0IGdldEFjY291bnQoYWNjb3VudElkKTtcbiAgICBsZXQgcHJpbWFyeUFjY291bnRJZCA9ICcnO1xuICAgIGlmKGFjY291bnREYXRhLnByaW1hcnlBY2NvdW50SWQpIHtcbiAgICAgIHByaW1hcnlBY2NvdW50SWQgPSBhY2NvdW50RGF0YS5wcmltYXJ5QWNjb3VudElkO1xuICAgICAgYWNjb3VudERhdGEgPSBhd2FpdCBnZXRBY2NvdW50KHByaW1hcnlBY2NvdW50SWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmltYXJ5QWNjb3VudElkID0gYWNjb3VudERhdGEuX2lkO1xuICAgIH1cblxuICAgIGxldCByZWdpb25zID0gW2FjY291bnREYXRhLnJlZ2lvbl0uY29uY2F0KGFjY291bnREYXRhLmFjY291bnRSZXBsaWNhcyAmJiBcbiAgICAgIGFjY291bnREYXRhLmFjY291bnRSZXBsaWNhcy5tYXAocmVwbGljYSA9PiByZXBsaWNhLnJlZ2lvbikgfHwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogcHJpbWFyeUFjY291bnRJZCxcbiAgICAgIHJlZ2lvbnNcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgX3VwZGF0ZUhvc3QoKSB7XG4gICAgaWYoIXRoaXMuX3VybENhY2hlIHx8IHRoaXMuX3VybENhY2hlLmxhc3RVcGRhdGVkIDwgRGF0ZS5ub3coKSAtIDEwMDAgKiA2MCAqIDEwKSB7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGVSZWdpb25zKCk7XG4gICAgICBjb25zdCB1cmxTZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2h0dHBDbGllbnQucmVxdWVzdCh7XG4gICAgICAgIHVybDogYGh0dHBzOi8vbXQtcHJvdmlzaW9uaW5nLWFwaS12MS4ke3RoaXMuX2RvbWFpbn0vdXNlcnMvY3VycmVudC9zZXJ2ZXJzL210LWNsaWVudC1hcGlgLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ2F1dGgtdG9rZW4nOiB0aGlzLl90b2tlblxuICAgICAgICB9LFxuICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICB0aGlzLl91cmxDYWNoZSA9IHtcbiAgICAgICAgdXJsOiBgaHR0cHM6Ly9jb3B5ZmFjdG9yeS1hcGktdjEuJHt0aGlzLl9yZWdpb25DYWNoZVt0aGlzLl9yZWdpb25JbmRleF19LiR7dXJsU2V0dGluZ3MuZG9tYWlufWAsXG4gICAgICAgIGRvbWFpbjogdXJsU2V0dGluZ3MuZG9tYWluLFxuICAgICAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKVxuICAgICAgfTsgXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VybENhY2hlID0ge1xuICAgICAgICB1cmw6IGBodHRwczovL2NvcHlmYWN0b3J5LWFwaS12MS4ke3RoaXMuX3JlZ2lvbkNhY2hlW3RoaXMuX3JlZ2lvbkluZGV4XX0uJHt0aGlzLl91cmxDYWNoZS5kb21haW59YCxcbiAgICAgICAgZG9tYWluOiB0aGlzLl91cmxDYWNoZS5kb21haW4sXG4gICAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpXG4gICAgICB9OyBcbiAgICB9XG4gIH1cblxuICBhc3luYyBfdXBkYXRlUmVnaW9ucygpIHtcbiAgICB0aGlzLl9yZWdpb25JbmRleCA9IDA7XG4gICAgdGhpcy5fcmVnaW9uQ2FjaGUgPSBhd2FpdCB0aGlzLl9odHRwQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgdXJsOiBgaHR0cHM6Ly9tdC1wcm92aXNpb25pbmctYXBpLXYxLiR7dGhpcy5fZG9tYWlufS91c2Vycy9jdXJyZW50L3JlZ2lvbnNgLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0aGlzLl90b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBfdXBkYXRlQWNjb3VudFJlZ2lvbnMoaG9zdCwgYWNjb3VudElkKSB7XG4gICAgaWYoaG9zdC5sYXN0VXBkYXRlZCA8IERhdGUubm93KCkgLSAxMDAwICogNjAgKiAxMCkge1xuICAgICAgY29uc3QgYWNjb3VudERhdGEgPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvKGFjY291bnRJZCk7XG4gICAgICBob3N0Lmxhc3RVcGRhdGVkID0gRGF0ZS5ub3coKTtcbiAgICAgIGhvc3QucmVnaW9ucyA9IGFjY291bnREYXRhLnJlZ2lvbnM7XG4gICAgfVxuICB9XG5cbn0iXX0=