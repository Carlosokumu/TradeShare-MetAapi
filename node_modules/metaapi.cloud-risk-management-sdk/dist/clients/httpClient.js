'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HttpClientMock = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _requestPromiseAny = require('request-promise-any');

var _requestPromiseAny2 = _interopRequireDefault(_requestPromiseAny);

var _errorHandler = require('./errorHandler');

var _timeoutError = require('./timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * HTTP client library based on request-promise
 */
class HttpClient {

  /**
   * @typedef {Object} RetryOptions retry options
   * @property {Number} [retries] the number of attempts to retry failed request, default 5
   * @property {Number} [minDelayInSeconds] minimum delay in seconds before retrying, default 1
   * @property {Number} [maxDelayInSeconds] maximum delay in seconds before retrying, default 30
   */

  /**
   * Constructs HttpClient class instance
   * @param {Number} [timeout] request timeout in seconds
   * @param {Number} [extendedTimeout] request timeout in seconds
   * @param {RetryOptions} [retryOpts] retry options
   */
  constructor(timeout = 10, extendedTimeout = 70, retryOpts = {}) {
    this._timeout = timeout * 1000;
    this._extendedTimeout = extendedTimeout * 1000;
    this._retries = retryOpts.retries || 5;
    this._minRetryDelay = (retryOpts.minDelayInSeconds || 1) * 1000;
    this._maxRetryDelay = (retryOpts.maxDelayInSeconds || 30) * 1000;
  }

  /**
   * Performs a request. Response errors are returned as ApiError or subclasses.
   * @param {Object} options request options
   * @param {Boolean} isExtendedTimeout whether to run the request with an extended timeout
   * @returns {Object|String|any} request result
   */
  async request(options, isExtendedTimeout) {
    options.timeout = isExtendedTimeout ? this._extendedTimeout : this._timeout;
    try {
      return await this._makeRequest(options);
    } catch (err) {
      throw this._convertError(err);
    }
  }

  /**
   * Performs a request with a failover. Response errors are returned as ApiError or subclasses.
   * @param {Object} options request options
   * @returns {Object|String|any} request result
   */
  async requestWithFailover(options, retryCounter = 0, endTime = Date.now() + this._maxRetryDelay * this._retries) {
    options.timeout = this._timeout;
    let retryAfterSeconds = 0;
    options.callback = (e, res) => {
      if (res && res.statusCode === 202) {
        retryAfterSeconds = res.headers['retry-after'];
      }
    };
    let body;
    try {
      body = await this._makeRequest(options);
    } catch (err) {
      retryCounter = await this._handleError(err, retryCounter, endTime);
      return this.requestWithFailover(options, retryCounter, endTime);
    }
    if (retryAfterSeconds) {
      await this._handleRetry(endTime, retryAfterSeconds * 1000);
      body = await this.requestWithFailover(options, retryCounter, endTime);
    }
    return body;
  }

  _makeRequest(options) {
    return (0, _requestPromiseAny2.default)(options);
  }

  async _wait(pause) {
    await new _promise2.default(res => setTimeout(res, pause));
  }

  async _handleRetry(endTime, retryAfter) {
    if (endTime > Date.now() + retryAfter) {
      await this._wait(retryAfter);
    } else {
      throw new _timeoutError2.default('Timed out waiting for the response');
    }
  }

  async _handleError(err, retryCounter, endTime) {
    const error = this._convertError(err);
    if (['ConflictError', 'InternalError', 'ApiError', 'TimeoutError'].includes(error.name) && retryCounter < this._retries) {
      const pause = Math.min(Math.pow(2, retryCounter) * this._minRetryDelay, this._maxRetryDelay);
      await this._wait(pause);
      return retryCounter + 1;
    } else if (error.name === 'TooManyRequestsError') {
      const retryTime = Date.parse(error.metadata.recommendedRetryTime);
      if (retryTime < endTime) {
        await this._wait(retryTime - Date.now());
        return retryCounter;
      }
    }
    throw error;
  }

  // eslint-disable-next-line complexity
  _convertError(err) {
    err.error = err.error || {};
    let status = err.statusCode || err.status;
    switch (status) {
      case 400:
        return new _errorHandler.ValidationError(err.error.message || err.message, err.error.details || err.details);
      case 401:
        return new _errorHandler.UnauthorizedError(err.error.message || err.message);
      case 403:
        return new _errorHandler.ForbiddenError(err.error.message || err.message);
      case 404:
        return new _errorHandler.NotFoundError(err.error.message || err.message);
      case 409:
        return new _errorHandler.ConflictError(err.error.message || err.message);
      case 429:
        return new _errorHandler.TooManyRequestsError(err.error.message || err.message, err.error.metadata || err.metadata);
      case 500:
        return new _errorHandler.InternalError(err.error.message || err.message);
      default:
        return new _errorHandler.ApiError(_errorHandler.ApiError, err.error.message || err.message, status);
    }
  }

}

exports.default = HttpClient; /**
                               * HTTP client service mock for tests
                               */

class HttpClientMock extends HttpClient {

  /**
   * Constructs HTTP client mock
   * @param {Function(options:Object):Promise} requestFn mocked request function
   * @param {Number} timeout request timeout in seconds
   * @param {RetryOptions} retryOpts retry options
   */
  constructor(requestFn, timeout, extendedTimeout, retryOpts) {
    super(timeout, extendedTimeout, retryOpts);
    this._requestFn = requestFn;
  }

  _makeRequest() {
    return this._requestFn.apply(this, arguments);
  }

}
exports.HttpClientMock = HttpClientMock;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jbGllbnRzL2h0dHBDbGllbnQuZXM2Il0sIm5hbWVzIjpbIkh0dHBDbGllbnQiLCJjb25zdHJ1Y3RvciIsInRpbWVvdXQiLCJleHRlbmRlZFRpbWVvdXQiLCJyZXRyeU9wdHMiLCJfdGltZW91dCIsIl9leHRlbmRlZFRpbWVvdXQiLCJfcmV0cmllcyIsInJldHJpZXMiLCJfbWluUmV0cnlEZWxheSIsIm1pbkRlbGF5SW5TZWNvbmRzIiwiX21heFJldHJ5RGVsYXkiLCJtYXhEZWxheUluU2Vjb25kcyIsInJlcXVlc3QiLCJvcHRpb25zIiwiaXNFeHRlbmRlZFRpbWVvdXQiLCJfbWFrZVJlcXVlc3QiLCJlcnIiLCJfY29udmVydEVycm9yIiwicmVxdWVzdFdpdGhGYWlsb3ZlciIsInJldHJ5Q291bnRlciIsImVuZFRpbWUiLCJEYXRlIiwibm93IiwicmV0cnlBZnRlclNlY29uZHMiLCJjYWxsYmFjayIsImUiLCJyZXMiLCJzdGF0dXNDb2RlIiwiaGVhZGVycyIsImJvZHkiLCJfaGFuZGxlRXJyb3IiLCJfaGFuZGxlUmV0cnkiLCJfd2FpdCIsInBhdXNlIiwic2V0VGltZW91dCIsInJldHJ5QWZ0ZXIiLCJUaW1lb3V0RXJyb3IiLCJlcnJvciIsImluY2x1ZGVzIiwibmFtZSIsIk1hdGgiLCJtaW4iLCJwb3ciLCJyZXRyeVRpbWUiLCJwYXJzZSIsIm1ldGFkYXRhIiwicmVjb21tZW5kZWRSZXRyeVRpbWUiLCJzdGF0dXMiLCJWYWxpZGF0aW9uRXJyb3IiLCJtZXNzYWdlIiwiZGV0YWlscyIsIlVuYXV0aG9yaXplZEVycm9yIiwiRm9yYmlkZGVuRXJyb3IiLCJOb3RGb3VuZEVycm9yIiwiQ29uZmxpY3RFcnJvciIsIlRvb01hbnlSZXF1ZXN0c0Vycm9yIiwiSW50ZXJuYWxFcnJvciIsIkFwaUVycm9yIiwiSHR0cENsaWVudE1vY2siLCJyZXF1ZXN0Rm4iLCJfcmVxdWVzdEZuIiwiYXBwbHkiLCJhcmd1bWVudHMiXSwibWFwcGluZ3MiOiJBQUFB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O0FBQzFELFVBQU1GLE9BQU4sRUFBZUMsZUFBZixFQUFnQ0MsU0FBaEM7QUFDQSxTQUFLeUQsVUFBTCxHQUFrQkQsU0FBbEI7QUFDRDs7QUFFRDVDLGlCQUFlO0FBQ2IsV0FBTyxLQUFLNkMsVUFBTCxDQUFnQkMsS0FBaEIsQ0FBc0IsSUFBdEIsRUFBNEJDLFNBQTVCLENBQVA7QUFDRDs7QUFmNEM7UUFBbENKLGMsR0FBQUEsYyIsImZpbGUiOiJodHRwQ2xpZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgcmVxdWVzdCBmcm9tICdyZXF1ZXN0LXByb21pc2UtYW55JztcbmltcG9ydCB7XG4gIFVuYXV0aG9yaXplZEVycm9yLCBGb3JiaWRkZW5FcnJvciwgQXBpRXJyb3IsIFZhbGlkYXRpb25FcnJvciwgSW50ZXJuYWxFcnJvciwgXG4gIE5vdEZvdW5kRXJyb3IsIFRvb01hbnlSZXF1ZXN0c0Vycm9yLCBDb25mbGljdEVycm9yXG59IGZyb20gJy4vZXJyb3JIYW5kbGVyJztcbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi90aW1lb3V0RXJyb3InO1xuXG4vKipcbiAqIEhUVFAgY2xpZW50IGxpYnJhcnkgYmFzZWQgb24gcmVxdWVzdC1wcm9taXNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEh0dHBDbGllbnQge1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXRyeU9wdGlvbnMgcmV0cnkgb3B0aW9uc1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3JldHJpZXNdIHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gcmV0cnkgZmFpbGVkIHJlcXVlc3QsIGRlZmF1bHQgNVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW21pbkRlbGF5SW5TZWNvbmRzXSBtaW5pbXVtIGRlbGF5IGluIHNlY29uZHMgYmVmb3JlIHJldHJ5aW5nLCBkZWZhdWx0IDFcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFttYXhEZWxheUluU2Vjb25kc10gbWF4aW11bSBkZWxheSBpbiBzZWNvbmRzIGJlZm9yZSByZXRyeWluZywgZGVmYXVsdCAzMFxuICAgKi9cblxuICAvKipcbiAgICogQ29uc3RydWN0cyBIdHRwQ2xpZW50IGNsYXNzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW91dF0gcmVxdWVzdCB0aW1lb3V0IGluIHNlY29uZHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtleHRlbmRlZFRpbWVvdXRdIHJlcXVlc3QgdGltZW91dCBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7UmV0cnlPcHRpb25zfSBbcmV0cnlPcHRzXSByZXRyeSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aW1lb3V0ID0gMTAsIGV4dGVuZGVkVGltZW91dCA9IDcwLCByZXRyeU9wdHMgPSB7fSkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSB0aW1lb3V0ICogMTAwMDtcbiAgICB0aGlzLl9leHRlbmRlZFRpbWVvdXQgPSBleHRlbmRlZFRpbWVvdXQgKiAxMDAwO1xuICAgIHRoaXMuX3JldHJpZXMgPSByZXRyeU9wdHMucmV0cmllcyB8fCA1O1xuICAgIHRoaXMuX21pblJldHJ5RGVsYXkgPSAocmV0cnlPcHRzLm1pbkRlbGF5SW5TZWNvbmRzIHx8IDEpICogMTAwMDtcbiAgICB0aGlzLl9tYXhSZXRyeURlbGF5ID0gKHJldHJ5T3B0cy5tYXhEZWxheUluU2Vjb25kcyB8fCAzMCkgKiAxMDAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgcmVxdWVzdC4gUmVzcG9uc2UgZXJyb3JzIGFyZSByZXR1cm5lZCBhcyBBcGlFcnJvciBvciBzdWJjbGFzc2VzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyByZXF1ZXN0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0V4dGVuZGVkVGltZW91dCB3aGV0aGVyIHRvIHJ1biB0aGUgcmVxdWVzdCB3aXRoIGFuIGV4dGVuZGVkIHRpbWVvdXRcbiAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8YW55fSByZXF1ZXN0IHJlc3VsdFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdChvcHRpb25zLCBpc0V4dGVuZGVkVGltZW91dCkge1xuICAgIG9wdGlvbnMudGltZW91dCA9IGlzRXh0ZW5kZWRUaW1lb3V0ID8gdGhpcy5fZXh0ZW5kZWRUaW1lb3V0IDogdGhpcy5fdGltZW91dDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX21ha2VSZXF1ZXN0KG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgdGhpcy5fY29udmVydEVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgcmVxdWVzdCB3aXRoIGEgZmFpbG92ZXIuIFJlc3BvbnNlIGVycm9ycyBhcmUgcmV0dXJuZWQgYXMgQXBpRXJyb3Igb3Igc3ViY2xhc3Nlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgcmVxdWVzdCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfGFueX0gcmVxdWVzdCByZXN1bHRcbiAgICovXG4gIGFzeW5jIHJlcXVlc3RXaXRoRmFpbG92ZXIob3B0aW9ucywgcmV0cnlDb3VudGVyID0gMCwgZW5kVGltZSA9IERhdGUubm93KCkgKyB0aGlzLl9tYXhSZXRyeURlbGF5ICogdGhpcy5fcmV0cmllcykge1xuICAgIG9wdGlvbnMudGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgbGV0IHJldHJ5QWZ0ZXJTZWNvbmRzID0gMDtcbiAgICBvcHRpb25zLmNhbGxiYWNrID0gKGUsIHJlcykgPT4ge1xuICAgICAgaWYgKHJlcyAmJiByZXMuc3RhdHVzQ29kZSA9PT0gMjAyKSB7XG4gICAgICAgIHJldHJ5QWZ0ZXJTZWNvbmRzID0gcmVzLmhlYWRlcnNbJ3JldHJ5LWFmdGVyJ107XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHRoaXMuX21ha2VSZXF1ZXN0KG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0cnlDb3VudGVyID0gYXdhaXQgdGhpcy5faGFuZGxlRXJyb3IoZXJyLCByZXRyeUNvdW50ZXIsIGVuZFRpbWUpO1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRpb25zLCByZXRyeUNvdW50ZXIsIGVuZFRpbWUpO1xuICAgIH1cbiAgICBpZiAocmV0cnlBZnRlclNlY29uZHMpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZVJldHJ5KGVuZFRpbWUsIHJldHJ5QWZ0ZXJTZWNvbmRzICogMTAwMCk7XG4gICAgICBib2R5ID0gYXdhaXQgdGhpcy5yZXF1ZXN0V2l0aEZhaWxvdmVyKG9wdGlvbnMsIHJldHJ5Q291bnRlciwgZW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgX21ha2VSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcmVxdWVzdChvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIF93YWl0KHBhdXNlKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCBwYXVzZSkpO1xuICB9XG5cbiAgYXN5bmMgX2hhbmRsZVJldHJ5KGVuZFRpbWUsIHJldHJ5QWZ0ZXIpIHtcbiAgICBpZihlbmRUaW1lID4gRGF0ZS5ub3coKSArIHJldHJ5QWZ0ZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3dhaXQocmV0cnlBZnRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciB0aGUgcmVzcG9uc2UnKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfaGFuZGxlRXJyb3IoZXJyLCByZXRyeUNvdW50ZXIsIGVuZFRpbWUpIHtcbiAgICBjb25zdCBlcnJvciA9IHRoaXMuX2NvbnZlcnRFcnJvcihlcnIpO1xuICAgIGlmKFsnQ29uZmxpY3RFcnJvcicsICdJbnRlcm5hbEVycm9yJywgJ0FwaUVycm9yJywgJ1RpbWVvdXRFcnJvciddLmluY2x1ZGVzKGVycm9yLm5hbWUpXG4gICAgICAmJiByZXRyeUNvdW50ZXIgPCB0aGlzLl9yZXRyaWVzKSB7XG4gICAgICBjb25zdCBwYXVzZSA9IE1hdGgubWluKE1hdGgucG93KDIsIHJldHJ5Q291bnRlcikgKiB0aGlzLl9taW5SZXRyeURlbGF5LCB0aGlzLl9tYXhSZXRyeURlbGF5KTtcbiAgICAgIGF3YWl0IHRoaXMuX3dhaXQocGF1c2UpO1xuICAgICAgcmV0dXJuIHJldHJ5Q291bnRlciArIDE7XG4gICAgfSBlbHNlIGlmKGVycm9yLm5hbWUgPT09ICdUb29NYW55UmVxdWVzdHNFcnJvcicpIHtcbiAgICAgIGNvbnN0IHJldHJ5VGltZSA9IERhdGUucGFyc2UoZXJyb3IubWV0YWRhdGEucmVjb21tZW5kZWRSZXRyeVRpbWUpO1xuICAgICAgaWYgKHJldHJ5VGltZSA8IGVuZFRpbWUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fd2FpdChyZXRyeVRpbWUgLSBEYXRlLm5vdygpKTtcbiAgICAgICAgcmV0dXJuIHJldHJ5Q291bnRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBfY29udmVydEVycm9yKGVycikge1xuICAgIGVyci5lcnJvciA9IGVyci5lcnJvciB8fCB7fTtcbiAgICBsZXQgc3RhdHVzID0gZXJyLnN0YXR1c0NvZGUgfHwgZXJyLnN0YXR1cztcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgNDAwOlxuICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoZXJyLmVycm9yLm1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2UsIGVyci5lcnJvci5kZXRhaWxzIHx8IGVyci5kZXRhaWxzKTtcbiAgICBjYXNlIDQwMTpcbiAgICAgIHJldHVybiBuZXcgVW5hdXRob3JpemVkRXJyb3IoZXJyLmVycm9yLm1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2UpO1xuICAgIGNhc2UgNDAzOlxuICAgICAgcmV0dXJuIG5ldyBGb3JiaWRkZW5FcnJvcihlcnIuZXJyb3IubWVzc2FnZSB8fCBlcnIubWVzc2FnZSk7XG4gICAgY2FzZSA0MDQ6XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IoZXJyLmVycm9yLm1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2UpO1xuICAgIGNhc2UgNDA5OlxuICAgICAgcmV0dXJuIG5ldyBDb25mbGljdEVycm9yKGVyci5lcnJvci5tZXNzYWdlIHx8IGVyci5tZXNzYWdlKTtcbiAgICBjYXNlIDQyOTpcbiAgICAgIHJldHVybiBuZXcgVG9vTWFueVJlcXVlc3RzRXJyb3IoZXJyLmVycm9yLm1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2UsIGVyci5lcnJvci5tZXRhZGF0YSB8fCBlcnIubWV0YWRhdGEpO1xuICAgIGNhc2UgNTAwOlxuICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbEVycm9yKGVyci5lcnJvci5tZXNzYWdlIHx8IGVyci5tZXNzYWdlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBBcGlFcnJvcihBcGlFcnJvciwgZXJyLmVycm9yLm1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2UsIHN0YXR1cyk7XG4gICAgfVxuICB9XG5cbn1cblxuLyoqXG4gKiBIVFRQIGNsaWVudCBzZXJ2aWNlIG1vY2sgZm9yIHRlc3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBIdHRwQ2xpZW50TW9jayBleHRlbmRzIEh0dHBDbGllbnQge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIEhUVFAgY2xpZW50IG1vY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbihvcHRpb25zOk9iamVjdCk6UHJvbWlzZX0gcmVxdWVzdEZuIG1vY2tlZCByZXF1ZXN0IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IHJlcXVlc3QgdGltZW91dCBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7UmV0cnlPcHRpb25zfSByZXRyeU9wdHMgcmV0cnkgb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IocmVxdWVzdEZuLCB0aW1lb3V0LCBleHRlbmRlZFRpbWVvdXQsIHJldHJ5T3B0cykge1xuICAgIHN1cGVyKHRpbWVvdXQsIGV4dGVuZGVkVGltZW91dCwgcmV0cnlPcHRzKTtcbiAgICB0aGlzLl9yZXF1ZXN0Rm4gPSByZXF1ZXN0Rm47XG4gIH1cblxuICBfbWFrZVJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbn1cbiJdfQ==