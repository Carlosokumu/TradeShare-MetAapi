'use strict';

var _should = require('should');

var _should2 = _interopRequireDefault(_should);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _httpClient = require('./httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

var _errorHandler = require('./errorHandler');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @test {HttpClient}
 */
describe('HttpClient', () => {

  let httpClient;

  /**
   * @test {HttpClient#request}
   */
  describe('Real request', () => {

    beforeEach(() => {
      httpClient = new _httpClient2.default();
    });

    /**
     * @test {HttpClient#request}
     */
    it('should load HTML page from example.com', async () => {
      const opts = { url: 'http://example.com' };
      const response = await httpClient.request(opts);
      response.should.match(/doctype html/);
    });

    /**
     * @test {HttpClient#requestWithFailover}
     */
    it('should load HTML page from example.com with failover', async () => {
      const opts = { url: 'http://example.com' };
      const response = await httpClient.requestWithFailover(opts);
      response.should.match(/doctype html/);
    });

    /**
     * @test {HttpClient#requestWithFailover}
     */
    it('should return NotFound error if server returns 404', async () => {
      let opts = { url: 'http://example.com/not-found' };
      try {
        const response = await httpClient.requestWithFailover(opts);
        _should2.default.not.exist(response);
      } catch (err) {
        err.name.should.be.eql('NotFoundError');
      }
    });

    /**
     * @test {HttpClient#requestWithFailover}
     */
    it('should return timeout error if request is timed out', async () => {
      httpClient = new _httpClient2.default(0.001, 60, { retries: 2 });
      let opts = { url: 'http://metaapi.cloud' };
      try {
        const response = await httpClient.requestWithFailover(opts);
        _should2.default.not.exist(response);
      } catch (err) {
        err.name.should.be.eql('ApiError');
        err.message.should.be.eql('ETIMEDOUT');
      }
    }).timeout(10000);
  });

  /**
   * @test {HttpClient#requestWithFailover}
   */
  describe('Retry request', () => {

    const opts = { url: 'http://metaapi.cloud' };
    let sandbox, stub;

    before(() => {
      sandbox = _sinon2.default.createSandbox();
    });

    beforeEach(() => {
      stub = sandbox.stub();
      httpClient = new _httpClient.HttpClientMock(stub);
    });

    afterEach(() => {
      sandbox.restore();
    });

    /**
     * @test {HttpClient#requestWithFailover}
     */
    describe('when InternalError or ApiError error occured', () => {

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should retry request on fail with ApiError error', async () => {
        stub.onFirstCall().rejects(new _errorHandler.ApiError(_errorHandler.ApiError, 'test')).onSecondCall().rejects(new _errorHandler.ApiError(_errorHandler.ApiError, 'test')).onThirdCall().resolves('response');
        const response = await httpClient.requestWithFailover(opts);
        response.should.match('response');
        _sinon2.default.assert.calledThrice(stub);
      }).timeout(10000);

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should retry request on fail with InternalError error', async () => {
        stub.onFirstCall().rejects(new _errorHandler.InternalError('test')).onSecondCall().rejects(new _errorHandler.InternalError('test')).onThirdCall().resolves('response');
        const response = await httpClient.requestWithFailover(opts);
        response.should.match('response');
        _sinon2.default.assert.calledThrice(stub);
      }).timeout(10000);

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should return error if retry limit exceeded', async () => {
        stub.rejects(new _errorHandler.ApiError(_errorHandler.ApiError, 'test'));
        httpClient = new _httpClient.HttpClientMock(stub, 10, 60, { retries: 2 });
        try {
          const response = await httpClient.requestWithFailover(opts);
          _should2.default.not.exist(response);
        } catch (err) {
          err.name.should.eql('ApiError');
          err.message.should.eql('test');
        }
        _sinon2.default.assert.calledThrice(stub);
      }).timeout(10000);

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should not retry if error is neither InternalError nor ApiError', async () => {
        stub.onFirstCall().rejects(new _errorHandler.ValidationError('test')).onSecondCall().rejects(new _errorHandler.ValidationError('test')).onThirdCall().resolves('response');
        try {
          const response = await httpClient.requestWithFailover(opts);
          _should2.default.not.exist(response);
        } catch (err) {
          err.name.should.eql('ValidationError');
          err.message.should.eql('test');
        }
        _sinon2.default.assert.calledOnce(stub);
      }).timeout(10000);
    });

    /**
     * @test {HttpClient#requestWithFailover}
     */
    describe('when TooManyRequestsError error occured', () => {

      const getTooManyRequestsError = sec => {
        const date = new Date();
        date.setSeconds(date.getSeconds() + sec);
        const recommendedRetryTime = date.toUTCString();
        return new _errorHandler.TooManyRequestsError('test', { recommendedRetryTime });
      };

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should retry request after waiting on fail with TooManyRequestsError error', async () => {
        stub.onFirstCall().rejects(getTooManyRequestsError(2)).onSecondCall().rejects(getTooManyRequestsError(3)).onThirdCall().resolves('response');
        const response = await httpClient.requestWithFailover(opts);
        response.should.eql('response');
        _sinon2.default.assert.calledThrice(stub);
      }).timeout(10000);

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should return error if recommended retry time is too long', async () => {
        stub.onFirstCall().rejects(getTooManyRequestsError(2)).onSecondCall().rejects(getTooManyRequestsError(300)).onThirdCall().resolves('response');
        try {
          const response = await httpClient.requestWithFailover(opts);
          _should2.default.not.exist(response);
        } catch (err) {
          err.name.should.eql('TooManyRequestsError');
          err.message.should.eql('test');
        }
        _sinon2.default.assert.calledTwice(stub);
      }).timeout(10000);

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should not count retrying TooManyRequestsError error', async () => {
        stub.onFirstCall().rejects(getTooManyRequestsError(1)).onSecondCall().rejects(new _errorHandler.ApiError(_errorHandler.ApiError, 'test')).onThirdCall().resolves('response');
        httpClient = new _httpClient.HttpClientMock(stub, 10, 60, { retries: 1 });
        const response = await httpClient.requestWithFailover(opts);
        response.should.eql('response');
        _sinon2.default.assert.calledThrice(stub);
      }).timeout(10000);
    });

    /**
     * @test {HttpClient#requestWithFailover}
     */
    describe('when status 202 response received', () => {

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should wait for the retry-after header time before retrying', async () => {
        stub.callsFake(options => {
          options.callback(null, { headers: { 'retry-after': 3 }, statusCode: 202 });
        }).onThirdCall().resolves('response');
        const response = await httpClient.requestWithFailover(opts);
        response.should.eql('response');
        _sinon2.default.assert.calledThrice(stub);
      }).timeout(10000);

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should return TimeoutError error if retry-after header time is too long', async () => {
        stub.callsFake(options => {
          options.callback(null, { headers: { 'retry-after': 30 }, statusCode: 202 });
        });
        httpClient = new _httpClient.HttpClientMock(stub, 10, 60, { maxDelayInSeconds: 3 });
        try {
          await httpClient.requestWithFailover(opts);
          _should2.default.not.exist('Should not exist this assertion');
        } catch (err) {
          err.name.should.eql('TimeoutError');
          err.message.should.eql('Timed out waiting for the response');
        }
        _sinon2.default.assert.calledOnce(stub);
      }).timeout(10000);

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should return TimeoutError error if timed out to retry', async () => {
        stub.callsFake(options => {
          options.callback(null, { headers: { 'retry-after': 1 }, statusCode: 202 });
        });
        httpClient = new _httpClient.HttpClientMock(stub, 10, 60, { maxDelayInSeconds: 2, retries: 3 });
        try {
          await httpClient.requestWithFailover(opts);
          _should2.default.not.exist('Should not exist this assertion');
        } catch (err) {
          err.name.should.eql('TimeoutError');
          err.message.should.eql('Timed out waiting for the response');
        }
        _sinon2.default.assert.callCount(stub, 6);
      }).timeout(10000);
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jbGllbnRzL2h0dHBDbGllbnQuc3BlYy5lczYiXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJodHRwQ2xpZW50IiwiYmVmb3JlRWFjaCIsIkh0dHBDbGllbnQiLCJpdCIsIm9wdHMiLCJ1cmwiLCJyZXNwb25zZSIsInJlcXVlc3QiLCJzaG91bGQiLCJtYXRjaCIsInJlcXVlc3RXaXRoRmFpbG92ZXIiLCJub3QiLCJleGlzdCIsImVyciIsIm5hbWUiLCJiZSIsImVxbCIsInJldHJpZXMiLCJtZXNzYWdlIiwidGltZW91dCIsInNhbmRib3giLCJzdHViIiwiYmVmb3JlIiwic2lub24iLCJjcmVhdGVTYW5kYm94IiwiSHR0cENsaWVudE1vY2siLCJhZnRlckVhY2giLCJyZXN0b3JlIiwib25GaXJzdENhbGwiLCJyZWplY3RzIiwiQXBpRXJyb3IiLCJvblNlY29uZENhbGwiLCJvblRoaXJkQ2FsbCIsInJlc29sdmVzIiwiYXNzZXJ0IiwiY2FsbGVkVGhyaWNlIiwiSW50ZXJuYWxFcnJvciIsIlZhbGlkYXRpb25FcnJvciIsImNhbGxlZE9uY2UiLCJnZXRUb29NYW55UmVxdWVzdHNFcnJvciIsInNlYyIsImRhdGUiLCJEYXRlIiwic2V0U2Vjb25kcyIsImdldFNlY29uZHMiLCJyZWNvbW1lbmRlZFJldHJ5VGltZSIsInRvVVRDU3RyaW5nIiwiVG9vTWFueVJlcXVlc3RzRXJyb3IiLCJjYWxsZWRUd2ljZSIsImNhbGxzRmFrZSIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImhlYWRlcnMiLCJzdGF0dXNDb2RlIiwibWF4RGVsYXlJblNlY29uZHMiLCJjYWxsQ291bnQiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7OztBQUdBQSxTQUFTLFlBQVQsRUFBdUIsTUFBTTs7QUFFM0IsTUFBSUMsVUFBSjs7QUFFQTs7O0FBR0FELFdBQVMsY0FBVCxFQUF5QixNQUFNOztBQUU3QkUsZUFBVyxNQUFNO0FBQ2ZE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WCxDQUFpQixpQ0FBakI7QUFDRCxTQUhELENBR0UsT0FBT0MsR0FBUCxFQUFZO0FBQ1pBLGNBQUlDLElBQUosQ0FBU04sTUFBVCxDQUFnQlEsR0FBaEIsQ0FBb0IsY0FBcEI7QUFDQUgsY0FBSUssT0FBSixDQUFZVixNQUFaLENBQW1CUSxHQUFuQixDQUF1QixvQ0FBdkI7QUFDRDtBQUNETyx3QkFBTVcsTUFBTixDQUFhcUIsU0FBYixDQUF1QmxDLElBQXZCLEVBQTZCLENBQTdCO0FBQ0QsT0FiRCxFQWFHRixPQWJILENBYVcsS0FiWDtBQWVELEtBbEREO0FBb0RELEdBak1EO0FBbU1ELENBblFEIiwiZmlsZSI6Imh0dHBDbGllbnQuc3BlYy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHNob3VsZCBmcm9tICdzaG91bGQnO1xuaW1wb3J0IHNpbm9uICBmcm9tICdzaW5vbic7XG5pbXBvcnQgSHR0cENsaWVudCwge0h0dHBDbGllbnRNb2NrfSBmcm9tICcuL2h0dHBDbGllbnQnO1xuaW1wb3J0IHtWYWxpZGF0aW9uRXJyb3IsIEFwaUVycm9yLCBJbnRlcm5hbEVycm9yLCBUb29NYW55UmVxdWVzdHNFcnJvcn0gZnJvbSAnLi9lcnJvckhhbmRsZXInO1xuXG4vKipcbiAqIEB0ZXN0IHtIdHRwQ2xpZW50fVxuICovXG5kZXNjcmliZSgnSHR0cENsaWVudCcsICgpID0+IHtcblxuICBsZXQgaHR0cENsaWVudDtcblxuICAvKipcbiAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdH1cbiAgICovXG4gIGRlc2NyaWJlKCdSZWFsIHJlcXVlc3QnLCAoKSA9PiB7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudCgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdH1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGxvYWQgSFRNTCBwYWdlIGZyb20gZXhhbXBsZS5jb20nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRzID0ge3VybDogJ2h0dHA6Ly9leGFtcGxlLmNvbSd9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3Qob3B0cyk7XG4gICAgICByZXNwb25zZS5zaG91bGQubWF0Y2goL2RvY3R5cGUgaHRtbC8pO1xuICAgIH0pO1xuICBcbiAgICAvKipcbiAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0V2l0aEZhaWxvdmVyfVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgbG9hZCBIVE1MIHBhZ2UgZnJvbSBleGFtcGxlLmNvbSB3aXRoIGZhaWxvdmVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0cyA9IHt1cmw6ICdodHRwOi8vZXhhbXBsZS5jb20nfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yZXF1ZXN0V2l0aEZhaWxvdmVyKG9wdHMpO1xuICAgICAgcmVzcG9uc2Uuc2hvdWxkLm1hdGNoKC9kb2N0eXBlIGh0bWwvKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gTm90Rm91bmQgZXJyb3IgaWYgc2VydmVyIHJldHVybnMgNDA0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IG9wdHMgPSB7dXJsOiAnaHR0cDovL2V4YW1wbGUuY29tL25vdC1mb3VuZCd9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3RXaXRoRmFpbG92ZXIob3B0cyk7XG4gICAgICAgIHNob3VsZC5ub3QuZXhpc3QocmVzcG9uc2UpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5uYW1lLnNob3VsZC5iZS5lcWwoJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdGltZW91dCBlcnJvciBpZiByZXF1ZXN0IGlzIHRpbWVkIG91dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudCgwLjAwMSwgNjAsIHtyZXRyaWVzOiAyfSk7XG4gICAgICBsZXQgb3B0cyA9IHt1cmw6ICdodHRwOi8vbWV0YWFwaS5jbG91ZCd9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3RXaXRoRmFpbG92ZXIob3B0cyk7XG4gICAgICAgIHNob3VsZC5ub3QuZXhpc3QocmVzcG9uc2UpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5uYW1lLnNob3VsZC5iZS5lcWwoJ0FwaUVycm9yJyk7XG4gICAgICAgIGVyci5tZXNzYWdlLnNob3VsZC5iZS5lcWwoJ0VUSU1FRE9VVCcpO1xuICAgICAgfVxuICAgIH0pLnRpbWVvdXQoMTAwMDApO1xuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0V2l0aEZhaWxvdmVyfVxuICAgKi9cbiAgZGVzY3JpYmUoJ1JldHJ5IHJlcXVlc3QnLCAoKSA9PiB7XG5cbiAgICBjb25zdCBvcHRzID0ge3VybDogJ2h0dHA6Ly9tZXRhYXBpLmNsb3VkJ307XG4gICAgbGV0IHNhbmRib3gsIHN0dWI7XG5cbiAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgc2FuZGJveCA9IHNpbm9uLmNyZWF0ZVNhbmRib3goKTtcbiAgICB9KTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgc3R1YiA9IHNhbmRib3guc3R1YigpO1xuICAgICAgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50TW9jayhzdHViKTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBzYW5kYm94LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICovXG4gICAgZGVzY3JpYmUoJ3doZW4gSW50ZXJuYWxFcnJvciBvciBBcGlFcnJvciBlcnJvciBvY2N1cmVkJywgKCkgPT4ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgKi9cbiAgICAgIGl0KCdzaG91bGQgcmV0cnkgcmVxdWVzdCBvbiBmYWlsIHdpdGggQXBpRXJyb3IgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHN0dWIub25GaXJzdENhbGwoKS5yZWplY3RzKG5ldyBBcGlFcnJvcihBcGlFcnJvciwgJ3Rlc3QnKSlcbiAgICAgICAgICAub25TZWNvbmRDYWxsKCkucmVqZWN0cyhuZXcgQXBpRXJyb3IoQXBpRXJyb3IsICd0ZXN0JykpXG4gICAgICAgICAgLm9uVGhpcmRDYWxsKCkucmVzb2x2ZXMoJ3Jlc3BvbnNlJyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yZXF1ZXN0V2l0aEZhaWxvdmVyKG9wdHMpO1xuICAgICAgICByZXNwb25zZS5zaG91bGQubWF0Y2goJ3Jlc3BvbnNlJyk7XG4gICAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRUaHJpY2Uoc3R1Yik7XG4gICAgICB9KS50aW1lb3V0KDEwMDAwKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0V2l0aEZhaWxvdmVyfVxuICAgICAgICovXG4gICAgICBpdCgnc2hvdWxkIHJldHJ5IHJlcXVlc3Qgb24gZmFpbCB3aXRoIEludGVybmFsRXJyb3IgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHN0dWIub25GaXJzdENhbGwoKS5yZWplY3RzKG5ldyBJbnRlcm5hbEVycm9yKCd0ZXN0JykpXG4gICAgICAgICAgLm9uU2Vjb25kQ2FsbCgpLnJlamVjdHMobmV3IEludGVybmFsRXJyb3IoJ3Rlc3QnKSlcbiAgICAgICAgICAub25UaGlyZENhbGwoKS5yZXNvbHZlcygncmVzcG9uc2UnKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3RXaXRoRmFpbG92ZXIob3B0cyk7XG4gICAgICAgIHJlc3BvbnNlLnNob3VsZC5tYXRjaCgncmVzcG9uc2UnKTtcbiAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFRocmljZShzdHViKTtcbiAgICAgIH0pLnRpbWVvdXQoMTAwMDApO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgKi9cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGVycm9yIGlmIHJldHJ5IGxpbWl0IGV4Y2VlZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBzdHViLnJlamVjdHMobmV3IEFwaUVycm9yKEFwaUVycm9yLCAndGVzdCcpKTtcbiAgICAgICAgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50TW9jayhzdHViLCAxMCwgNjAsIHtyZXRyaWVzOiAyfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3RXaXRoRmFpbG92ZXIob3B0cyk7XG4gICAgICAgICAgc2hvdWxkLm5vdC5leGlzdChyZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVyci5uYW1lLnNob3VsZC5lcWwoJ0FwaUVycm9yJyk7XG4gICAgICAgICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmVxbCgndGVzdCcpO1xuICAgICAgICB9XG4gICAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRUaHJpY2Uoc3R1Yik7XG4gICAgICB9KS50aW1lb3V0KDEwMDAwKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0V2l0aEZhaWxvdmVyfVxuICAgICAgICovXG4gICAgICBpdCgnc2hvdWxkIG5vdCByZXRyeSBpZiBlcnJvciBpcyBuZWl0aGVyIEludGVybmFsRXJyb3Igbm9yIEFwaUVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBzdHViLm9uRmlyc3RDYWxsKCkucmVqZWN0cyhuZXcgVmFsaWRhdGlvbkVycm9yKCd0ZXN0JykpXG4gICAgICAgICAgLm9uU2Vjb25kQ2FsbCgpLnJlamVjdHMobmV3IFZhbGlkYXRpb25FcnJvcigndGVzdCcpKVxuICAgICAgICAgIC5vblRoaXJkQ2FsbCgpLnJlc29sdmVzKCdyZXNwb25zZScpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yZXF1ZXN0V2l0aEZhaWxvdmVyKG9wdHMpO1xuICAgICAgICAgIHNob3VsZC5ub3QuZXhpc3QocmVzcG9uc2UpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBlcnIubmFtZS5zaG91bGQuZXFsKCdWYWxpZGF0aW9uRXJyb3InKTtcbiAgICAgICAgICBlcnIubWVzc2FnZS5zaG91bGQuZXFsKCd0ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2Uoc3R1Yik7XG4gICAgICB9KS50aW1lb3V0KDEwMDAwKTtcblxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdFdpdGhGYWlsb3Zlcn1cbiAgICAgKi9cbiAgICBkZXNjcmliZSgnd2hlbiBUb29NYW55UmVxdWVzdHNFcnJvciBlcnJvciBvY2N1cmVkJywgKCkgPT4ge1xuXG4gICAgICBjb25zdCBnZXRUb29NYW55UmVxdWVzdHNFcnJvciA9IChzZWMpID0+IHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcyhkYXRlLmdldFNlY29uZHMoKSArIHNlYyk7XG4gICAgICAgIGNvbnN0IHJlY29tbWVuZGVkUmV0cnlUaW1lID0gZGF0ZS50b1VUQ1N0cmluZygpO1xuICAgICAgICByZXR1cm4gbmV3IFRvb01hbnlSZXF1ZXN0c0Vycm9yKCd0ZXN0Jywge3JlY29tbWVuZGVkUmV0cnlUaW1lfSk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgKi9cbiAgICAgIGl0KCdzaG91bGQgcmV0cnkgcmVxdWVzdCBhZnRlciB3YWl0aW5nIG9uIGZhaWwgd2l0aCBUb29NYW55UmVxdWVzdHNFcnJvciBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgc3R1Yi5vbkZpcnN0Q2FsbCgpLnJlamVjdHMoZ2V0VG9vTWFueVJlcXVlc3RzRXJyb3IoMikpXG4gICAgICAgICAgLm9uU2Vjb25kQ2FsbCgpLnJlamVjdHMoZ2V0VG9vTWFueVJlcXVlc3RzRXJyb3IoMykpXG4gICAgICAgICAgLm9uVGhpcmRDYWxsKCkucmVzb2x2ZXMoJ3Jlc3BvbnNlJyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yZXF1ZXN0V2l0aEZhaWxvdmVyKG9wdHMpO1xuICAgICAgICByZXNwb25zZS5zaG91bGQuZXFsKCdyZXNwb25zZScpO1xuICAgICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkVGhyaWNlKHN0dWIpO1xuICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdFdpdGhGYWlsb3Zlcn1cbiAgICAgICAqL1xuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZXJyb3IgaWYgcmVjb21tZW5kZWQgcmV0cnkgdGltZSBpcyB0b28gbG9uZycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgc3R1Yi5vbkZpcnN0Q2FsbCgpLnJlamVjdHMoZ2V0VG9vTWFueVJlcXVlc3RzRXJyb3IoMikpXG4gICAgICAgICAgLm9uU2Vjb25kQ2FsbCgpLnJlamVjdHMoZ2V0VG9vTWFueVJlcXVlc3RzRXJyb3IoMzAwKSlcbiAgICAgICAgICAub25UaGlyZENhbGwoKS5yZXNvbHZlcygncmVzcG9uc2UnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgICBzaG91bGQubm90LmV4aXN0KHJlc3BvbnNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxbCgnVG9vTWFueVJlcXVlc3RzRXJyb3InKTtcbiAgICAgICAgICBlcnIubWVzc2FnZS5zaG91bGQuZXFsKCd0ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFR3aWNlKHN0dWIpO1xuICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdFdpdGhGYWlsb3Zlcn1cbiAgICAgICAqL1xuICAgICAgaXQoJ3Nob3VsZCBub3QgY291bnQgcmV0cnlpbmcgVG9vTWFueVJlcXVlc3RzRXJyb3IgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHN0dWIub25GaXJzdENhbGwoKS5yZWplY3RzKGdldFRvb01hbnlSZXF1ZXN0c0Vycm9yKDEpKVxuICAgICAgICAgIC5vblNlY29uZENhbGwoKS5yZWplY3RzKG5ldyBBcGlFcnJvcihBcGlFcnJvciwgJ3Rlc3QnKSlcbiAgICAgICAgICAub25UaGlyZENhbGwoKS5yZXNvbHZlcygncmVzcG9uc2UnKTtcbiAgICAgICAgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50TW9jayhzdHViLCAxMCwgNjAsIHtyZXRyaWVzOiAxfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yZXF1ZXN0V2l0aEZhaWxvdmVyKG9wdHMpO1xuICAgICAgICByZXNwb25zZS5zaG91bGQuZXFsKCdyZXNwb25zZScpO1xuICAgICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkVGhyaWNlKHN0dWIpO1xuICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICovXG4gICAgZGVzY3JpYmUoJ3doZW4gc3RhdHVzIDIwMiByZXNwb25zZSByZWNlaXZlZCcsICgpID0+IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0V2l0aEZhaWxvdmVyfVxuICAgICAgICovXG4gICAgICBpdCgnc2hvdWxkIHdhaXQgZm9yIHRoZSByZXRyeS1hZnRlciBoZWFkZXIgdGltZSBiZWZvcmUgcmV0cnlpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHN0dWIuY2FsbHNGYWtlKChvcHRpb25zKT0+IHtcbiAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKG51bGwsIHtoZWFkZXJzOiB7J3JldHJ5LWFmdGVyJzogM30sIHN0YXR1c0NvZGU6IDIwMn0pO1xuICAgICAgICB9KS5vblRoaXJkQ2FsbCgpLnJlc29sdmVzKCdyZXNwb25zZScpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgcmVzcG9uc2Uuc2hvdWxkLmVxbCgncmVzcG9uc2UnKTtcbiAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFRocmljZShzdHViKTtcbiAgICAgIH0pLnRpbWVvdXQoMTAwMDApO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgKi9cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFRpbWVvdXRFcnJvciBlcnJvciBpZiByZXRyeS1hZnRlciBoZWFkZXIgdGltZSBpcyB0b28gbG9uZycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgc3R1Yi5jYWxsc0Zha2UoKG9wdGlvbnMpPT4ge1xuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sobnVsbCwge2hlYWRlcnM6IHsncmV0cnktYWZ0ZXInOiAzMH0sIHN0YXR1c0NvZGU6IDIwMn0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50TW9jayhzdHViLCAxMCwgNjAsIHttYXhEZWxheUluU2Vjb25kczogM30pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgICBzaG91bGQubm90LmV4aXN0KCdTaG91bGQgbm90IGV4aXN0IHRoaXMgYXNzZXJ0aW9uJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVyci5uYW1lLnNob3VsZC5lcWwoJ1RpbWVvdXRFcnJvcicpO1xuICAgICAgICAgIGVyci5tZXNzYWdlLnNob3VsZC5lcWwoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciB0aGUgcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZShzdHViKTtcbiAgICAgIH0pLnRpbWVvdXQoMTAwMDApO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgKi9cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFRpbWVvdXRFcnJvciBlcnJvciBpZiB0aW1lZCBvdXQgdG8gcmV0cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHN0dWIuY2FsbHNGYWtlKChvcHRpb25zKT0+IHtcbiAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKG51bGwsIHtoZWFkZXJzOiB7J3JldHJ5LWFmdGVyJzogMX0sIHN0YXR1c0NvZGU6IDIwMn0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50TW9jayhzdHViLCAxMCwgNjAsIHttYXhEZWxheUluU2Vjb25kczogMiwgcmV0cmllczogM30pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgICBzaG91bGQubm90LmV4aXN0KCdTaG91bGQgbm90IGV4aXN0IHRoaXMgYXNzZXJ0aW9uJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVyci5uYW1lLnNob3VsZC5lcWwoJ1RpbWVvdXRFcnJvcicpO1xuICAgICAgICAgIGVyci5tZXNzYWdlLnNob3VsZC5lcWwoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciB0aGUgcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBzaW5vbi5hc3NlcnQuY2FsbENvdW50KHN0dWIsIDYpO1xuICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICB9KTtcblxuICB9KTtcblxufSk7XG4iXX0=