'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _historyDatabase = require('./historyDatabase');

var _historyDatabase2 = _interopRequireDefault(_historyDatabase);

var _logger = require('../../logger');

var _logger2 = _interopRequireDefault(_logger);

var _idb = require('idb');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Provides access to history database stored in a browser IndexedDB
 */
class BrowserHistoryDatabase extends _historyDatabase2.default {

  /**
   * Constructs the class instance
   */
  constructor() {
    super();
    this._logger = _logger2.default.getLogger('BrowserHistoryDatabase');
  }

  /**
   * Returns history database instance
   * @returns {HistoryDatabase} history database instance
   */
  static getInstance() {
    if (!BrowserHistoryDatabase.instance) {
      BrowserHistoryDatabase.instance = new BrowserHistoryDatabase();
    }
    return BrowserHistoryDatabase.instance;
  }

  /**
   * Loads history from database
   * @param {string} accountId account id
   * @param {string} application application name
   * @return {Promise<{deals: Array<MetatraderDeal>, historyOrders: Array<MetatraderOrder>}>} full account history
   */
  async loadHistory(accountId, application) {
    let db;
    try {
      db = await this._getDatabase();
      let deals = await this._readDb(db, 'deals', accountId + '-' + application);
      deals.forEach(deal => deal.time = new Date(deal.time));
      let historyOrders = await this._readDb(db, 'historyOrders', accountId + '-' + application);
      historyOrders.forEach(historyOrder => {
        historyOrder.time = new Date(historyOrder.time);
        historyOrder.doneTime = new Date(historyOrder.doneTime);
      });
      return { deals, historyOrders };
    } catch (err) {
      this._logger.warn(`${accountId}: failed to read history database, will reinitialize it now`, err);
      await this.clear(accountId, application);
      return { deals: [], historyOrders: [] };
    } finally {
      try {
        await db.close();
      } catch (err) {
        this._logger.error(`${accountId}: error closing db`, err);
      }
    }
  }

  /**
   * Removes history from database
   * @param {string} accountId account id
   * @param {string} application application name
   * @return {Promise} promise resolving when the history is removed
   */
  async clear(accountId, application) {
    const prefix = accountId + '-' + application;
    const range = IDBKeyRange.bound(prefix, prefix + ':');
    let db;
    try {
      db = await this._getDatabase();
      await db.delete('deals', range);
      await db.delete('dealsIndex', range);
      await db.delete('historyOrders', range);
      await db.delete('historyOrdersIndex', range);
    } catch (e) {
      this._logger.warn(`${accountId}: failed to clear history storage`, e);
    } finally {
      try {
        await db.close();
      } catch (err) {
        this._logger.error(`${accountId}: error closing db`, err);
      }
    }
  }

  /**
   * Flushes the new history to db
   * @param {string} accountId account id
   * @param {string} application application name
   * @param {Array<MetatraderOrder>} newHistoryOrders history orders to save to db
   * @param {Array<MetatraderDeal>} newDeals deals to save to db
   * @return {Promise} promise resolving when the history is flushed
   */
  async flush(accountId, application, newHistoryOrders, newDeals) {
    let db;
    try {
      db = await this._getDatabase();
      await this._appendDb(db, 'deals', accountId + '-' + application, newDeals);
      await this._appendDb(db, 'historyOrders', accountId + '-' + application, newHistoryOrders);
    } catch (e) {
      this._logger.warn(`${accountId}: failed to flush history storage`, e);
    } finally {
      try {
        await db.close();
      } catch (err) {
        this._logger.error(`${accountId}: error closing db`, err);
      }
    }
  }

  async _getDatabase() {
    const keyPath = 'id';
    const db = await (0, _idb.openDB)('metaapi', 2, {
      upgrade(database, oldVersion, newVersion, transaction) {
        if (oldVersion !== 2) {
          if (database.objectStoreNames.contains('deals')) {
            database.deleteObjectStore('deals');
          }
          if (database.objectStoreNames.contains('historyOrders')) {
            database.deleteObjectStore('historyOrders');
          }
        }
        if (!database.objectStoreNames.contains('dealsIndex')) {
          database.createObjectStore('dealsIndex', { keyPath });
        }
        if (!database.objectStoreNames.contains('deals')) {
          database.createObjectStore('deals', { keyPath });
        }
        if (!database.objectStoreNames.contains('historyOrdersIndex')) {
          database.createObjectStore('historyOrdersIndex', { keyPath });
        }
        if (!database.objectStoreNames.contains('historyOrders')) {
          database.createObjectStore('historyOrders', { keyPath });
        }
      }
    });
    return db;
  }

  async _readDb(db, store, prefix) {
    const keys = await db.getAllKeys(store, IDBKeyRange.bound(prefix, prefix + '-' + ':'));
    let result = [];
    for (let key of keys) {
      let value = await db.get(store, key);
      if (value) {
        for (let line of value.data.split('\n')) {
          if (line.length) {
            let record = JSON.parse(line);
            result.push(record);
          }
        }
      }
    }
    return result;
  }

  async _appendDb(db, store, prefix, records) {
    if (records && records.length) {
      let lastKey = await db.get(store + 'Index', prefix + '-' + 'sn');
      let index = (lastKey || { index: 0 }).index + 1;
      let data = records.map(r => (0, _stringify2.default)(r) + '\n').join('');
      await db.put(store, { data, id: prefix + '-' + index });
      await db.put(store + 'Index', { id: prefix + '-' + 'sn', index });
    }
  }

}
exports.default = BrowserHistoryDatabase;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9tZXRhQXBpL2hpc3RvcnlEYXRhYmFzZS9icm93c2VySGlzdG9yeURhdGFiYXNlLmVzNiJdLCJuYW1lcyI6WyJCcm93c2VySGlzdG9yeURhdGFiYXNlIiwiSGlzdG9yeURhdGFiYXNlIiwiY29uc3RydWN0b3IiLCJfbG9nZ2VyIiwiTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImxvYWRIaXN0b3J5IiwiYWNjb3VudElkIiwiYXBwbGljYXRpb24iLCJkYiIsIl9nZXREYXRhYmFzZSIsImRlYWxzIiwiX3JlYWREYiIsImZvckVhY2giLCJkZWFsIiwidGltZSIsIkRhdGUiLCJoaXN0b3J5T3JkZXJzIiwiaGlzdG9yeU9yZGVyIiwiZG9uZVRpbWUiLCJlcnIiLCJ3YXJuIiwiY2xlYXIiLCJjbG9zZSIsImVycm9yIiwicHJlZml4IiwicmFuZ2UiLCJJREJLZXlSYW5nZSIsImJvdW5kIiwiZGVsZXRlIiwiZSIsImZsdXNoIiwibmV3SGlzdG9yeU9yZGVycyIsIm5ld0RlYWxzIiwiX2FwcGVuZERiIiwia2V5UGF0aCIsInVwZ3JhZGUiLCJkYXRhYmFzZSIsIm9sZFZlcnNpb24iLCJuZXdWZXJzaW9uIiwidHJhbnNhY3Rpb24iLCJvYmplY3RTdG9yZU5hbWVzIiwiY29udGFpbnMiLCJkZWxldGVPYmplY3RTdG9yZSIsImNyZWF0ZU9iamVjdFN0b3JlIiwic3RvcmUiLCJrZXlzIiwiZ2V0QWxsS2V5cyIsInJlc3VsdCIsImtleSIsInZhbHVlIiwiZ2V0IiwibGluZSIsImRhdGEiLCJzcGxpdCIsImxlbmd0aCIsInJlY29yZCIsIkpTT04iLCJwYXJzZSIsInB1c2giLCJyZWNvcmRzIiwibGFzdEtleSIsImluZGV4IiwibWFwIiwiciIsImpvaW4iLCJwdXQiLCJpZCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7O0FBR2UsTUFBTUEsc0JBQU4sU0FBcUND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LEdBQWUsSUFBcEIsRUFBMEJxQyxLQUExQixFQUF4QixDQUFOO0FBQ0Q7QUFDRjs7QUE5SmlFO2tCQUEvQ2hFLHNCIiwiZmlsZSI6ImJyb3dzZXJIaXN0b3J5RGF0YWJhc2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBIaXN0b3J5RGF0YWJhc2UgZnJvbSAnLi9oaXN0b3J5RGF0YWJhc2UnO1xuaW1wb3J0IExvZ2dlciBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHtvcGVuREJ9IGZyb20gJ2lkYic7XG5cbi8qKlxuICogUHJvdmlkZXMgYWNjZXNzIHRvIGhpc3RvcnkgZGF0YWJhc2Ugc3RvcmVkIGluIGEgYnJvd3NlciBJbmRleGVkREJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJvd3Nlckhpc3RvcnlEYXRhYmFzZSBleHRlbmRzIEhpc3RvcnlEYXRhYmFzZSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGNsYXNzIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoJ0Jyb3dzZXJIaXN0b3J5RGF0YWJhc2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcnkgZGF0YWJhc2UgaW5zdGFuY2VcbiAgICogQHJldHVybnMge0hpc3RvcnlEYXRhYmFzZX0gaGlzdG9yeSBkYXRhYmFzZSBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgIGlmICghQnJvd3Nlckhpc3RvcnlEYXRhYmFzZS5pbnN0YW5jZSkge1xuICAgICAgQnJvd3Nlckhpc3RvcnlEYXRhYmFzZS5pbnN0YW5jZSA9IG5ldyBCcm93c2VySGlzdG9yeURhdGFiYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiBCcm93c2VySGlzdG9yeURhdGFiYXNlLmluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIGhpc3RvcnkgZnJvbSBkYXRhYmFzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFwcGxpY2F0aW9uIGFwcGxpY2F0aW9uIG5hbWVcbiAgICogQHJldHVybiB7UHJvbWlzZTx7ZGVhbHM6IEFycmF5PE1ldGF0cmFkZXJEZWFsPiwgaGlzdG9yeU9yZGVyczogQXJyYXk8TWV0YXRyYWRlck9yZGVyPn0+fSBmdWxsIGFjY291bnQgaGlzdG9yeVxuICAgKi9cbiAgYXN5bmMgbG9hZEhpc3RvcnkoYWNjb3VudElkLCBhcHBsaWNhdGlvbikge1xuICAgIGxldCBkYjtcbiAgICB0cnkge1xuICAgICAgZGIgPSBhd2FpdCB0aGlzLl9nZXREYXRhYmFzZSgpO1xuICAgICAgbGV0IGRlYWxzID0gYXdhaXQgdGhpcy5fcmVhZERiKGRiLCAnZGVhbHMnLCBhY2NvdW50SWQgKyAnLScgKyBhcHBsaWNhdGlvbik7XG4gICAgICBkZWFscy5mb3JFYWNoKGRlYWwgPT4gZGVhbC50aW1lID0gbmV3IERhdGUoZGVhbC50aW1lKSk7XG4gICAgICBsZXQgaGlzdG9yeU9yZGVycyA9IGF3YWl0IHRoaXMuX3JlYWREYihkYiwgJ2hpc3RvcnlPcmRlcnMnLCBhY2NvdW50SWQgKyAnLScgKyBhcHBsaWNhdGlvbik7XG4gICAgICBoaXN0b3J5T3JkZXJzLmZvckVhY2goaGlzdG9yeU9yZGVyID0+IHtcbiAgICAgICAgaGlzdG9yeU9yZGVyLnRpbWUgPSBuZXcgRGF0ZShoaXN0b3J5T3JkZXIudGltZSk7XG4gICAgICAgIGhpc3RvcnlPcmRlci5kb25lVGltZSA9IG5ldyBEYXRlKGhpc3RvcnlPcmRlci5kb25lVGltZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7ZGVhbHMsIGhpc3RvcnlPcmRlcnN9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYCR7YWNjb3VudElkfTogZmFpbGVkIHRvIHJlYWQgaGlzdG9yeSBkYXRhYmFzZSwgd2lsbCByZWluaXRpYWxpemUgaXQgbm93YCwgZXJyKTtcbiAgICAgIGF3YWl0IHRoaXMuY2xlYXIoYWNjb3VudElkLCBhcHBsaWNhdGlvbik7XG4gICAgICByZXR1cm4ge2RlYWxzOiBbXSwgaGlzdG9yeU9yZGVyczogW119O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBkYi5jbG9zZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHthY2NvdW50SWR9OiBlcnJvciBjbG9zaW5nIGRiYCwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBoaXN0b3J5IGZyb20gZGF0YWJhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBsaWNhdGlvbiBhcHBsaWNhdGlvbiBuYW1lXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGhpc3RvcnkgaXMgcmVtb3ZlZFxuICAgKi9cbiAgYXN5bmMgY2xlYXIoYWNjb3VudElkLCBhcHBsaWNhdGlvbikge1xuICAgIGNvbnN0IHByZWZpeCA9IGFjY291bnRJZCArICctJyArIGFwcGxpY2F0aW9uO1xuICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQocHJlZml4LCBwcmVmaXggKyAnOicpO1xuICAgIGxldCBkYjtcbiAgICB0cnkge1xuICAgICAgZGIgPSBhd2FpdCB0aGlzLl9nZXREYXRhYmFzZSgpO1xuICAgICAgYXdhaXQgZGIuZGVsZXRlKCdkZWFscycsIHJhbmdlKTtcbiAgICAgIGF3YWl0IGRiLmRlbGV0ZSgnZGVhbHNJbmRleCcsIHJhbmdlKTtcbiAgICAgIGF3YWl0IGRiLmRlbGV0ZSgnaGlzdG9yeU9yZGVycycsIHJhbmdlKTtcbiAgICAgIGF3YWl0IGRiLmRlbGV0ZSgnaGlzdG9yeU9yZGVyc0luZGV4JywgcmFuZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGAke2FjY291bnRJZH06IGZhaWxlZCB0byBjbGVhciBoaXN0b3J5IHN0b3JhZ2VgLCBlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGIuY2xvc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7YWNjb3VudElkfTogZXJyb3IgY2xvc2luZyBkYmAsIGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoZXMgdGhlIG5ldyBoaXN0b3J5IHRvIGRiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwbGljYXRpb24gYXBwbGljYXRpb24gbmFtZVxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJPcmRlcj59IG5ld0hpc3RvcnlPcmRlcnMgaGlzdG9yeSBvcmRlcnMgdG8gc2F2ZSB0byBkYlxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJEZWFsPn0gbmV3RGVhbHMgZGVhbHMgdG8gc2F2ZSB0byBkYlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBoaXN0b3J5IGlzIGZsdXNoZWRcbiAgICovXG4gIGFzeW5jIGZsdXNoKGFjY291bnRJZCwgYXBwbGljYXRpb24sIG5ld0hpc3RvcnlPcmRlcnMsIG5ld0RlYWxzKSB7XG4gICAgbGV0IGRiO1xuICAgIHRyeSB7XG4gICAgICBkYiA9IGF3YWl0IHRoaXMuX2dldERhdGFiYXNlKCk7XG4gICAgICBhd2FpdCB0aGlzLl9hcHBlbmREYihkYiwgJ2RlYWxzJywgYWNjb3VudElkICsgJy0nICsgYXBwbGljYXRpb24sIG5ld0RlYWxzKTtcbiAgICAgIGF3YWl0IHRoaXMuX2FwcGVuZERiKGRiLCAnaGlzdG9yeU9yZGVycycsIGFjY291bnRJZCArICctJyArIGFwcGxpY2F0aW9uLCBuZXdIaXN0b3J5T3JkZXJzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLl9sb2dnZXIud2FybihgJHthY2NvdW50SWR9OiBmYWlsZWQgdG8gZmx1c2ggaGlzdG9yeSBzdG9yYWdlYCwgZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGRiLmNsb3NlKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke2FjY291bnRJZH06IGVycm9yIGNsb3NpbmcgZGJgLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9nZXREYXRhYmFzZSgpIHtcbiAgICBjb25zdCBrZXlQYXRoID0gJ2lkJztcbiAgICBjb25zdCBkYiA9IGF3YWl0IG9wZW5EQignbWV0YWFwaScsIDIsIHtcbiAgICAgIHVwZ3JhZGUoZGF0YWJhc2UsIG9sZFZlcnNpb24sIG5ld1ZlcnNpb24sIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmIChvbGRWZXJzaW9uICE9PSAyKSB7XG4gICAgICAgICAgaWYgKGRhdGFiYXNlLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ2RlYWxzJykpIHtcbiAgICAgICAgICAgIGRhdGFiYXNlLmRlbGV0ZU9iamVjdFN0b3JlKCdkZWFscycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YWJhc2Uub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnaGlzdG9yeU9yZGVycycpKSB7XG4gICAgICAgICAgICBkYXRhYmFzZS5kZWxldGVPYmplY3RTdG9yZSgnaGlzdG9yeU9yZGVycycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFiYXNlLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ2RlYWxzSW5kZXgnKSkge1xuICAgICAgICAgIGRhdGFiYXNlLmNyZWF0ZU9iamVjdFN0b3JlKCdkZWFsc0luZGV4Jywge2tleVBhdGh9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFiYXNlLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ2RlYWxzJykpIHtcbiAgICAgICAgICBkYXRhYmFzZS5jcmVhdGVPYmplY3RTdG9yZSgnZGVhbHMnLCB7a2V5UGF0aH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YWJhc2Uub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnaGlzdG9yeU9yZGVyc0luZGV4JykpIHtcbiAgICAgICAgICBkYXRhYmFzZS5jcmVhdGVPYmplY3RTdG9yZSgnaGlzdG9yeU9yZGVyc0luZGV4Jywge2tleVBhdGh9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFiYXNlLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ2hpc3RvcnlPcmRlcnMnKSkge1xuICAgICAgICAgIGRhdGFiYXNlLmNyZWF0ZU9iamVjdFN0b3JlKCdoaXN0b3J5T3JkZXJzJywge2tleVBhdGh9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gZGI7XG4gIH1cblxuICBhc3luYyBfcmVhZERiKGRiLCBzdG9yZSwgcHJlZml4KSB7XG4gICAgY29uc3Qga2V5cyA9IGF3YWl0IGRiLmdldEFsbEtleXMoc3RvcmUsIElEQktleVJhbmdlLmJvdW5kKHByZWZpeCwgcHJlZml4ICsgJy0nICsgJzonKSk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgdmFsdWUgPSBhd2FpdCBkYi5nZXQoc3RvcmUsIGtleSk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB2YWx1ZS5kYXRhLnNwbGl0KCdcXG4nKSkge1xuICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlY29yZCA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChyZWNvcmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgX2FwcGVuZERiKGRiLCBzdG9yZSwgcHJlZml4LCByZWNvcmRzKSB7XG4gICAgaWYgKHJlY29yZHMgJiYgcmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgIGxldCBsYXN0S2V5ID0gYXdhaXQgZGIuZ2V0KHN0b3JlICsgJ0luZGV4JywgcHJlZml4ICsgJy0nICsgJ3NuJyk7XG4gICAgICBsZXQgaW5kZXggPSAobGFzdEtleSB8fCB7aW5kZXg6IDB9KS5pbmRleCArIDE7XG4gICAgICBsZXQgZGF0YSA9IHJlY29yZHMubWFwKHIgPT4gSlNPTi5zdHJpbmdpZnkocikgKyAnXFxuJykuam9pbignJyk7XG4gICAgICBhd2FpdCBkYi5wdXQoc3RvcmUsIHtkYXRhLCBpZDogcHJlZml4ICsgJy0nICsgaW5kZXh9KTtcbiAgICAgIGF3YWl0IGRiLnB1dChzdG9yZSArICdJbmRleCcsIHtpZDogcHJlZml4ICsgJy0nICsgJ3NuJywgaW5kZXh9KTtcbiAgICB9XG4gIH1cblxufVxuIl19