'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _synchronizationListener = require('../clients/metaApi/synchronizationListener');

var _synchronizationListener2 = _interopRequireDefault(_synchronizationListener);

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Exposes MetaApi MetaTrader API connection to consumers
 */
class MetaApiConnection extends _synchronizationListener2.default {

  /**
   * Constructs MetaApi MetaTrader Api connection
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   * @param {String} [application] application to use
   */
  constructor(websocketClient, account, application) {
    super();
    this._websocketClient = websocketClient;
    this._account = account;
    this._logger = _logger2.default.getLogger('MetaApiConnection');
    this._application = application;
  }

  /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @return {Promise} promise resolving when the connection is opened
   */
  async connect() {}

  /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   */
  async close() {}

  /**
   * Common trade options
   * @typedef {Object} TradeOptions
   * @property {String} [comment] optional order comment. The sum of the line lengths of the comment and the
   * clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [clientId] optional client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {Number} [magic] optional magic (expert id) number. If not set default value specified in account entity
   * will be used.
   * @property {Number} [slippage] optional slippage in points. Should be greater or equal to zero. In not set,
   * default value specified in account entity will be used. Slippage is ignored if execution mode set to
   * SYMBOL_TRADE_EXECUTION_MARKET in symbol specification. Not used for close by orders.
   */

  /**
   * Market trade options
   * @typedef {TradeOptions} MarketTradeOptions
   * @property {Array<String>} [fillingModes] optional allowed filling modes in the order of priority. Default is to
   * allow all filling modes and prefer ORDER_FILLING_FOK over ORDER_FILLING_IOC. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_filling for extra
   * explanation
   */

  /**
   * Market trade options
   * @typedef {MarketTradeOptions} CreateMarketTradeOptions
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defines the base price to calculate SL/TP relative to for pending order
   * requests. Default is CURRENT_PRICE, one of CURRENT_PRICE
   */

  /**
   * Pending order trade options
   * @typedef {TradeOptions} PendingTradeOptions
   * @property {ExpirationOptions} [expiration] optional pending order expiration settings. See Pending order expiration
   * settings section
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defined the base price to calculate SL/TP relative to for *_MODIFY and pending
   * order requests. STOP_PRICE means the SL/TP is relative to previous SL/TP value. Default is OPEN_PRICE, one of
   * CURRENT_PRICE, OPEN_PRICE
   * @property {String} [openPriceUnits] open price units. ABSOLUTE_PRICE means the that the value of openPrice field
   * is a final open price value. RELATIVE* means that the openPrice field value contains relative open price expressed
   * either in price, points, pips, account currency or balance percentage. Default is ABSOLUTE_PRICE. One of
   * ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   */

  /**
   * Options for creating a stop limit pending order
   * @typedef {PendingTradeOptions} StopLimitPendingTradeOptions
   * @property {String} [openPriceBase] defined the base price to calculate open price relative to for ORDER_MODIFY
   * and pending order requests. Default is CURRENT_PRICE for pending orders or STOP_LIMIT_PRICE for stop limit orders.
   * One of CURRENT_PRICE, OPEN_PRICE, STOP_LIMIT_PRICE
   * @property {String} [stopLimitPriceUnits] stop limit price units. ABSOLUTE_PRICE means the that the value of
   * stopLimitPrice field is a final stop limit price value. RELATIVE* means that the stopLimitPrice field value
   * contains relative stop limit price expressed either in price, points, pips, account currency or balance percentage.
   * Default is ABSOLUTE_PRICE. One of ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY,
   * RELATIVE_BALANCE_PERCENTAGE
   */

  /**
   * Options for modifying orders
   * @typedef {Object} ModifyOrderOptions
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {String} [stopPriceBase] defined the base price to calculate SL/TP relative to for *_MODIFY and pending
   * order requests. STOP_PRICE means the SL/TP is relative to previous SL/TP value. Default is OPEN_PRICE, one of
   * CURRENT_PRICE, OPEN_PRICE, STOP_PRICE
   * @property {String} [openPriceUnits] open price units. ABSOLUTE_PRICE means the that the value of openPrice field
   * is a final open price value. RELATIVE* means that the openPrice field value contains relative open price expressed
   * either in price, points, pips, account currency or balance percentage. Default is ABSOLUTE_PRICE. One of
   * ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   * @property {String} [openPriceBase] defined the base price to calculate open price relative to for ORDER_MODIFY
   * and pending order requests. Default is CURRENT_PRICE for pending orders or STOP_LIMIT_PRICE for stop limit orders.
   * One of CURRENT_PRICE, OPEN_PRICE, STOP_LIMIT_PRICE
   * @property {String} [stopLimitPriceUnits] stop limit price units. ABSOLUTE_PRICE means the that the value of
   * stopLimitPrice field is a final stop limit price value. RELATIVE* means that the stopLimitPrice field value
   * contains relative stop limit price expressed either in price, points, pips, account currency or balance percentage.
   * Default is ABSOLUTE_PRICE. One of ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY,
   * RELATIVE_BALANCE_PERCENTAGE
   * @property {String} [stopLimitPriceBase] Defined the base price to calculate stop limit price relative to for
   * ORDER_MODIFY requests. One of CURRENT_PRICE, STOP_LIMIT_PRICE
   */

  /**
   * Pending order expiration settings
   * @typedef {Object} ExpirationOptions
   * @property {String} type pending order expiration type. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_time for the list of
   * possible options. MetaTrader4 platform supports only ORDER_TIME_SPECIFIED expiration type. One of ORDER_TIME_GTC,
   * ORDER_TIME_DAY, ORDER_TIME_SPECIFIED, ORDER_TIME_SPECIFIED_DAY
   * @property {Date} [time] optional pending order expiration time. Ignored if expiration type is not one of
   * ORDER_TIME_DAY or ORDER_TIME_SPECIFIED
   */

  /**
   * Stop options
   * @typedef {Object} StopOptions
   * @property {number} value stop (SL or TP) value
   * @property {string} units stop units. ABSOLUTE_PRICE means the that the value of value field is a final stop value.
   * RELATIVE_* means that the value field value contains relative stop expressed either in price, points, pips, account
   * currency or balance percentage. Default is ABSOLUTE_PRICE. Allowed values are ABSOLUTE_PRICE, RELATIVE_PRICE,
   * RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   */

  /**
   * Creates a market buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {CreateMarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createMarketBuyOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY', symbol, volume }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a market sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {CreateMarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createMarketSellOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL', symbol, volume }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a limit buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {String} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createLimitBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY_LIMIT', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a limit sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createLimitSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL_LIMIT', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY_STOP', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL_STOP', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop limit buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {StopLimitPendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopLimitBuyOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY_STOP_LIMIT',
      symbol, volume, openPrice, stopLimitPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop limit sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {StopLimitPendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopLimitSellOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL_STOP_LIMIT',
      symbol, volume, openPrice, stopLimitPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Modifies a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to modify
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {TrailingStopLoss} trailingStopLoss distance trailing stop loss configuration
   * @param {String} [stopPriceBase] defines the base price to calculate SL relative to for POSITION_MODIFY and
   * pending order requests. Default is OPEN_PRICE. One of CURRENT_PRICE, OPEN_PRICE, STOP_PRICE
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  modifyPosition(positionId, stopLoss, takeProfit, trailingStopLoss, stopPriceBase) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'POSITION_MODIFY', positionId, trailingStopLoss, stopPriceBase }, this._generateStopOptions(stopLoss, takeProfit)));
  }

  /**
   * Partially closes a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to modify
   * @param {number} volume volume to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closePositionPartially(positionId, volume, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'POSITION_PARTIAL', positionId,
      volume }, options || {}));
  }

  /**
   * Fully closes a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to modify
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closePosition(positionId, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'POSITION_CLOSE_ID', positionId }, options || {}));
  }

  /**
   * Fully closes a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to close by opposite position
   * @param {string} oppositePositionId opposite position id to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closeBy(positionId, oppositePositionId, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'POSITION_CLOSE_BY', positionId,
      closeByPositionId: oppositePositionId }, options || {}));
  }

  /**
   * Closes positions by a symbol(see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closePositionsBySymbol(symbol, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'POSITIONS_CLOSE_SYMBOL', symbol }, options || {}));
  }

  /**
   * Modifies a pending order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} orderId order id (ticket number)
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {ModifyOrderOptions} [options] optional modify order options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  modifyOrder(orderId, openPrice, stopLoss, takeProfit, options = {}) {
    this._checkIsConnectionActive();
    return this._trade((0, _assign2.default)({ actionType: 'ORDER_MODIFY', orderId, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Cancels order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} orderId order id (ticket number)
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  cancelOrder(orderId) {
    this._checkIsConnectionActive();
    return this._trade({ actionType: 'ORDER_CANCEL', orderId });
  }

  _trade(request) {
    return this._websocketClient.trade(this._account.id, request, this._application, this._account.reliability);
  }

  /**
   * Calculates margin required to open a trade on the specified trading account (see
   * https://metaapi.cloud/docs/client/websocket/api/calculateMargin/).
   * @param {MarginOrder} order order to calculate margin for
   * @returns {Promise<Margin>} promise resolving with margin calculation result
   */
  calculateMargin(order) {
    this._checkIsConnectionActive();
    return this._websocketClient.calculateMargin(this._account.id, this._application, this._account.reliability, order);
  }

  /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */
  get account() {
    return this._account;
  }
  _generateStopOptions(stopLoss, takeProfit) {
    let trade = {};
    if (typeof stopLoss === 'number') {
      trade.stopLoss = stopLoss;
    } else if (stopLoss) {
      trade.stopLoss = stopLoss.value;
      trade.stopLossUnits = stopLoss.units;
    }
    if (typeof takeProfit === 'number') {
      trade.takeProfit = takeProfit;
    } else if (takeProfit) {
      trade.takeProfit = takeProfit.value;
      trade.takeProfitUnits = takeProfit.units;
    }
    return trade;
  }

  async _ensureSynchronized(instanceIndex, key) {
    let state = this._getState(instanceIndex);
    if (state && !this._closed) {
      try {
        const synchronizationResult = await this.synchronize(instanceIndex);
        if (synchronizationResult) {
          state.synchronized = true;
          state.synchronizationRetryIntervalInSeconds = 1;
        }
      } catch (err) {
        this._logger.error('MetaApi websocket client for account ' + this._account.id + ':' + instanceIndex + ' failed to synchronize', err);
        if (state.shouldSynchronize === key) {
          setTimeout(this._ensureSynchronized.bind(this, instanceIndex, key), state.synchronizationRetryIntervalInSeconds * 1000);
          state.synchronizationRetryIntervalInSeconds = Math.min(state.synchronizationRetryIntervalInSeconds * 2, 300);
        }
      }
    }
  }

  _getState(instanceIndex) {
    if (!this._stateByInstanceIndex['' + instanceIndex]) {
      this._stateByInstanceIndex['' + instanceIndex] = {
        instanceIndex,
        ordersSynchronized: {},
        dealsSynchronized: {},
        shouldSynchronize: undefined,
        synchronizationRetryIntervalInSeconds: 1,
        synchronized: false,
        lastDisconnectedSynchronizationId: undefined,
        lastSynchronizationId: undefined,
        disconnected: false
      };
    }
    return this._stateByInstanceIndex['' + instanceIndex];
  }

  _checkIsConnectionActive() {
    if (!this._opened) {
      throw new Error('This connection has not been initialized yet, please invoke await connection.connect()');
    }
    if (this._closed) {
      throw new Error('This connection has been closed, please create a new connection');
    }
  }

}
exports.default = MetaApiConnection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9tZXRhQXBpL21ldGFBcGlDb25uZWN0aW9uLmVzNiJdLCJuYW1lcyI6WyJNZXRhQXBpQ29ubmVjdGlvbiIsIlN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiY29uc3RydWN0b3IiLCJ3ZWJzb2NrZXRDbGllbnQiLCJhY2NvdW50IiwiYXBwbGljYXRpb24iLCJfd2Vic29ja2V0Q2xpZW50IiwiX2FjY291bnQiLCJfbG9nZ2VyIiwiTG9nZ2VyTWFuYWdlciIsImdldExvZ2dlciIsIl9hcHBsaWNhdGlvbiIsImNvbm5lY3QiLCJjbG9zZSIsImNyZWF0ZU1hcmtldEJ1eU9yZGVyIiwic3ltYm9sIiwidm9sdW1lIiwic3RvcExvc3MiLCJ0YWtlUHJvZml0Iiwib3B0aW9ucyIsIl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSIsIl90cmFkZSIsImFjdGlvblR5cGUiLCJfZ2VuZXJhdGVTdG9wT3B0aW9ucyIsImNyZWF0ZU1hcmtldFNlbGxPcmRlciIsImNyZWF0ZUxpbWl0QnV5T3JkZXIiLCJvcGVuUHJpY2UiLCJjcmVhdGVMaW1pdFNlbGxPcmRlciIsImNyZWF0ZVN0b3BCdXlPcmRlciIsImNyZWF0ZVN0b3BTZWxsT3JkZXIiLCJjcmVhdGVTdG9wTGltaXRCdXlPcmRlciIsInN0b3BMaW1pdFByaWNlIiwiY3JlYXRlU3RvcExpbWl0U2VsbE9yZGVyIiwibW9kaWZ5UG9zaXRpb24iLCJwb3NpdGlvbklkIiwidHJhaWxpbmdTdG9wTG9zcyIsInN0b3BQcmljZUJhc2UiLCJjbG9zZVBvc2l0aW9uUGFydGlhbGx5IiwiY2xvc2VQb3NpdGlvbiIsImNsb3NlQnkiLCJvcHBvc2l0ZVBvc2l0aW9uSWQiLCJjbG9zZUJ5UG9zaXRpb25JZCIsImNsb3NlUG9zaXRpb25zQnlTeW1ib2wiLCJtb2RpZnlPcmRlciIsIm9yZGVySWQiLCJjYW5jZWxPcmRlciIsInJlcXVlc3QiLCJ0cmFkZSIsImlkIiwicmVsaWFiaWxpdHkiLCJjYWxjdWxhdGVNYXJnaW4iLCJvcmRlciIsInZhbHVlIiwic3RvcExvc3NVbml0cyIsInVuaXRzIiwidGFrZVByb2ZpdFVuaXRzIiwiX2Vuc3VyZVN5bmNocm9uaXplZCIsImluc3RhbmNlSW5kZXgiLCJrZXkiLCJzdGF0ZSIsIl9nZXRTdGF0ZSIsIl9jbG9zZWQiLCJzeW5jaHJvbml6YXRpb25SZXN1bHQiLCJzeW5jaHJvbml6ZSIsInN5bmNocm9uaXplZCIsInN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMiLCJlcnIiLCJlcnJvciIsInNob3VsZFN5bmNocm9uaXplIiwic2V0VGltZW91dCIsImJpbmQiLCJNYXRoIiwibWluIiwiX3N0YXRlQnlJbnN0YW5jZUluZGV4Iiwib3JkZXJzU3luY2hyb25pemVkIiwiZGVhbHNTeW5jaHJvbml6ZWQiLCJ1bmRlZmluZWQiLCJsYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQiLCJsYXN0U3luY2hyb25pemF0aW9uSWQiLCJkaXNjb25uZWN0ZWQiLCJfb3BlbmVkIiwiRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7Ozs7O0FBRUE7OztBQUdlLE1BQU1BLGlCQUFOLFNBQWdDQyxpQ0FBaEMsQ0FBd0Q7O0FBRXJFOzs7Ozs7QUFNQUMsY0FBWUMsZUFBWixFQUE2QkMsT0FBN0IsRUFBc0NDLFdBQXRDLEVBQW1EO0FBQ2pEO0FBQ0EsU0FBS0MsZ0JBQUwsR0FBd0JILGVBQXhCO0FBQ0EsU0FBS0ksUUFBTCxHQUFnQkgsT0FBaEI7QUFDQSxTQUFLSSxPQUFMLEdBQWVDLGlCQUFjQyxTQUFkLENBQXdCLG1CQUF4QixDQUFmO0FBQ0EsU0FBS0MsWUFBTCxHQUFvQk4sV0FBcEI7QUFDRDs7QUFFRDs7OztBQUlBLFFBQU1PLE9BQU4sR0FBZ0IsQ0FBRTs7QUFFbEI7OztBQUdBLFFBQU1DLEtBQU4sR0FBYyxDQUFFOztBQUVoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7Ozs7O0FB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aEQ7QUFFQU4sZ0JBQU1NLHFDQUFOLEdBQThDTSxLQUFLQyxHQUFMLENBQVNiLE1BQU1NLHFDQUFOLEdBQThDLENBQXZELEVBQTBELEdBQTFELENBQTlDO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRURMLFlBQVVILGFBQVYsRUFBeUI7QUFDdkIsUUFBSSxDQUFDLEtBQUtnQixxQkFBTCxDQUEyQixLQUFLaEIsYUFBaEMsQ0FBTCxFQUFxRDtBQUNuRCxXQUFLZ0IscUJBQUwsQ0FBMkIsS0FBS2hCLGFBQWhDLElBQWlEO0FBQy9DQSxxQkFEK0M7QUFFL0NpQiw0QkFBb0IsRUFGMkI7QUFHL0NDLDJCQUFtQixFQUg0QjtBQUkvQ1AsMkJBQW1CUSxTQUo0QjtBQUsvQ1gsK0NBQXVDLENBTFE7QUFNL0NELHNCQUFjLEtBTmlDO0FBTy9DYSwyQ0FBbUNELFNBUFk7QUFRL0NFLCtCQUF1QkYsU0FSd0I7QUFTL0NHLHNCQUFjO0FBVGlDLE9BQWpEO0FBV0Q7QUFDRCxXQUFPLEtBQUtOLHFCQUFMLENBQTJCLEtBQUtoQixhQUFoQyxDQUFQO0FBQ0Q7O0FBRURyQyw2QkFBMkI7QUFDekIsUUFBRyxDQUFDLEtBQUs0RCxPQUFULEVBQWtCO0FBQ2hCLFlBQU0sSUFBSUMsS0FBSixDQUFVLHdGQUFWLENBQU47QUFDRDtBQUNELFFBQUcsS0FBS3BCLE9BQVIsRUFBaUI7QUFDZixZQUFNLElBQUlvQixLQUFKLENBQVUsaUVBQVYsQ0FBTjtBQUNEO0FBQ0Y7O0FBcGNvRTtrQkFBbERqRixpQiIsImZpbGUiOiJtZXRhQXBpQ29ubmVjdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIGZyb20gJy4uL2NsaWVudHMvbWV0YUFwaS9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcic7XG5pbXBvcnQgTG9nZ2VyTWFuYWdlciBmcm9tICcuLi9sb2dnZXInO1xuXG4vKipcbiAqIEV4cG9zZXMgTWV0YUFwaSBNZXRhVHJhZGVyIEFQSSBjb25uZWN0aW9uIHRvIGNvbnN1bWVyc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXRhQXBpQ29ubmVjdGlvbiBleHRlbmRzIFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBNZXRhQXBpIE1ldGFUcmFkZXIgQXBpIGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50fSB3ZWJzb2NrZXRDbGllbnQgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50XG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnR9IGFjY291bnQgTWV0YVRyYWRlciBhY2NvdW50IGlkIHRvIGNvbm5lY3QgdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IFthcHBsaWNhdGlvbl0gYXBwbGljYXRpb24gdG8gdXNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3ZWJzb2NrZXRDbGllbnQsIGFjY291bnQsIGFwcGxpY2F0aW9uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQgPSB3ZWJzb2NrZXRDbGllbnQ7XG4gICAgdGhpcy5fYWNjb3VudCA9IGFjY291bnQ7XG4gICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyTWFuYWdlci5nZXRMb2dnZXIoJ01ldGFBcGlDb25uZWN0aW9uJyk7XG4gICAgdGhpcy5fYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgY29ubmVjdGlvbi4gQ2FuIG9ubHkgYmUgY2FsbGVkIHRoZSBmaXJzdCB0aW1lLCBuZXh0IGNhbGxzIHdpbGwgYmUgaWdub3JlZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWRcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoKSB7fVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uIFRoZSBpbnN0YW5jZSBvZiB0aGUgY2xhc3Mgc2hvdWxkIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyIHRoaXMgbWV0aG9kIGlzIGludm9rZWQuXG4gICAqL1xuICBhc3luYyBjbG9zZSgpIHt9XG4gIFxuICAvKipcbiAgICogQ29tbW9uIHRyYWRlIG9wdGlvbnNcbiAgICogQHR5cGVkZWYge09iamVjdH0gVHJhZGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY29tbWVudF0gb3B0aW9uYWwgb3JkZXIgY29tbWVudC4gVGhlIHN1bSBvZiB0aGUgbGluZSBsZW5ndGhzIG9mIHRoZSBjb21tZW50IGFuZCB0aGVcbiAgICogY2xpZW50SWQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjYuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvY2xpZW50SWRVc2FnZS9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjbGllbnRJZF0gb3B0aW9uYWwgY2xpZW50LWFzc2lnbmVkIGlkLiBUaGUgaWQgdmFsdWUgY2FuIGJlIGFzc2lnbmVkIHdoZW4gc3VibWl0dGluZyBhIHRyYWRlIGFuZFxuICAgKiB3aWxsIGJlIHByZXNlbnQgb24gcG9zaXRpb24sIGhpc3Rvcnkgb3JkZXJzIGFuZCBoaXN0b3J5IGRlYWxzIHJlbGF0ZWQgdG8gdGhlIHRyYWRlLiBZb3UgY2FuIHVzZSB0aGlzIGZpZWxkIHRvIGJpbmRcbiAgICogeW91ciB0cmFkZXMgdG8gb2JqZWN0cyBpbiB5b3VyIGFwcGxpY2F0aW9uIGFuZCB0aGVuIHRyYWNrIHRyYWRlIHByb2dyZXNzLiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlXG4gICAqIGNvbW1lbnQgYW5kIHRoZSBjbGllbnRJZCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gW21hZ2ljXSBvcHRpb25hbCBtYWdpYyAoZXhwZXJ0IGlkKSBudW1iZXIuIElmIG5vdCBzZXQgZGVmYXVsdCB2YWx1ZSBzcGVjaWZpZWQgaW4gYWNjb3VudCBlbnRpdHlcbiAgICogd2lsbCBiZSB1c2VkLlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3NsaXBwYWdlXSBvcHRpb25hbCBzbGlwcGFnZSBpbiBwb2ludHMuIFNob3VsZCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIHplcm8uIEluIG5vdCBzZXQsXG4gICAqIGRlZmF1bHQgdmFsdWUgc3BlY2lmaWVkIGluIGFjY291bnQgZW50aXR5IHdpbGwgYmUgdXNlZC4gU2xpcHBhZ2UgaXMgaWdub3JlZCBpZiBleGVjdXRpb24gbW9kZSBzZXQgdG9cbiAgICogU1lNQk9MX1RSQURFX0VYRUNVVElPTl9NQVJLRVQgaW4gc3ltYm9sIHNwZWNpZmljYXRpb24uIE5vdCB1c2VkIGZvciBjbG9zZSBieSBvcmRlcnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNYXJrZXQgdHJhZGUgb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7VHJhZGVPcHRpb25zfSBNYXJrZXRUcmFkZU9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtBcnJheTxTdHJpbmc+fSBbZmlsbGluZ01vZGVzXSBvcHRpb25hbCBhbGxvd2VkIGZpbGxpbmcgbW9kZXMgaW4gdGhlIG9yZGVyIG9mIHByaW9yaXR5LiBEZWZhdWx0IGlzIHRvXG4gICAqIGFsbG93IGFsbCBmaWxsaW5nIG1vZGVzIGFuZCBwcmVmZXIgT1JERVJfRklMTElOR19GT0sgb3ZlciBPUkRFUl9GSUxMSU5HX0lPQy4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvb3JkZXJwcm9wZXJ0aWVzI2VudW1fb3JkZXJfdHlwZV9maWxsaW5nIGZvciBleHRyYVxuICAgKiBleHBsYW5hdGlvblxuICAgKi9cblxuICAvKipcbiAgICogTWFya2V0IHRyYWRlIG9wdGlvbnNcbiAgICogQHR5cGVkZWYge01hcmtldFRyYWRlT3B0aW9uc30gQ3JlYXRlTWFya2V0VHJhZGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7VHJhaWxpbmdTdG9wTG9zc30gW3RyYWlsaW5nU3RvcExvc3NdIGRpc3RhbmNlIHRyYWlsaW5nIHN0b3AgbG9zcyBjb25maWd1cmF0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcFByaWNlQmFzZV0gZGVmaW5lcyB0aGUgYmFzZSBwcmljZSB0byBjYWxjdWxhdGUgU0wvVFAgcmVsYXRpdmUgdG8gZm9yIHBlbmRpbmcgb3JkZXJcbiAgICogcmVxdWVzdHMuIERlZmF1bHQgaXMgQ1VSUkVOVF9QUklDRSwgb25lIG9mIENVUlJFTlRfUFJJQ0VcbiAgICovXG5cbiAgLyoqXG4gICAqIFBlbmRpbmcgb3JkZXIgdHJhZGUgb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7VHJhZGVPcHRpb25zfSBQZW5kaW5nVHJhZGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7RXhwaXJhdGlvbk9wdGlvbnN9IFtleHBpcmF0aW9uXSBvcHRpb25hbCBwZW5kaW5nIG9yZGVyIGV4cGlyYXRpb24gc2V0dGluZ3MuIFNlZSBQZW5kaW5nIG9yZGVyIGV4cGlyYXRpb25cbiAgICogc2V0dGluZ3Mgc2VjdGlvblxuICAgKiBAcHJvcGVydHkge1RyYWlsaW5nU3RvcExvc3N9IFt0cmFpbGluZ1N0b3BMb3NzXSBkaXN0YW5jZSB0cmFpbGluZyBzdG9wIGxvc3MgY29uZmlndXJhdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N0b3BQcmljZUJhc2VdIGRlZmluZWQgdGhlIGJhc2UgcHJpY2UgdG8gY2FsY3VsYXRlIFNML1RQIHJlbGF0aXZlIHRvIGZvciAqX01PRElGWSBhbmQgcGVuZGluZ1xuICAgKiBvcmRlciByZXF1ZXN0cy4gU1RPUF9QUklDRSBtZWFucyB0aGUgU0wvVFAgaXMgcmVsYXRpdmUgdG8gcHJldmlvdXMgU0wvVFAgdmFsdWUuIERlZmF1bHQgaXMgT1BFTl9QUklDRSwgb25lIG9mXG4gICAqIENVUlJFTlRfUFJJQ0UsIE9QRU5fUFJJQ0VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcGVuUHJpY2VVbml0c10gb3BlbiBwcmljZSB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mIG9wZW5QcmljZSBmaWVsZFxuICAgKiBpcyBhIGZpbmFsIG9wZW4gcHJpY2UgdmFsdWUuIFJFTEFUSVZFKiBtZWFucyB0aGF0IHRoZSBvcGVuUHJpY2UgZmllbGQgdmFsdWUgY29udGFpbnMgcmVsYXRpdmUgb3BlbiBwcmljZSBleHByZXNzZWRcbiAgICogZWl0aGVyIGluIHByaWNlLCBwb2ludHMsIHBpcHMsIGFjY291bnQgY3VycmVuY3kgb3IgYmFsYW5jZSBwZXJjZW50YWdlLiBEZWZhdWx0IGlzIEFCU09MVVRFX1BSSUNFLiBPbmUgb2ZcbiAgICogQUJTT0xVVEVfUFJJQ0UsIFJFTEFUSVZFX1BSSUNFLCBSRUxBVElWRV9QT0lOVFMsIFJFTEFUSVZFX1BJUFMsIFJFTEFUSVZFX0NVUlJFTkNZLCBSRUxBVElWRV9CQUxBTkNFX1BFUkNFTlRBR0VcbiAgICovXG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgc3RvcCBsaW1pdCBwZW5kaW5nIG9yZGVyXG4gICAqIEB0eXBlZGVmIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBTdG9wTGltaXRQZW5kaW5nVHJhZGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbb3BlblByaWNlQmFzZV0gZGVmaW5lZCB0aGUgYmFzZSBwcmljZSB0byBjYWxjdWxhdGUgb3BlbiBwcmljZSByZWxhdGl2ZSB0byBmb3IgT1JERVJfTU9ESUZZXG4gICAqIGFuZCBwZW5kaW5nIG9yZGVyIHJlcXVlc3RzLiBEZWZhdWx0IGlzIENVUlJFTlRfUFJJQ0UgZm9yIHBlbmRpbmcgb3JkZXJzIG9yIFNUT1BfTElNSVRfUFJJQ0UgZm9yIHN0b3AgbGltaXQgb3JkZXJzLlxuICAgKiBPbmUgb2YgQ1VSUkVOVF9QUklDRSwgT1BFTl9QUklDRSwgU1RPUF9MSU1JVF9QUklDRVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N0b3BMaW1pdFByaWNlVW5pdHNdIHN0b3AgbGltaXQgcHJpY2UgdW5pdHMuIEFCU09MVVRFX1BSSUNFIG1lYW5zIHRoZSB0aGF0IHRoZSB2YWx1ZSBvZlxuICAgKiBzdG9wTGltaXRQcmljZSBmaWVsZCBpcyBhIGZpbmFsIHN0b3AgbGltaXQgcHJpY2UgdmFsdWUuIFJFTEFUSVZFKiBtZWFucyB0aGF0IHRoZSBzdG9wTGltaXRQcmljZSBmaWVsZCB2YWx1ZVxuICAgKiBjb250YWlucyByZWxhdGl2ZSBzdG9wIGxpbWl0IHByaWNlIGV4cHJlc3NlZCBlaXRoZXIgaW4gcHJpY2UsIHBvaW50cywgcGlwcywgYWNjb3VudCBjdXJyZW5jeSBvciBiYWxhbmNlIHBlcmNlbnRhZ2UuXG4gICAqIERlZmF1bHQgaXMgQUJTT0xVVEVfUFJJQ0UuIE9uZSBvZiBBQlNPTFVURV9QUklDRSwgUkVMQVRJVkVfUFJJQ0UsIFJFTEFUSVZFX1BPSU5UUywgUkVMQVRJVkVfUElQUywgUkVMQVRJVkVfQ1VSUkVOQ1ksXG4gICAqIFJFTEFUSVZFX0JBTEFOQ0VfUEVSQ0VOVEFHRVxuICAgKi9cblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgbW9kaWZ5aW5nIG9yZGVyc1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNb2RpZnlPcmRlck9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtUcmFpbGluZ1N0b3BMb3NzfSBbdHJhaWxpbmdTdG9wTG9zc10gZGlzdGFuY2UgdHJhaWxpbmcgc3RvcCBsb3NzIGNvbmZpZ3VyYXRpb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzdG9wUHJpY2VCYXNlXSBkZWZpbmVkIHRoZSBiYXNlIHByaWNlIHRvIGNhbGN1bGF0ZSBTTC9UUCByZWxhdGl2ZSB0byBmb3IgKl9NT0RJRlkgYW5kIHBlbmRpbmdcbiAgICogb3JkZXIgcmVxdWVzdHMuIFNUT1BfUFJJQ0UgbWVhbnMgdGhlIFNML1RQIGlzIHJlbGF0aXZlIHRvIHByZXZpb3VzIFNML1RQIHZhbHVlLiBEZWZhdWx0IGlzIE9QRU5fUFJJQ0UsIG9uZSBvZlxuICAgKiBDVVJSRU5UX1BSSUNFLCBPUEVOX1BSSUNFLCBTVE9QX1BSSUNFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbb3BlblByaWNlVW5pdHNdIG9wZW4gcHJpY2UgdW5pdHMuIEFCU09MVVRFX1BSSUNFIG1lYW5zIHRoZSB0aGF0IHRoZSB2YWx1ZSBvZiBvcGVuUHJpY2UgZmllbGRcbiAgICogaXMgYSBmaW5hbCBvcGVuIHByaWNlIHZhbHVlLiBSRUxBVElWRSogbWVhbnMgdGhhdCB0aGUgb3BlblByaWNlIGZpZWxkIHZhbHVlIGNvbnRhaW5zIHJlbGF0aXZlIG9wZW4gcHJpY2UgZXhwcmVzc2VkXG4gICAqIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50IGN1cnJlbmN5IG9yIGJhbGFuY2UgcGVyY2VudGFnZS4gRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gT25lIG9mXG4gICAqIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSwgUkVMQVRJVkVfUE9JTlRTLCBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSwgUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbb3BlblByaWNlQmFzZV0gZGVmaW5lZCB0aGUgYmFzZSBwcmljZSB0byBjYWxjdWxhdGUgb3BlbiBwcmljZSByZWxhdGl2ZSB0byBmb3IgT1JERVJfTU9ESUZZXG4gICAqIGFuZCBwZW5kaW5nIG9yZGVyIHJlcXVlc3RzLiBEZWZhdWx0IGlzIENVUlJFTlRfUFJJQ0UgZm9yIHBlbmRpbmcgb3JkZXJzIG9yIFNUT1BfTElNSVRfUFJJQ0UgZm9yIHN0b3AgbGltaXQgb3JkZXJzLlxuICAgKiBPbmUgb2YgQ1VSUkVOVF9QUklDRSwgT1BFTl9QUklDRSwgU1RPUF9MSU1JVF9QUklDRVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N0b3BMaW1pdFByaWNlVW5pdHNdIHN0b3AgbGltaXQgcHJpY2UgdW5pdHMuIEFCU09MVVRFX1BSSUNFIG1lYW5zIHRoZSB0aGF0IHRoZSB2YWx1ZSBvZlxuICAgKiBzdG9wTGltaXRQcmljZSBmaWVsZCBpcyBhIGZpbmFsIHN0b3AgbGltaXQgcHJpY2UgdmFsdWUuIFJFTEFUSVZFKiBtZWFucyB0aGF0IHRoZSBzdG9wTGltaXRQcmljZSBmaWVsZCB2YWx1ZVxuICAgKiBjb250YWlucyByZWxhdGl2ZSBzdG9wIGxpbWl0IHByaWNlIGV4cHJlc3NlZCBlaXRoZXIgaW4gcHJpY2UsIHBvaW50cywgcGlwcywgYWNjb3VudCBjdXJyZW5jeSBvciBiYWxhbmNlIHBlcmNlbnRhZ2UuXG4gICAqIERlZmF1bHQgaXMgQUJTT0xVVEVfUFJJQ0UuIE9uZSBvZiBBQlNPTFVURV9QUklDRSwgUkVMQVRJVkVfUFJJQ0UsIFJFTEFUSVZFX1BPSU5UUywgUkVMQVRJVkVfUElQUywgUkVMQVRJVkVfQ1VSUkVOQ1ksXG4gICAqIFJFTEFUSVZFX0JBTEFOQ0VfUEVSQ0VOVEFHRVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N0b3BMaW1pdFByaWNlQmFzZV0gRGVmaW5lZCB0aGUgYmFzZSBwcmljZSB0byBjYWxjdWxhdGUgc3RvcCBsaW1pdCBwcmljZSByZWxhdGl2ZSB0byBmb3JcbiAgICogT1JERVJfTU9ESUZZIHJlcXVlc3RzLiBPbmUgb2YgQ1VSUkVOVF9QUklDRSwgU1RPUF9MSU1JVF9QUklDRVxuICAgKi9cblxuICAvKipcbiAgICogUGVuZGluZyBvcmRlciBleHBpcmF0aW9uIHNldHRpbmdzXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEV4cGlyYXRpb25PcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIHBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvbiB0eXBlLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl90eXBlX3RpbWUgZm9yIHRoZSBsaXN0IG9mXG4gICAqIHBvc3NpYmxlIG9wdGlvbnMuIE1ldGFUcmFkZXI0IHBsYXRmb3JtIHN1cHBvcnRzIG9ubHkgT1JERVJfVElNRV9TUEVDSUZJRUQgZXhwaXJhdGlvbiB0eXBlLiBPbmUgb2YgT1JERVJfVElNRV9HVEMsXG4gICAqIE9SREVSX1RJTUVfREFZLCBPUkRFUl9USU1FX1NQRUNJRklFRCwgT1JERVJfVElNRV9TUEVDSUZJRURfREFZXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gW3RpbWVdIG9wdGlvbmFsIHBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvbiB0aW1lLiBJZ25vcmVkIGlmIGV4cGlyYXRpb24gdHlwZSBpcyBub3Qgb25lIG9mXG4gICAqIE9SREVSX1RJTUVfREFZIG9yIE9SREVSX1RJTUVfU1BFQ0lGSUVEXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTdG9wIG9wdGlvbnNcbiAgICogQHR5cGVkZWYge09iamVjdH0gU3RvcE9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZhbHVlIHN0b3AgKFNMIG9yIFRQKSB2YWx1ZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdW5pdHMgc3RvcCB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mIHZhbHVlIGZpZWxkIGlzIGEgZmluYWwgc3RvcCB2YWx1ZS5cbiAgICogUkVMQVRJVkVfKiBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmaWVsZCB2YWx1ZSBjb250YWlucyByZWxhdGl2ZSBzdG9wIGV4cHJlc3NlZCBlaXRoZXIgaW4gcHJpY2UsIHBvaW50cywgcGlwcywgYWNjb3VudFxuICAgKiBjdXJyZW5jeSBvciBiYWxhbmNlIHBlcmNlbnRhZ2UuIERlZmF1bHQgaXMgQUJTT0xVVEVfUFJJQ0UuIEFsbG93ZWQgdmFsdWVzIGFyZSBBQlNPTFVURV9QUklDRSwgUkVMQVRJVkVfUFJJQ0UsXG4gICAqIFJFTEFUSVZFX1BPSU5UUywgUkVMQVRJVkVfUElQUywgUkVMQVRJVkVfQ1VSUkVOQ1ksIFJFTEFUSVZFX0JBTEFOQ0VfUEVSQ0VOVEFHRVxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcmtldCBidXkgb3JkZXIgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge0NyZWF0ZU1hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVNYXJrZXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWScsIHN5bWJvbCwgdm9sdW1lfSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcmtldCBzZWxsIG9yZGVyIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtDcmVhdGVNYXJrZXRUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY3JlYXRlTWFya2V0U2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTCcsIHN5bWJvbCwgdm9sdW1lfSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGxpbWl0IGJ1eSBvcmRlciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgbGltaXQgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZUxpbWl0QnV5T3JkZXIoc3ltYm9sLCB2b2x1bWUsIG9wZW5QcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcsIHN5bWJvbCxcbiAgICAgIHZvbHVtZSwgb3BlblByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbGltaXQgc2VsbCBvcmRlciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgbGltaXQgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZUxpbWl0U2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMX0xJTUlUJywgc3ltYm9sLFxuICAgICAgdm9sdW1lLCBvcGVuUHJpY2V9LCB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdG9wIGJ1eSBvcmRlciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgc3RvcCBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1BlbmRpbmdUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY3JlYXRlU3RvcEJ1eU9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9CVVlfU1RPUCcsIHN5bWJvbCxcbiAgICAgIHZvbHVtZSwgb3BlblByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RvcCBzZWxsIG9yZGVyIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVTdG9wU2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMX1NUT1AnLCBzeW1ib2wsXG4gICAgICB2b2x1bWUsIG9wZW5QcmljZX0sIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0b3AgbGltaXQgYnV5IG9yZGVyIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdG9wTGltaXRQcmljZSB0aGUgbGltaXQgb3JkZXIgcHJpY2UgZm9yIHRoZSBzdG9wIGxpbWl0IG9yZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7U3RvcExpbWl0UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVTdG9wTGltaXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTGltaXRQcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWRlKE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWV9TVE9QX0xJTUlUJyxcbiAgICAgIHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RvcCBsaW1pdCBzZWxsIG9yZGVyIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdG9wTGltaXRQcmljZSB0aGUgbGltaXQgb3JkZXIgcHJpY2UgZm9yIHRoZSBzdG9wIGxpbWl0IG9yZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7U3RvcExpbWl0UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVTdG9wTGltaXRTZWxsT3JkZXIoc3ltYm9sLCB2b2x1bWUsIG9wZW5QcmljZSwgc3RvcExpbWl0UHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMX1NUT1BfTElNSVQnLFxuICAgICAgc3ltYm9sLCB2b2x1bWUsIG9wZW5QcmljZSwgc3RvcExpbWl0UHJpY2V9LCB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgcG9zaXRpb24gKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZCB0byBtb2RpZnlcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtUcmFpbGluZ1N0b3BMb3NzfSB0cmFpbGluZ1N0b3BMb3NzIGRpc3RhbmNlIHRyYWlsaW5nIHN0b3AgbG9zcyBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc3RvcFByaWNlQmFzZV0gZGVmaW5lcyB0aGUgYmFzZSBwcmljZSB0byBjYWxjdWxhdGUgU0wgcmVsYXRpdmUgdG8gZm9yIFBPU0lUSU9OX01PRElGWSBhbmRcbiAgICogcGVuZGluZyBvcmRlciByZXF1ZXN0cy4gRGVmYXVsdCBpcyBPUEVOX1BSSUNFLiBPbmUgb2YgQ1VSUkVOVF9QUklDRSwgT1BFTl9QUklDRSwgU1RPUF9QUklDRVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgbW9kaWZ5UG9zaXRpb24ocG9zaXRpb25JZCwgc3RvcExvc3MsIHRha2VQcm9maXQsIHRyYWlsaW5nU3RvcExvc3MsIHN0b3BQcmljZUJhc2UpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnUE9TSVRJT05fTU9ESUZZJywgcG9zaXRpb25JZCwgdHJhaWxpbmdTdG9wTG9zcywgc3RvcFByaWNlQmFzZX0sXG4gICAgICB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnRpYWxseSBjbG9zZXMgYSBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkIHRvIG1vZGlmeVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIHZvbHVtZSB0byBjbG9zZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjbG9zZVBvc2l0aW9uUGFydGlhbGx5KHBvc2l0aW9uSWQsIHZvbHVtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX1BBUlRJQUwnLCBwb3NpdGlvbklkLFxuICAgICAgdm9sdW1lfSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IGNsb3NlcyBhIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gbW9kaWZ5XG4gICAqIEBwYXJhbSB7TWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNsb3NlUG9zaXRpb24ocG9zaXRpb25JZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX0NMT1NFX0lEJywgcG9zaXRpb25JZH0sXG4gICAgICBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogRnVsbHkgY2xvc2VzIGEgcG9zaXRpb24gKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZCB0byBjbG9zZSBieSBvcHBvc2l0ZSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3Bwb3NpdGVQb3NpdGlvbklkIG9wcG9zaXRlIHBvc2l0aW9uIGlkIHRvIGNsb3NlXG4gICAqIEBwYXJhbSB7TWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNsb3NlQnkocG9zaXRpb25JZCwgb3Bwb3NpdGVQb3NpdGlvbklkLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZShPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnUE9TSVRJT05fQ0xPU0VfQlknLCBwb3NpdGlvbklkLFxuICAgICAgY2xvc2VCeVBvc2l0aW9uSWQ6IG9wcG9zaXRlUG9zaXRpb25JZH0sIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgcG9zaXRpb25zIGJ5IGEgc3ltYm9sKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjbG9zZVBvc2l0aW9uc0J5U3ltYm9sKHN5bWJvbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OU19DTE9TRV9TWU1CT0wnLCBzeW1ib2x9LFxuICAgICAgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgcGVuZGluZyBvcmRlciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcklkIG9yZGVyIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtNb2RpZnlPcmRlck9wdGlvbnN9IFtvcHRpb25zXSBvcHRpb25hbCBtb2RpZnkgb3JkZXIgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgbW9kaWZ5T3JkZXIob3JkZXJJZCwgb3BlblByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhZGUoT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX01PRElGWScsIG9yZGVySWQsIG9wZW5QcmljZX0sXG4gICAgICB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgb3JkZXIgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JkZXJJZCBvcmRlciBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNhbmNlbE9yZGVyKG9yZGVySWQpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl90cmFkZSh7YWN0aW9uVHlwZTogJ09SREVSX0NBTkNFTCcsIG9yZGVySWR9KTtcbiAgfVxuXG4gIF90cmFkZShyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC50cmFkZSh0aGlzLl9hY2NvdW50LmlkLCByZXF1ZXN0LCB0aGlzLl9hcHBsaWNhdGlvbiwgdGhpcy5fYWNjb3VudC5yZWxpYWJpbGl0eSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBtYXJnaW4gcmVxdWlyZWQgdG8gb3BlbiBhIHRyYWRlIG9uIHRoZSBzcGVjaWZpZWQgdHJhZGluZyBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvY2FsY3VsYXRlTWFyZ2luLykuXG4gICAqIEBwYXJhbSB7TWFyZ2luT3JkZXJ9IG9yZGVyIG9yZGVyIHRvIGNhbGN1bGF0ZSBtYXJnaW4gZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1hcmdpbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggbWFyZ2luIGNhbGN1bGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgY2FsY3VsYXRlTWFyZ2luKG9yZGVyKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmNhbGN1bGF0ZU1hcmdpbih0aGlzLl9hY2NvdW50LmlkLCB0aGlzLl9hcHBsaWNhdGlvbiwgdGhpcy5fYWNjb3VudC5yZWxpYWJpbGl0eSwgb3JkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YUFwaSBhY2NvdW50XG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJBY2NvdW50fSBNZXRhQXBpIGFjY291bnRcbiAgICovXG4gIGdldCBhY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9hY2NvdW50O1xuICB9XG4gIF9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSB7XG4gICAgbGV0IHRyYWRlID0ge307XG4gICAgaWYgKHR5cGVvZiBzdG9wTG9zcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRyYWRlLnN0b3BMb3NzID0gc3RvcExvc3M7XG4gICAgfSBlbHNlIGlmIChzdG9wTG9zcykge1xuICAgICAgdHJhZGUuc3RvcExvc3MgPSBzdG9wTG9zcy52YWx1ZTtcbiAgICAgIHRyYWRlLnN0b3BMb3NzVW5pdHMgPSBzdG9wTG9zcy51bml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YWtlUHJvZml0ID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhZGUudGFrZVByb2ZpdCA9IHRha2VQcm9maXQ7XG4gICAgfSBlbHNlIGlmICh0YWtlUHJvZml0KSB7XG4gICAgICB0cmFkZS50YWtlUHJvZml0ID0gdGFrZVByb2ZpdC52YWx1ZTtcbiAgICAgIHRyYWRlLnRha2VQcm9maXRVbml0cyA9IHRha2VQcm9maXQudW5pdHM7XG4gICAgfVxuICAgIHJldHVybiB0cmFkZTtcbiAgfVxuXG4gIGFzeW5jIF9lbnN1cmVTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwga2V5KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYgKHN0YXRlICYmICF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN5bmNocm9uaXphdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuc3luY2hyb25pemUoaW5zdGFuY2VJbmRleCk7XG4gICAgICAgIGlmKHN5bmNocm9uaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IHRydWU7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ01ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBmb3IgYWNjb3VudCAnICsgdGhpcy5fYWNjb3VudC5pZCArXG4gICAgICAgICAgJzonICsgaW5zdGFuY2VJbmRleCArICcgZmFpbGVkIHRvIHN5bmNocm9uaXplJywgZXJyKTtcbiAgICAgICAgaWYgKHN0YXRlLnNob3VsZFN5bmNocm9uaXplID09PSBrZXkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX2Vuc3VyZVN5bmNocm9uaXplZC5iaW5kKHRoaXMsIGluc3RhbmNlSW5kZXgsIGtleSksXG4gICAgICAgICAgICBzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzICogMTAwMCk7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IE1hdGgubWluKHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgKiAyLCAzMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF0pIHtcbiAgICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF0gPSB7XG4gICAgICAgIGluc3RhbmNlSW5kZXgsXG4gICAgICAgIG9yZGVyc1N5bmNocm9uaXplZDoge30sXG4gICAgICAgIGRlYWxzU3luY2hyb25pemVkOiB7fSxcbiAgICAgICAgc2hvdWxkU3luY2hyb25pemU6IHVuZGVmaW5lZCxcbiAgICAgICAgc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kczogMSxcbiAgICAgICAgc3luY2hyb25pemVkOiBmYWxzZSxcbiAgICAgICAgbGFzdERpc2Nvbm5lY3RlZFN5bmNocm9uaXphdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICAgIGxhc3RTeW5jaHJvbml6YXRpb25JZDogdW5kZWZpbmVkLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XTtcbiAgfVxuXG4gIF9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpIHtcbiAgICBpZighdGhpcy5fb3BlbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LCBwbGVhc2UgaW52b2tlIGF3YWl0IGNvbm5lY3Rpb24uY29ubmVjdCgpJyk7XG4gICAgfVxuICAgIGlmKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkLCBwbGVhc2UgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24nKTtcbiAgICB9XG4gIH1cblxufVxuIl19