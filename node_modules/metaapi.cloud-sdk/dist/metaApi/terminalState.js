'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _cryptoJs = require('crypto-js');

var _cryptoJs2 = _interopRequireDefault(_cryptoJs);

var _synchronizationListener = require('../clients/metaApi/synchronizationListener');

var _synchronizationListener2 = _interopRequireDefault(_synchronizationListener);

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Responsible for storing a local copy of remote terminal state
 */
class TerminalState extends _synchronizationListener2.default {

  /**
   * Constructs the instance of terminal state class
   * @param {string} accountId account id
   * @param {ClientApiClient} clientApiClient client api client
   */
  constructor(accountId, clientApiClient) {
    super();
    this._accountId = accountId;
    this._clientApiClient = clientApiClient;
    this._stateByInstanceIndex = {};
    this._waitForPriceResolves = {};
    this._combinedState = {
      accountInformation: undefined,
      positions: [],
      orders: [],
      specificationsBySymbol: {},
      pricesBySymbol: {},
      completedOrders: {},
      removedPositions: {},
      ordersInitialized: false,
      positionsInitialized: false,
      lastUpdateTime: 0,
      lastQuoteTime: undefined,
      lastQuoteBrokerTime: undefined
    };
    this._logger = _logger2.default.getLogger('TerminalState');
  }

  /**
   * Returns true if MetaApi have connected to MetaTrader terminal
   * @return {Boolean} true if MetaApi have connected to MetaTrader terminal
   */
  get connected() {
    return (0, _values2.default)(this._stateByInstanceIndex).reduce((acc, s) => acc || s.connected, false);
  }

  /**
   * Returns true if MetaApi have connected to MetaTrader terminal and MetaTrader terminal is connected to broker
   * @return {Boolean} true if MetaApi have connected to MetaTrader terminal and MetaTrader terminal is connected to
   * broker
   */
  get connectedToBroker() {
    return (0, _values2.default)(this._stateByInstanceIndex).reduce((acc, s) => acc || s.connectedToBroker, false);
  }

  /**
   * Returns a local copy of account information
   * @returns {MetatraderAccountInformation} local copy of account information
   */
  get accountInformation() {
    return this._combinedState.accountInformation;
  }

  /**
   * Returns a local copy of MetaTrader positions opened
   * @returns {Array<MetatraderPosition>} a local copy of MetaTrader positions opened
   */
  get positions() {
    return this._combinedState.positions;
  }

  /**
   * Returns a local copy of MetaTrader orders opened
   * @returns {Array<MetatraderOrder>} a local copy of MetaTrader orders opened
   */
  get orders() {
    return this._combinedState.orders;
  }

  /**
   * Returns a local copy of symbol specifications available in MetaTrader trading terminal
   * @returns {Array<MetatraderSymbolSpecification>} a local copy of symbol specifications available in MetaTrader
   * trading terminal
   */
  get specifications() {
    return (0, _values2.default)(this._combinedState.specificationsBySymbol);
  }

  /**
   * Returns hashes of terminal state data for incremental synchronization
   * @param {String} accountType account type
   * @param {String} instanceIndex index of instance to get hashes of
   * @returns {Promise<Object>} promise resolving with hashes of terminal state data
   */
  // eslint-disable-next-line complexity
  async getHashes(accountType, instanceIndex) {
    let requestedState = this._getState(instanceIndex);
    // get latest instance number state
    const region = instanceIndex.split(':')[0];
    const hashFields = await this._clientApiClient.getHashingIgnoredFieldLists(region);
    const instanceNumber = instanceIndex.split(':')[1];
    const instanceNumberStates = (0, _keys2.default)(this._stateByInstanceIndex).filter(stateInstanceIndex => stateInstanceIndex.startsWith(`${region}:${instanceNumber}:`));
    instanceNumberStates.sort((a, b) => b.lastSyncUpdateTime - a.lastSyncUpdateTime);
    const state = this._getState(instanceNumberStates[0]);

    const sortByKey = (obj1, obj2, key) => {
      if (obj1[key] < obj2[key]) {
        return -1;
      }
      if (obj1[key] > obj2[key]) {
        return 1;
      }
      return 0;
    };
    const specifications = JSON.parse((0, _stringify2.default)((0, _values2.default)(state.specificationsBySymbol)));
    specifications.sort((a, b) => sortByKey(a, b, 'symbol'));
    specifications.forEach(specification => {
      if (accountType === 'cloud-g1') {
        hashFields.g1.specification.forEach(field => delete specification[field]);
      } else if (accountType === 'cloud-g2') {
        hashFields.g2.specification.forEach(field => delete specification[field]);
      }
    });
    const specificationsHash = specifications.length ? state.specificationsHash || this._getHash(specifications, accountType, ['digits']) : null;
    state.specificationsHash = specificationsHash;

    const positions = JSON.parse((0, _stringify2.default)(state.positions));
    if (accountType === 'cloud-g1') {
      positions.sort((a, b) => Number(a.id) - Number(b.id));
    } else {
      positions.sort((a, b) => sortByKey(a, b, 'id'));
    }
    positions.forEach(position => {
      if (accountType === 'cloud-g1') {
        hashFields.g1.position.forEach(field => delete position[field]);
      } else if (accountType === 'cloud-g2') {
        hashFields.g2.position.forEach(field => delete position[field]);
      }
    });
    const positionsHash = state.positionsInitialized ? state.positionsHash || this._getHash(positions, accountType, ['magic']) : null;
    state.positionsHash = positionsHash;

    const orders = JSON.parse((0, _stringify2.default)(state.orders));
    if (accountType === 'cloud-g1') {
      orders.sort((a, b) => Number(a.id) - Number(b.id));
    } else {
      orders.sort((a, b) => sortByKey(a, b, 'id'));
    }
    orders.forEach(order => {
      if (accountType === 'cloud-g1') {
        hashFields.g1.order.forEach(field => delete order[field]);
      } else if (accountType === 'cloud-g2') {
        hashFields.g2.order.forEach(field => delete order[field]);
      }
    });
    const ordersHash = state.ordersInitialized ? state.ordersHash || this._getHash(orders, accountType, ['magic']) : null;
    state.ordersHash = ordersHash;

    if (requestedState !== state) {
      requestedState.specificationsBySymbol = (0, _assign2.default)({}, state.specificationsBySymbol || {});
      requestedState.specificationsHash = specificationsHash;
      requestedState.positions = (state.positions || []).map(p => (0, _assign2.default)({}, p));
      requestedState.positionsHash = positionsHash;
      requestedState.orders = (state.orders || []).map(o => (0, _assign2.default)({}, o));
      requestedState.ordersHash = ordersHash;
    }

    return {
      specificationsMd5: specificationsHash,
      positionsMd5: positionsHash,
      ordersMd5: ordersHash
    };
  }

  /**
   * Returns MetaTrader symbol specification by symbol
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @return {MetatraderSymbolSpecification} MetatraderSymbolSpecification found or undefined if specification for a
   * symbol is not found
   */
  specification(symbol) {
    return this._combinedState.specificationsBySymbol[symbol];
  }

  /**
   * Returns MetaTrader symbol price by symbol
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @return {MetatraderSymbolPrice} MetatraderSymbolPrice found or undefined if price for a symbol is not found
   */
  price(symbol) {
    return this._combinedState.pricesBySymbol[symbol];
  }

  /**
   * Quote time
   * @typdef {Object} QuoteTime
   * @property {Date} time quote time
   * @property {String} brokerTime quote time in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */

  /**
   * Returns time of the last received quote
   * @return {QuoteTime} time of the last received quote
   */
  get lastQuoteTime() {
    if (this._combinedState.lastQuoteTime) {
      return {
        time: this._combinedState.lastQuoteTime,
        brokerTime: this._combinedState.lastQuoteBrokerTime
      };
    } else {
      return undefined;
    }
  }

  /**
   * Waits for price to be received
   * @param {string} symbol symbol (e.g. currency pair or an index)
   * @param {number} [timeoutInSeconds] timeout in seconds, default is 30
   * @return {Promise<MetatraderSymbolPrice>} promise resolving with price or undefined if price has not been received
   */
  async waitForPrice(symbol, timeoutInSeconds = 30) {
    this._waitForPriceResolves[symbol] = this._waitForPriceResolves[symbol] || [];
    if (!this.price(symbol)) {
      await _promise2.default.race([new _promise2.default(res => this._waitForPriceResolves[symbol].push(res)), new _promise2.default(res => setTimeout(res, timeoutInSeconds * 1000))]);
    }
    return this.price(symbol);
  }

  /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   */
  onConnected(instanceIndex) {
    this._getState(instanceIndex).connected = true;
  }

  /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */
  onDisconnected(instanceIndex) {
    let state = this._getState(instanceIndex);
    state.connected = false;
    state.connectedToBroker = false;
  }

  /**
   * Invoked when broker connection status have changed
   * @param {String} instanceIndex index of an account instance connected
   * @param {Boolean} connected is MetaTrader terminal is connected to broker
   */
  onBrokerConnectionStatusChanged(instanceIndex, connected) {
    this._getState(instanceIndex).connectedToBroker = connected;
  }

  /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {String} instanceIndex index of an account instance connected
   * @param {Boolean} specificationsUpdated whether specifications are going to be updated during synchronization
   * @param {Boolean} positionsUpdated whether positions are going to be updated during synchronization
   * @param {Boolean} ordersUpdated whether orders are going to be updated during synchronization
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onSynchronizationStarted(instanceIndex, specificationsUpdated, positionsUpdated, ordersUpdated, synchronizationId) {
    const unsynchronizedStates = this._getStateIndicesOfSameInstanceNumber(instanceIndex).filter(stateIndex => !this._stateByInstanceIndex[stateIndex].ordersInitialized);
    unsynchronizedStates.sort((a, b) => b.lastSyncUpdateTime - a.lastSyncUpdateTime);
    unsynchronizedStates.slice(1).forEach(stateIndex => delete this._stateByInstanceIndex[stateIndex]);

    let state = this._getState(instanceIndex);
    state.lastSyncUpdateTime = Date.now();
    state.accountInformation = undefined;
    state.pricesBySymbol = {};
    if (positionsUpdated) {
      state.positions = [];
      state.removedPositions = {};
      state.positionsInitialized = false;
      state.positionsHash = null;
    }
    if (ordersUpdated) {
      state.orders = [];
      state.completedOrders = {};
      state.ordersInitialized = false;
      state.ordersHash = null;
    }
    if (specificationsUpdated) {
      this._logger.trace(() => `${this._accountId}:${instanceIndex}:${synchronizationId}: cleared specifications ` + 'on synchronization start');
      state.specificationsBySymbol = {};
      state.specificationsHash = null;
    } else {
      this._logger.trace(() => `${this._accountId}:${instanceIndex}:${synchronizationId}: no need to clear ` + `specifications on synchronization start, ${(0, _keys2.default)(state.specificationsBySymbol || {}).length} ` + 'specifications reused');
    }
  }

  /**
   * Invoked when MetaTrader account information is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderAccountInformation} accountInformation updated MetaTrader account information
   */
  onAccountInformationUpdated(instanceIndex, accountInformation) {
    let state = this._getState(instanceIndex);
    this._refreshStateUpdateTime(instanceIndex);
    state.accountInformation = accountInformation;
    if (accountInformation) {
      this._combinedState.accountInformation = (0, _assign2.default)({}, accountInformation);
    }
  }

  /**
   * Invoked when the positions are replaced as a result of initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderPosition>} positions updated array of positions
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onPositionsReplaced(instanceIndex, positions) {
    let state = this._getState(instanceIndex);
    this._refreshStateUpdateTime(instanceIndex);
    state.positions = positions;
    state.positionsHash = null;
  }

  /**
   * Invoked when position synchronization fnished to indicate progress of an initial terminal state synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onPositionsSynchronized(instanceIndex, synchronizationId) {
    let state = this._getState(instanceIndex);
    state.removedPositions = {};
    state.positionsInitialized = true;
  }

  /**
   * Invoked when MetaTrader position is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderPosition} position updated MetaTrader position
   */
  onPositionUpdated(instanceIndex, position) {
    let instanceState = this._getState(instanceIndex);
    this._refreshStateUpdateTime(instanceIndex);
    instanceState.positionsHash = null;

    const updatePosition = state => {
      let index = state.positions.findIndex(p => p.id === position.id);
      if (index !== -1) {
        state.positions[index] = position;
      } else if (!state.removedPositions[position.id]) {
        state.positions.push(position);
      }
    };
    updatePosition(instanceState);
    updatePosition(this._combinedState);
  }

  /**
   * Invoked when MetaTrader position is removed
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} positionId removed MetaTrader position id
   */
  onPositionRemoved(instanceIndex, positionId) {
    let instanceState = this._getState(instanceIndex);
    this._refreshStateUpdateTime(instanceIndex);
    instanceState.positionsHash = null;

    const removePosition = state => {
      let position = state.positions.find(p => p.id === positionId);
      if (!position) {
        for (let e of (0, _entries2.default)(state.removedPositions)) {
          if (e[1] + 5 * 60 * 1000 < Date.now()) {
            delete state.removedPositions[e[0]];
          }
        }
        state.removedPositions[positionId] = Date.now();
      } else {
        state.positions = state.positions.filter(p => p.id !== positionId);
      }
    };
    removePosition(instanceState);
    removePosition(this._combinedState);
  }

  /**
   * Invoked when the orders are replaced as a result of initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderOrder>} orders updated array of pending orders
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onPendingOrdersReplaced(instanceIndex, orders) {
    let state = this._getState(instanceIndex);
    this._refreshStateUpdateTime(instanceIndex);
    state.ordersHash = null;
    state.orders = orders;
  }

  /**
   * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
   * synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onPendingOrdersSynchronized(instanceIndex, synchronizationId) {
    let state = this._getState(instanceIndex);
    state.completedOrders = {};
    state.positionsInitialized = true;
    state.ordersInitialized = true;
    this._combinedState.accountInformation = state.accountInformation ? (0, _assign2.default)({}, state.accountInformation) : undefined;
    this._combinedState.positions = (state.positions || []).map(p => (0, _assign2.default)({}, p));
    this._combinedState.orders = (state.orders || []).map(o => (0, _assign2.default)({}, o));
    this._combinedState.specificationsBySymbol = (0, _assign2.default)({}, state.specificationsBySymbol);
    this._logger.trace(() => `${this._accountId}:${instanceIndex}:${synchronizationId}: assigned specifications to ` + 'combined state from ' + `${instanceIndex}, ${(0, _keys2.default)(state.specificationsBySymbol || {}).length} specifications assigned`);
    this._combinedState.positionsInitialized = true;
    this._combinedState.ordersInitialized = true;
    this._combinedState.completedOrders = {};
    this._combinedState.removedPositions = {};
    for (let stateIndex of this._getStateIndicesOfSameInstanceNumber(instanceIndex)) {
      if (!this._stateByInstanceIndex[stateIndex].connected) {
        delete this._stateByInstanceIndex[stateIndex];
      }
    }
  }

  /**
   * Invoked when MetaTrader pending order is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderOrder} order updated MetaTrader pending order
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onPendingOrderUpdated(instanceIndex, order) {
    let instanceState = this._getState(instanceIndex);
    this._refreshStateUpdateTime(instanceIndex);
    instanceState.ordersHash = null;

    const updatePendingOrder = state => {
      let index = state.orders.findIndex(o => o.id === order.id);
      if (index !== -1) {
        state.orders[index] = order;
      } else if (!state.completedOrders[order.id]) {
        state.orders.push(order);
      }
    };
    updatePendingOrder(instanceState);
    updatePendingOrder(this._combinedState);
  }

  /**
   * Invoked when MetaTrader pending order is completed (executed or canceled)
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} orderId completed MetaTrader pending order id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onPendingOrderCompleted(instanceIndex, orderId) {
    let instanceState = this._getState(instanceIndex);
    this._refreshStateUpdateTime(instanceIndex);
    instanceState.ordersHash = null;

    const completeOrder = state => {
      let order = state.orders.find(o => o.id === orderId);
      if (!order) {
        for (let e of (0, _entries2.default)(state.completedOrders)) {
          if (e[1] + 5 * 60 * 1000 < Date.now()) {
            delete state.completedOrders[e[0]];
          }
        }
        state.completedOrders[orderId] = Date.now();
      } else {
        state.orders = state.orders.filter(o => o.id !== orderId);
      }
    };
    completeOrder(instanceState);
    completeOrder(this._combinedState);
  }

  /**
   * Invoked when a symbol specification was updated
   * @param {String} instanceIndex index of account instance connected
   * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
   * @param {Array<String>} removedSymbols removed symbols
   */
  onSymbolSpecificationsUpdated(instanceIndex, specifications, removedSymbols) {
    let instanceState = this._getState(instanceIndex);
    this._refreshStateUpdateTime(instanceIndex);
    instanceState.specificationsHash = null;

    const updateSpecifications = state => {
      for (let specification of specifications) {
        state.specificationsBySymbol[specification.symbol] = specification;
      }
      for (let symbol of removedSymbols) {
        delete state.specificationsBySymbol[symbol];
      }
    };
    updateSpecifications(instanceState);
    updateSpecifications(this._combinedState);
    this._logger.trace(() => `${this._accountId}:${instanceIndex}: updated ${specifications.length} specifications, ` + `removed ${removedSymbols.length} specifications. There are ` + `${(0, _keys2.default)(instanceState.specificationsBySymbol || {}).length} specifications after update`);
  }

  /**
   * Invoked when prices for several symbols were updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderSymbolPrice>} prices updated MetaTrader symbol prices
   * @param {Number} equity account liquidation value
   * @param {Number} margin margin used
   * @param {Number} freeMargin free margin
   * @param {Number} marginLevel margin level calculated as % of equity/margin
   */
  // eslint-disable-next-line complexity
  onSymbolPricesUpdated(instanceIndex, prices, equity, margin, freeMargin, marginLevel) {
    let instanceState = this._getState(instanceIndex);
    this._refreshStateUpdateTime(instanceIndex);

    // eslint-disable-next-line complexity,max-statements
    const updateSymbolPrices = state => {
      state.lastUpdateTime = Math.max(prices.map(p => p.time.getTime()));
      let pricesInitialized = false;
      let priceUpdated = false;
      for (let price of prices || []) {
        let currentPrice = state.pricesBySymbol[price.symbol];
        if (currentPrice && currentPrice.time.getTime() > price.time.getTime()) {
          continue;
        } else {
          priceUpdated = true;
        }
        if (!state.lastQuoteTime || state.lastQuoteTime.getTime() < price.time.getTime()) {
          state.lastQuoteTime = price.time;
          state.lastQuoteBrokerTime = price.brokerTime;
        }
        state.pricesBySymbol[price.symbol] = price;
        let positions = state.positions.filter(p => p.symbol === price.symbol);
        let otherPositions = state.positions.filter(p => p.symbol !== price.symbol);
        let orders = state.orders.filter(o => o.symbol === price.symbol);
        pricesInitialized = true;
        for (let position of otherPositions) {
          let p = state.pricesBySymbol[position.symbol];
          if (p) {
            if (position.unrealizedProfit === undefined) {
              this._updatePositionProfits(position, p);
            }
          } else {
            pricesInitialized = false;
          }
        }
        for (let position of positions) {
          this._updatePositionProfits(position, price);
        }
        for (let order of orders) {
          order.currentPrice = order.type === 'ORDER_TYPE_BUY' || order.type === 'ORDER_TYPE_BUY_LIMIT' || order.type === 'ORDER_TYPE_BUY_STOP' || order.type === 'ORDER_TYPE_BUY_STOP_LIMIT' ? price.ask : price.bid;
        }
        let priceResolves = this._waitForPriceResolves[price.symbol] || [];
        if (priceResolves.length) {
          for (let resolve of priceResolves) {
            resolve();
          }
          delete this._waitForPriceResolves[price.symbol];
        }
      }
      if (priceUpdated && state.accountInformation) {
        if (state.positionsInitialized && pricesInitialized) {
          if (state.accountInformation.platform === 'mt5') {
            state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.balance + state.positions.reduce((acc, p) => acc + Math.round((p.unrealizedProfit || 0) * 100) / 100 + Math.round((p.swap || 0) * 100) / 100, 0);
          } else {
            state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.balance + state.positions.reduce((acc, p) => acc + Math.round((p.swap || 0) * 100) / 100 + Math.round((p.commission || 0) * 100) / 100 + Math.round((p.unrealizedProfit || 0) * 100) / 100, 0);
          }
          state.accountInformation.equity = Math.round(state.accountInformation.equity * 100) / 100;
        } else {
          state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.equity;
        }
        state.accountInformation.margin = margin !== undefined ? margin : state.accountInformation.margin;
        state.accountInformation.freeMargin = freeMargin !== undefined ? freeMargin : state.accountInformation.freeMargin;
        state.accountInformation.marginLevel = freeMargin !== undefined ? marginLevel : state.accountInformation.marginLevel;
      }
    };
    updateSymbolPrices(instanceState);
    updateSymbolPrices(this._combinedState);
  }

  /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onStreamClosed(instanceIndex) {
    if (this._stateByInstanceIndex[instanceIndex]) {
      for (let stateIndex of this._getStateIndicesOfSameInstanceNumber(instanceIndex)) {
        const instanceState = this._stateByInstanceIndex[stateIndex];
        if (!this._stateByInstanceIndex[instanceIndex].ordersInitialized && this._stateByInstanceIndex[instanceIndex].lastSyncUpdateTime <= instanceState.lastSyncUpdateTime) {
          delete this._stateByInstanceIndex[instanceIndex];
          break;
        }
        if (instanceState.connected && instanceState.ordersInitialized) {
          delete this._stateByInstanceIndex[instanceIndex];
          break;
        }
      }
    }
  }

  _refreshStateUpdateTime(instanceIndex) {
    const state = this._stateByInstanceIndex[instanceIndex];
    if (state && state.ordersInitialized) {
      state.lastSyncUpdateTime = Date.now();
    }
  }

  _getStateIndicesOfSameInstanceNumber(instanceIndex) {
    const region = instanceIndex.split(':')[0];
    const instanceNumber = instanceIndex.split(':')[1];
    return (0, _keys2.default)(this._stateByInstanceIndex).filter(stateInstanceIndex => stateInstanceIndex.startsWith(`${region}:${instanceNumber}:`) && instanceIndex !== stateInstanceIndex);
  }

  // eslint-disable-next-line complexity
  _updatePositionProfits(position, price) {
    let specification = this.specification(position.symbol);
    if (specification) {
      let multiplier = Math.pow(10, specification.digits);
      if (position.profit !== undefined) {
        position.profit = Math.round(position.profit * multiplier) / multiplier;
      }
      if (position.unrealizedProfit === undefined || position.realizedProfit === undefined) {
        position.unrealizedProfit = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (position.currentPrice - position.openPrice) * position.currentTickValue * position.volume / specification.tickSize;
        position.unrealizedProfit = Math.round(position.unrealizedProfit * multiplier) / multiplier;
        position.realizedProfit = position.profit - position.unrealizedProfit;
      }
      let newPositionPrice = position.type === 'POSITION_TYPE_BUY' ? price.bid : price.ask;
      let isProfitable = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (newPositionPrice - position.openPrice);
      let currentTickValue = isProfitable > 0 ? price.profitTickValue : price.lossTickValue;
      let unrealizedProfit = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (newPositionPrice - position.openPrice) * currentTickValue * position.volume / specification.tickSize;
      unrealizedProfit = Math.round(unrealizedProfit * multiplier) / multiplier;
      position.unrealizedProfit = unrealizedProfit;
      position.profit = position.unrealizedProfit + position.realizedProfit;
      position.profit = Math.round(position.profit * multiplier) / multiplier;
      position.currentPrice = newPositionPrice;
      position.currentTickValue = currentTickValue;
    }
  }

  _getState(instanceIndex) {
    if (!this._stateByInstanceIndex['' + instanceIndex]) {
      this._logger.trace(`${this._accountId}:${instanceIndex}: constructed new state`);
      this._stateByInstanceIndex['' + instanceIndex] = this._constructTerminalState(instanceIndex);
    }
    return this._stateByInstanceIndex['' + instanceIndex];
  }

  _constructTerminalState(instanceIndex) {
    return {
      instanceIndex,
      connected: false,
      connectedToBroker: false,
      accountInformation: undefined,
      positions: [],
      orders: [],
      specificationsBySymbol: {},
      pricesBySymbol: {},
      completedOrders: {},
      removedPositions: {},
      ordersInitialized: false,
      positionsInitialized: false,
      lastUpdateTime: 0,
      lastSyncUpdateTime: 0,
      positionsHash: null,
      ordersHash: null,
      specificationsHash: null,
      lastQuoteTime: undefined,
      lastQuoteBrokerTime: undefined
    };
  }

  _getHash(obj, accountType, integerKeys) {
    let jsonItem = '';
    if (accountType === 'cloud-g1') {
      const stringify = (objFromJson, key) => {
        if (typeof objFromJson === 'number') {
          if (integerKeys.includes(key)) {
            return objFromJson;
          } else {
            return objFromJson.toFixed(8);
          }
        } else if (Array.isArray(objFromJson)) {
          return `[${objFromJson.map(item => stringify(item)).join(',')}]`;
        } else if (objFromJson === null) {
          return objFromJson;
        } else if (typeof objFromJson !== 'object' || objFromJson.getTime) {
          return (0, _stringify2.default)(objFromJson);
        }

        let props = (0, _keys2.default)(objFromJson).map(keyItem => `"${keyItem}":${stringify(objFromJson[keyItem], keyItem)}`).join(',');
        return `{${props}}`;
      };

      jsonItem = stringify(obj);
    } else if (accountType === 'cloud-g2') {
      const stringify = (objFromJson, key) => {
        if (typeof objFromJson === 'number') {
          if (integerKeys.includes(key)) {
            return objFromJson;
          } else {
            return parseFloat(objFromJson.toFixed(8));
          }
        } else if (Array.isArray(objFromJson)) {
          return `[${objFromJson.map(item => stringify(item)).join(',')}]`;
        } else if (objFromJson === null) {
          return objFromJson;
        } else if (typeof objFromJson !== 'object' || objFromJson.getTime) {
          return (0, _stringify2.default)(objFromJson);
        }

        let props = (0, _keys2.default)(objFromJson).map(keyItem => `"${keyItem}":${stringify(objFromJson[keyItem], keyItem)}`).join(',');
        return `{${props}}`;
      };

      jsonItem = stringify(obj);
    }
    return _cryptoJs2.default.MD5(jsonItem).toString();
  }

}
exports.default = TerminalState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9tZXRhQXBpL3Rlcm1pbmFsU3RhdGUuZXM2Il0sIm5hbWVzIjpbIlRlcm1pbmFsU3RhdGUiLCJTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsImNvbnN0cnVjdG9yIiwiYWNjb3VudElkIiwiY2xpZW50QXBpQ2xpZW50IiwiX2FjY291bnRJZCIsIl9jbGllbnRBcGlDbGllbnQiLCJfc3RhdGVCeUluc3RhbmNlSW5kZXgiLCJfd2FpdEZvclByaWNlUmVzb2x2ZXMiLCJfY29tYmluZWRTdGF0ZSIsImFjY291bnRJbmZvcm1hdGlvbiIsInVuZGVmaW5lZCIsInBvc2l0aW9ucyIsIm9yZGVycyIsInNwZWNpZmljYXRpb25zQnlTeW1ib2wiLCJwcmljZXNCeVN5bWJvbCIsImNvbXBsZXRlZE9yZGVycyIsInJlbW92ZWRQb3NpdGlvbnMiLCJvcmRlcnNJbml0aWFsaXplZCIsInBvc2l0aW9uc0luaXRpYWxpemVkIiwibGFzdFVwZGF0ZVRpbWUiLCJsYXN0UXVvdGVUaW1lIiwibGFzdFF1b3RlQnJva2VyVGltZSIsIl9sb2dnZXIiLCJMb2dnZXJNYW5hZ2VyIiwiZ2V0TG9nZ2VyIiwiY29ubmVjdGVkIiwicmVkdWNlIiwiYWNjIiwicyIsImNvbm5lY3RlZFRvQnJva2VyIiwic3BlY2lmaWNhdGlvbnMiLCJnZXRIYXNoZXMiLCJhY2NvdW50VHlwZSIsImluc3RhbmNlSW5kZXgiLCJyZXF1ZXN0ZWRTdGF0ZSIsIl9nZXRTdGF0ZSIsInJlZ2lvbiIsInNwbGl0IiwiaGFzaEZpZWxkcyIsImdldEhhc2hpbmdJZ25vcmVkRmllbGRMaXN0cyIsImluc3RhbmNlTnVtYmVyIiwiaW5zdGFuY2VOdW1iZXJTdGF0ZXMiLCJmaWx0ZXIiLCJzdGF0ZUluc3RhbmNlSW5kZXgiLCJzdGFydHNXaXRoIiwic29ydCIsImEiLCJiIiwibGFzdFN5bmNVcGRhdGVUaW1lIiwic3RhdGUiLCJzb3J0QnlLZXkiLCJvYmoxIiwib2JqMiIsImtleSIsIkpTT04iLCJwYXJzZSIsImZvckVhY2giLCJzcGVjaWZpY2F0aW9uIiwiZzEiLCJmaWVsZCIsImcyIiwic3BlY2lmaWNhdGlvbnNIYXNoIiwibGVuZ3RoIiwiX2dldEhhc2giLCJOdW1iZXIiLCJpZCIsInBvc2l0aW9uIiwicG9zaXRpb25zSGFzaCIsIm9yZGVyIiwib3JkZXJzSGFzaCIsIm1hcCIsInAiLCJvIiwic3BlY2lmaWNhdGlvbnNNZDUiLCJwb3NpdGlvbnNNZDUiLCJvcmRlcnNNZDUiLCJzeW1ib2wiLCJwcmljZSIsInRpbWUiLCJicm9rZXJUaW1lIiwid2FpdEZvclByaWNlIiwidGltZW91dEluU2Vjb25kcyIsInJhY2UiLCJyZXMiLCJwdXNoIiwic2V0VGltZW91dCIsIm9uQ29ubmVjdGVkIiwib25EaXNjb25uZWN0ZWQiLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkIiwib25TeW5jaHJvbml6YXRpb25TdGFydGVkIiwic3BlY2lmaWNhdGlvbnNVcGRhdGVkIiwicG9zaXRpb25zVXBkYXRlZCIsIm9yZGVyc1VwZGF0ZWQiLCJzeW5jaHJvbml6YXRpb25JZCIsInVuc3luY2hyb25pemVkU3RhdGVzIiwiX2dldFN0YXRlSW5kaWNlc09mU2FtZUluc3RhbmNlTnVtYmVyIiwic3RhdGVJbmRleCIsInNsaWNlIiwiRGF0ZSIsIm5vdyIsInRyYWNlIiwib25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkIiwiX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUiLCJvblBvc2l0aW9uc1JlcGxhY2VkIiwib25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQiLCJvblBvc2l0aW9uVXBkYXRlZCIsImluc3RhbmNlU3RhdGUiLCJ1cGRhdGVQb3NpdGlvbiIsImluZGV4IiwiZmluZEluZGV4Iiwib25Qb3NpdGlvblJlbW92ZWQiLCJwb3NpdGlvbklkIiwicmVtb3ZlUG9zaXRpb24iLCJmaW5kIiwiZSIsIm9uUGVuZGluZ09yZGVyc1JlcGxhY2VkIiwib25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkIiwib25QZW5kaW5nT3JkZXJVcGRhdGVkIiwidXBkYXRlUGVuZGluZ09yZGVyIiwib25QZW5kaW5nT3JkZXJDb21wbGV0ZWQiLCJvcmRlcklkIiwiY29tcGxldGVPcmRlciIsIm9uU3ltYm9sU3BlY2lmaWNhdGlvbnNVcGRhdGVkIiwicmVtb3ZlZFN5bWJvbHMiLCJ1cGRhdGVTcGVjaWZpY2F0aW9ucyIsIm9uU3ltYm9sUHJpY2VzVXBkYXRlZCIsInByaWNlcyIsImVxdWl0eSIsIm1hcmdpbiIsImZyZWVNYXJnaW4iLCJtYXJnaW5MZXZlbCIsInVwZGF0ZVN5bWJvbFByaWNlcyIsIk1hdGgiLCJtYXgiLCJnZXRUaW1lIiwicHJpY2VzSW5pdGlhbGl6ZWQiLCJwcmljZVVwZGF0ZWQiLCJjdXJyZW50UHJpY2UiLCJvdGhlclBvc2l0aW9ucyIsInVucmVhbGl6ZWRQcm9maXQiLCJfdXBkYXRlUG9zaXRpb25Qcm9maXRzIiwidHlwZSIsImFzayIsImJpZCIsInByaWNlUmVzb2x2ZXMiLCJyZXNvbHZlIiwicGxhdGZvcm0iLCJiYWxhbmNlIiwicm91bmQiLCJzd2FwIiwiY29tbWlzc2lvbiIsIm9uU3RyZWFtQ2xvc2VkIiwibXVsdGlwbGllciIsInBvdyIsImRpZ2l0cyIsInByb2ZpdCIsInJlYWxpemVkUHJvZml0Iiwib3BlblByaWNlIiwiY3VycmVudFRpY2tWYWx1ZSIsInZvbHVtZSIsInRpY2tTaXplIiwibmV3UG9zaXRpb25QcmljZSIsImlzUHJvZml0YWJsZSIsInByb2ZpdFRpY2tWYWx1ZSIsImxvc3NUaWNrVmFsdWUiLCJfY29uc3RydWN0VGVybWluYWxTdGF0ZSIsIm9iaiIsImludGVnZXJLZXlzIiwianNvbkl0ZW0iLCJzdHJpbmdpZnkiLCJvYmpGcm9tSnNvbiIsImluY2x1ZGVzIiwidG9GaXhlZCIsIkFycmF5IiwiaXNBcnJheSIsIml0ZW0iLCJqb2luIiwicHJvcHMiLCJrZXlJdGVtIiwicGFyc2VGbG9hdCIsImNyeXB0byIsIk1ENSIsInRvU3RyaW5nIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTs7O0FBR2UsTUFBTUEsYUFBTixTQUE0QkMsaUNBQTVCLENBQW9EOztBQUVqRTs7Ozs7QUFLQUMsY0FBWUMsU0FBWixFQUF1QkMsZUFBdkIsRUFBd0M7QUFDdEM7QUFDQSxTQUFLQyxVQUFMLEdBQWtCRixTQUFsQjtBQUNBLFNBQUtHLGdCQUFMLEdBQXdCRixlQUF4QjtBQUNBLFNBQUtHLHFCQUFMLEdBQTZCLEVBQTdCO0FBQ0EsU0FBS0MscUJBQUwsR0FBNkIsRUFBN0I7QUFDQSxTQUFLQyxjQUFMLEdBQXNCO0FBQ3BCQywwQkFBb0JDLFNBREE7QUFFcEJDLGlCQUFXLEVBRlM7QUFHcEJDLGNBQVEsRUFIWTtBQUlwQkMsOEJBQXdCLEVBSko7QUFLcEJDLHNCQUFnQixFQUxJO0FBTXBCQyx1QkFBaUIsRUFORztBQU9wQkMsd0JBQWtCLEVBUEU7QUFRcEJDLHlCQUFtQixLQVJDO0FBU3BCQyw0QkFBc0IsS0FURjtBQVVwQkMsc0JBQWdCLENBVkk7QUFXcEJDLHFCQUFlVixTQVhLO0FBWXBCVywyQkFBcUJYO0FBWkQsS0FBdEI7QUFjQSxTQUFLWSxPQUFMLEdBQWVDLGlCQUFjQyxTQUFkLENBQXdCLGVBQXhCLENBQWY7QUFDRDs7QUFFRDs7OztBQUlBLE1BQUlDLFNBQUosR0FBZ0I7QUFDZCxXQUFPLHNCQUFjLEtBQUtuQixxQkFBbkIsRUFBMENvQixNQUExQyxDQUFpRCxDQUFDQyxHQUFELEVBQU1DLENBQU4sS0FBWUQsT0FBT0MsRUFBRUgsU0FBdEUsRUFBaUYsS0FBakYsQ0FBUDtBQUNEOztBQUVEOzs7OztBQUtBLE1BQUlJLGlCQUFKLEdBQXdCO0FBQ3RCLFdBQU8sc0JBQWMsS0FBS3ZCLHFCQUFuQixFQUEwQ29CLE1BQTFDLENBQWlELENBQUNDLEdBQUQsRUFBTUMsQ0FBTixLQUFZRCxPQUFPQyxFQUFFQyxpQkFBdEUsRUFBeUYsS0FBekYsQ0FBUDtBQUNEOztBQUVEOzs7O0FBSUEsTUFBSXBCLGtCQUFKLEdBQXlCO0FBQ3ZCLFdBQU8sS0FBS0QsY0FBTCxDQUFvQkMsa0JBQTNCO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxNQUFJRSxTQUFKLEdBQWdCO0FBQ2QsV0FBTyxLQUFLSCxjQUFMLENBQW9CRyxTQUEzQjtBQUNEOztBQUVEOzs7O0FBSUEsTUFBSUMsTUFBSixHQUFhO0FBQ1gsV0FBTyxLQUFLSixjQUFMLENBQW9CSSxNQUEzQjtBQUNEOztBQUVEOzs7OztBQUtBLE1BQUlrQixjQUFKLEdBQXFCO0FBQ25CLFdBQU8sc0JBQWMsS0FBS3RCLGNBQUwsQ0FBb0JLLHNCQUFsQyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0EsUUFBTWtCLFNBQU4sQ0FBZ0JDLFdBQWhCLEVBQTZCQyxhQUE3QixFQUE0QztBQUMxQyxRQUFJQyxpQkFBaUIsS0FBS0MsU0FBTCxDQUFlRixhQUFmLENBQXJCO0FBQ0E7QUFDQSxVQUFNRyxTQUFTSCxjQUFjSSxLQUFkLENBQW9CLEdBQXBCLEVBQXlCLENBQXpCLENBQWY7QUFDQSxVQUFNQyxhQUFhLE1BQU0sS0FBS2pDLGdCQUFMLENBQXNCa0MsMkJBQXRCLENBQWtESCxNQUFsRCxDQUF6QjtBQUNBLFVBQU1JLGlCQUFpQlAsY0FBY0ksS0FBZCxDQUFvQixHQUFwQixFQUF5QixDQUF6QixDQUF2QjtBQUNBLFVBQU1JLHVCQUF1QixvQkFBWSxLQUFLbkMscUJBQWpCLEVBQzFCb0MsTUFEMEIsQ0FDbkJDLHNCQUFzQkEsbUJBQW1CQyxVQUFuQixDQUErQixHQUFFUixNQUFPLElBQUdJLGNBQWUsR0FBMUQsQ0FESCxDQUE3QjtBQUVBQyx5QkFBcUJJLElBQXJCLENBQTBCLENBQUNDLENBQUQsRUFBR0MsQ0FBSCxLQUFTQSxFQUFFQyxrQkFBRixHQUF1QkYsRUFBRUUsa0JBQTVEO0FBQ0EsVUFBTUMsUUFBUSxLQUFLZCxTQUFMLENBQWVNLHFCQUFxQixDQUFyQixDQUFmLENBQWQ7O0FBRUEsVUFBTVMsWUFBWSxDQUFDQyxJQUFELEVBQU9DLElBQVAsRUFBYUMsR0FBYixLQUFxQjtBQUNyQyxVQUFHRixLQUFLRSxHQUFMLElBQVlELEtBQUtDLEdBQUwsQ0FBZixFQUEwQjtBQUN4QixlQUFPLENBQUMsQ0FBUjtBQUNEO0FBQ0QsVUFBR0YsS0FBS0UsR0FBTCxJQUFZRCxLQUFLQyxHQUFMLENBQWYsRUFBMEI7QUFDeEIsZUFBTyxDQUFQO0FBQ0Q7QUFDRCxhQUFPLENBQVA7QUFDRCxLQVJEO0FBU0EsVUFBTXZCLGlCQUFpQndCLEtBQUtDLEtBQUwsQ0FBVyx5QkFBZSxzQkFBY04sTUFBTXBDLHNCQUFwQixDQUFmLENBQVgsQ0FBdkI7QUFDQWlCLG1CQUFlZSxJQUFmLENBQW9CLENBQUNDLENBQUQsRUFBR0MsQ0FBSCxLQUFTRyxVQUFVSixDQUFWLEVBQWFDLENBQWIsRUFBZ0IsUUFBaEIsQ0FBN0I7QUFDQWpCLG1CQUFlMEIsT0FBZixDQUF1QkMsaUJBQWlCO0FBQ3RDLFVBQUd6QixnQkFBZ0IsVUFBbkIsRUFBK0I7QUFDN0JNLG1CQUFXb0IsRUFBWCxDQUFjRCxhQUFkLENBQTRCRCxPQUE1QixDQUFvQ0csU0FBUyxPQUFPRixjQUFjRSxLQUFkLENBQXBEO0FBQ0QsT0FGRCxNQUVPLElBQUczQixnQkFBZ0IsVUFBbkIsRUFBK0I7QUFDcENNLG1CQUFXc0IsRUFBWCxDQUFjSCxhQUFkLENBQTRCRCxPQUE1QixDQUFvQ0csU0FBUyxPQUFPRixjQUFjRSxLQUFkLENBQXBEO0FBQ0Q7QUFDRixLQU5EO0FBT0EsVUFBTUUscUJBQXFCL0IsZUFBZWdDLE1BQWYsR0FDekJiLE1BQU1ZLGtCQUFOLElBQTRCLEtBQUtFLFFBQUwsQ0FBY2pDLGNBQWQsRUFBOEJFLFdBQTlCLEVBQTJDLENBQUMsUUFBRCxDQUEzQyxDQURILEdBQzRELElBRHZGO0FBRUFpQixVQUFNWSxrQkFBTixHQUEyQkEsa0JBQTNCOztBQUVBLFVBQU1sRCxZQUFZMkMsS0FBS0MsS0FBTCxDQUFXLHlCQUFlTixNQUFNdEMsU0FBckIsQ0FBWCxDQUFsQjtBQUNBLFFBQUdxQixnQkFBZ0IsVUFBbkIsRUFBK0I7QUFDN0JyQixnQkFBVWtDLElBQVYsQ0FBZSxDQUFDQyxDQUFELEVBQUdDLENBQUgsS0FBU2lCLE9BQU9sQixFQUFFbUIsRUFBVCxJQUFlRCxPQUFPakIsRUFBRWtCLEVBQVQsQ0FBdkM7QUFDRCxLQUZELE1BRU87QUFDTHRELGdCQUFVa0MsSUFBVixDQUFlLENBQUNDLENBQUQsRUFBR0MsQ0FBSCxLQUFTRyxVQUFVSixDQUFWLEVBQWFDLENBQWIsRUFBZ0IsSUFBaEIsQ0FBeEI7QUFDRDtBQUNEcEMsY0FBVTZDLE9BQVYsQ0FBa0JVLFlBQVk7QUFDNUIsVUFBR2xDLGdCQUFnQixVQUFuQixFQUErQjtBQUM3Qk0sbUJBQVdvQixFQUFYLENBQWNRLFFBQWQsQ0FBdUJWLE9BQXZCLENBQStCRyxTQUFTLE9BQU9PLFNBQVNQLEtBQVQsQ0FBL0M7QUFDRCxPQUZELE1BRU8sSUFBRzNCLGdCQUFnQixVQUFuQixFQUErQjtBQUNwQ00sbUJBQVdzQixFQUFYLENBQWNNLFFBQWQsQ0FBdUJWLE9BQXZCLENBQStCRyxTQUFTLE9BQU9PLFNBQVNQLEtBQVQsQ0FBL0M7QUFDRDtBQUNGLEtBTkQ7QUFPQSxVQUFNUSxnQkFBZ0JsQixNQUFNL0Isb0JBQU4sR0FDcEIrQixNQUFNa0IsYUFBTixJQUF1QixLQUFLSixRQUFMLENBQWNwRCxTQUFkLEVBQXlCcUIsV0FBekIsRUFBc0MsQ0FBQyxPQUFELENBQXRDLENBREgsR0FDc0QsSUFENUU7QUFFQWlCLFVBQU1rQixhQUFOLEdBQXNCQSxhQUF0Qjs7QUFFQSxVQUFNdkQsU0FBUzBDLEtBQUtDLEtBQUwsQ0FBVyx5QkFBZU4sTUFBTXJDLE1BQXJCLENBQVgsQ0FBZjtBQUNBLFFBQUdvQixnQkFBZ0IsVUFBbkIsRUFBK0I7QUFDN0JwQixhQUFPaUMsSUFBUCxDQUFZLENBQUNDLENBQUQsRUFBR0MsQ0FBSCxLQUFTaUIsT0FBT2xCLEVBQUVtQixFQUFULElBQWVELE9BQU9qQixFQUFFa0IsRUFBVCxDQUFwQztBQUNELEtBRkQsTUFFTztBQUNMckQsYUFBT2lDLElBQVAsQ0FBWSxDQUFDQyxDQUFELEVBQUdDLENBQUgsS0FBU0csVUFBVUosQ0FBVixFQUFhQyxDQUFiLEVBQWdCLElBQWhCLENBQXJCO0FBQ0Q7QUFDRG5DLFdBQU80QyxPQUFQLENBQWVZLFNBQVM7QUFDdEIsVUFBR3BDLGdCQUFnQixVQUFuQixFQUErQjtBQUM3Qk0sbUJBQVdvQixFQUFYLENBQWNVLEtBQWQsQ0FBb0JaLE9BQXBCLENBQTRCRyxTQUFTLE9BQU9TLE1BQU1ULEtBQU4sQ0FBNUM7QUFDRCxPQUZELE1BRU8sSUFBRzNCLGdCQUFnQixVQUFuQixFQUErQjtBQUNwQ00sbUJBQVdzQixFQUFYLENBQWNRLEtBQWQsQ0FBb0JaLE9BQXBCLENBQTRCRyxTQUFTLE9BQU9TLE1BQU1ULEtBQU4sQ0FBNUM7QUFDRDtBQUNGLEtBTkQ7QUFPQSxVQUFNVSxhQUFhcEIsTUFBTWhDLGlCQUFOLEdBQ2pCZ0MsTUFBTW9CLFVBQU4sSUFBb0IsS0FBS04sUUFBTCxDQUFjbkQsTUFBZCxFQUFzQm9CLFdBQXRCLEVBQW1DLENBQUMsT0FBRCxDQUFuQyxDQURILEdBQ21ELElBRHRFO0FBRUFpQixVQUFNb0IsVUFBTixHQUFtQkEsVUFBbkI7O0FBRUEsUUFBSW5DLG1CQUFtQmUsS0FBdkIsRUFBOEI7QUFDNUJmLHFCQUFlckIsc0JBQWYsR0FBd0Msc0JBQWMsRUFBZCxFQUFrQm9DLE1BQU1wQyxzQkFBTixJQUFnQyxFQUFsRCxDQUF4QztBQUNBcUIscUJBQWUyQixrQkFBZixHQUFvQ0Esa0JBQXBDO0FBQ0EzQixxQkFBZXZCLFNBQWYsR0FBMkIsQ0FBQ3NDLE1BQU10QyxTQUFOLElBQW1CLEVBQXBCLEVBQXdCMkQsR0FBeEIsQ0FBNEJDLEtBQUssc0JBQWMsRUFBZCxFQUFrQkEsQ0FBbEIsQ0FBakMsQ0FBM0I7QUFDQXJDLHFCQUFlaUMsYUFBZixHQUErQkEsYUFBL0I7QUFDQWpDLHFCQUFldEIsTUFBZixHQUF3QixDQUFDcUMsTUFBTXJDLE1BQU4sSUFBZ0IsRUFBakIsRUFBcUIwRCxHQUFyQixDQUF5QkUsS0FBSyxzQkFBYyxFQUFkLEVBQWtCQSxDQUFsQixDQUE5QixDQUF4QjtBQUNBdEMscUJBQWVtQyxVQUFmLEdBQTRCQSxVQUE1QjtBQUNEOztBQUVELFdBQU87QUFDTEkseUJBQW1CWixrQkFEZDtBQUVMYSxvQkFBY1AsYUFGVDtBQUdMUSxpQkFBV047QUFITixLQUFQO0FBS0Q7O0FBRUQ7Ozs7OztBQU1BWixnQkFBY21CLE1BQWQsRUFBc0I7QUFDcEIsV0FBTyxLQUFLcEUsY0FBTCxDQUFvQkssc0JBQXBCLENBQTJDK0QsTUFBM0MsQ0FBUDtBQUNEOztBQUVEOzs7OztBQUtBQyxRQUFNRCxNQUFOLEVBQWM7QUFDWixXQUFPLEtBQUtwRSxjQUFMLENBQW9CTSxjQUFwQixDQUFtQzhELE1BQW5DLENBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9BOzs7O0FBSUEsTUFBSXhELGFBQUosR0FBb0I7QUFDbEIsUUFBSSxLQUFLWixjQUFMLENBQW9CWSxhQUF4QixFQUF1QztBQUNyQyxhQUFPO0FBQ0wwRCxjQUFNLEtBQUt0RSxjQUFMLENBQW9CWSxhQURyQjtBQUVMMkQsb0JBQVksS0FBS3ZFLGNBQUwsQ0FBb0JhO0FBRjNCLE9BQVA7QUFJRCxLQUxELE1BS087QUFDTCxhQUFPWCxTQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7O0FBTUEsUUFBTXNFLFlBQU4sQ0FBbUJKLE1BQW5CLEVBQTJCSyxtQkFBbUIsRUFBOUMsRUFBa0Q7QUFDaEQsU0FBSzFFLHFCQUFMLENBQTJCcUUsTUFBM0IsSUFBcUMsS0FBS3JFLHFCQUFMLENBQTJCcUUsTUFBM0IsS0FBc0MsRUFBM0U7QUFDQSxRQUFJLENBQUMsS0FBS0MsS0FBTCxDQUFXRCxNQUFYLENBQUwsRUFBeUI7QUFDdkIsWUFBTSxrQkFBUU0sSUFBUixDQUFhLENBQ2pCLHNCQUFZQyxPQUFPLEtBQUs1RSxxQkFBTCxDQUEyQnFFLE1BQTNCLEVBQW1DUSxJQUFuQyxDQUF3Q0QsR0FBeEMsQ0FBbkIsQ0FEaUIsRUFFakIsc0JBQVlBLE9BQU9FLFdBQVdGLEdBQVgsRUFBZ0JGLG1CQUFtQixJQUFuQyxDQUFuQixDQUZpQixDQUFiLENBQU47QUFJRDtBQUNELFdBQU8sS0FBS0osS0FBTCxDQUFXRCxNQUFYLENBQVA7QUFDRDs7QUFFRDs7OztBQUlBVSxjQUFZckQsYUFBWixFQUEyQjtBQUN6QixTQUFLRSxTQUFMLENBQWVGLGFBQWYsRUFBOEJSLFNBQTlCLEdBQTBDLElBQTFDO0FBQ0Q7O0FBRUQ7Ozs7QUFJQThELGlCQUFldEQsYUFBZixFQUE4QjtBQUM1QixRQUFJZ0IsUUFBUSxLQUFLZCxTQUFMLENBQWVGLGFBQWYsQ0FBWjtBQUNBZ0IsVUFBTXhCLFNBQU4sR0FBa0IsS0FBbEI7QUFDQXdCLFVBQU1wQixpQkFBTixHQUEwQixLQUExQjtBQUNEOztBQUVEOzs7OztBQUtBMkQsa0NBQWdDdkQsYUFBaEMsRUFBK0NSLFNBQS9DLEVBQTBEO0FBQ3hELFNBQUtVLFNBQUwsQ0FBZUYsYUFBZixFQUE4QkosaUJBQTlCLEdBQWtESixTQUFsRDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBZ0UsMkJBQXlCeEQsYUFBekIsRUFBd0N5RCxxQkFBeEMsRUFBK0RDLGdCQUEvRCxFQUFpRkMsYUFBakYsRUFBZ0dDLGlCQUFoRyxFQUFtSDtBQUNqSCxVQUFNQyx1QkFBdUIsS0FBS0Msb0NBQUwsQ0FBMEM5RCxhQUExQyxFQUMxQlMsTUFEMEIsQ0FDbkJzRCxjQUFjLENBQUMsS0FBSzFGLHFCQUFMLENBQTJCMEYsVUFBM0IsRUFBdUMvRSxpQkFEbkMsQ0FBN0I7QUFFQTZFLHlCQUFxQmpELElBQXJCLENBQTBCLENBQUNDLENBQUQsRUFBR0MsQ0FBSCxLQUFTQSxFQUFFQyxrQkFBRixHQUF1QkYsRUFBRUUsa0JBQTVEO0FBQ0E4Qyx5QkFBcUJHLEtBQXJCLENBQTJCLENBQTNCLEVBQThCekMsT0FBOUIsQ0FBc0N3QyxjQUFjLE9BQU8sS0FBSzFGLHFCQUFMLENBQTJCMEYsVUFBM0IsQ0FBM0Q7O0FBRUEsUUFBSS9DLFFBQVEsS0FBS2QsU0FBTCxDQUFlRixhQUFmLENBQVo7QUFDQWdCLFVBQU1ELGtCQUFOLEdBQTJCa0QsS0FBS0MsR0FBTCxFQUEzQjtBQUNBbEQsVUFBTXhDLGtCQUFOLEdBQTJCQyxTQUEzQjtBQUNBdUMsVUFBTW5DLGNBQU4sR0FBdUIsRUFBdkI7QUFDQSxRQUFHNkUsZ0JBQUgsRUFBcUI7QUFDbkIxQyxZQUFNdEMsU0FBTixHQUFrQixFQUFsQjtBQUNBc0MsWUFBTWpDLGdCQUFOLEdBQXlCLEVBQXpCO0FBQ0FpQyxZQUFNL0Isb0JBQU4sR0FBNkIsS0FBN0I7QUFDQStCLFlBQU1rQixhQUFOLEdBQXNCLElBQXRCO0FBQ0Q7QUFDRCxRQUFHeUIsYUFBSCxFQUFrQjtBQUNoQjNDLFlBQU1yQyxNQUFOLEdBQWUsRUFBZjtBQUNBcUMsWUFBTWxDLGVBQU4sR0FBd0IsRUFBeEI7QUFDQWtDLFlBQU1oQyxpQkFBTixHQUEwQixLQUExQjtBQUNBZ0MsWUFBTW9CLFVBQU4sR0FBbUIsSUFBbkI7QUFDRDtBQUNELFFBQUdxQixxQkFBSCxFQUEwQjtBQUN4QixXQUFLcEUsT0FBTCxDQUFhOEUsS0FBYixDQUFtQixNQUFPLEdBQUUsS0FBS2hHLFVBQVcsSUFBRzZCLGFBQWMsSUFBRzRELGlCQUFrQiwyQkFBekQsR0FDdkIsMEJBREY7QUFFQTVDLFlBQU1wQyxzQkFBTixHQUErQixFQUEvQjtBQUNBb0MsWUFBTVksa0JBQU4sR0FBMkIsSUFBM0I7QUFDRCxLQUxELE1BS087QUFDTCxXQUFLdkMsT0FBTCxDQUFhOEUsS0FBYixDQUFtQixNQUFPLEdBQUUsS0FBS2hHLFVBQVcsSUFBRzZCLGFBQWMsSUFBRzRELGlCQUFrQixxQkFBekQsR0FDdEIsNENBQTJDLG9CQUFZNUMsTUFBTXBDLHNCQUFOLElBQWdDLEVBQTVDLEVBQWdEaUQsTUFBTyxHQUQ1RSxHQUV2Qix1QkFGRjtBQUdEO0FBQ0Y7O0FBRUQ7Ozs7O0FBS0F1Qyw4QkFBNEJwRSxhQUE1QixFQUEyQ3hCLGtCQUEzQyxFQUErRDtBQUM3RCxRQUFJd0MsUUFBUSxLQUFLZCxTQUFMLENBQWVGLGFBQWYsQ0FBWjtBQUNBLFNBQUtxRSx1QkFBTCxDQUE2QnJFLGFBQTdCO0FBQ0FnQixVQUFNeEMsa0JBQU4sR0FBMkJBLGtCQUEzQjtBQUNBLFFBQUlBLGtCQUFKLEVBQXdCO0FBQ3RCLFdBQUtELGNBQUwsQ0FBb0JDLGtCQUFwQixHQUF5QyxzQkFBYyxFQUFkLEVBQWtCQSxrQkFBbEIsQ0FBekM7QUFDRDtBQUNGOztBQUVEOzs7Ozs7QUFNQThGLHNCQUFvQnRFLGFBQXBCLEVBQW1DdEIsU0FBbkMsRUFBOEM7QUFDNUMsUUFBSXNDLFFBQVEsS0FBS2QsU0FBTCxDQUFlRixhQUFmLENBQVo7QUFDQSxTQUFLcUUsdUJBQUwsQ0FBNkJyRSxhQUE3QjtBQUNBZ0IsVUFBTXRDLFNBQU4sR0FBa0JBLFNBQWxCO0FBQ0FzQyxVQUFNa0IsYUFBTixHQUFzQixJQUF0QjtBQUNEOztBQUVEOzs7Ozs7QUFNQXFDLDBCQUF3QnZFLGFBQXhCLEVBQXVDNEQsaUJBQXZDLEVBQTBEO0FBQ3hELFFBQUk1QyxRQUFRLEtBQUtkLFNBQUwsQ0FBZUYsYUFBZixDQUFaO0FBQ0FnQixVQUFNakMsZ0JBQU4sR0FBeUIsRUFBekI7QUFDQWlDLFVBQU0vQixvQkFBTixHQUE2QixJQUE3QjtBQUNEOztBQUVEOzs7OztBQUtBdUYsb0JBQWtCeEUsYUFBbEIsRUFBaUNpQyxRQUFqQyxFQUEyQztBQUN6QyxRQUFJd0MsZ0JBQWdCLEtBQUt2RSxTQUFMLENBQWVGLGFBQWYsQ0FBcEI7QUFDQSxTQUFLcUUsdUJBQUwsQ0FBNkJyRSxhQUE3QjtBQUNBeUUsa0JBQWN2QyxhQUFkLEdBQThCLElBQTlCOztBQUVBLFVBQU13QyxpQkFBa0IxRCxLQUFELElBQVc7QUFDaEMsVUFBSTJELFFBQVEzRCxNQUFNdEMsU0FBTixDQUFnQmtHLFNBQWhCLENBQTBCdEMsS0FBS0EsRUFBRU4sRUFBRixLQUFTQyxTQUFTRCxFQUFqRCxDQUFaO0FBQ0EsVUFBSTJDLFVBQVUsQ0FBQyxDQUFmLEVBQWtCO0FBQ2hCM0QsY0FBTXRDLFNBQU4sQ0FBZ0JpRyxLQUFoQixJQUF5QjFDLFFBQXpCO0FBQ0QsT0FGRCxNQUVPLElBQUksQ0FBQ2pCLE1BQU1qQyxnQkFBTixDQUF1QmtELFNBQVNELEVBQWhDLENBQUwsRUFBMEM7QUFDL0NoQixjQUFNdEMsU0FBTixDQUFnQnlFLElBQWhCLENBQXFCbEIsUUFBckI7QUFDRDtBQUNGLEtBUEQ7QUFRQXlDLG1CQUFlRCxhQUFmO0FBQ0FDLG1CQUFlLEtBQUtuRyxjQUFwQjtBQUNEOztBQUVEOzs7OztBQUtBc0csb0JBQWtCN0UsYUFBbEIsRUFBaUM4RSxVQUFqQyxFQUE2QztBQUMzQyxRQUFJTCxnQkFBZ0IsS0FBS3ZFLFNBQUwsQ0FBZUYsYUFBZixDQUFwQjtBQUNBLFNBQUtxRSx1QkFBTCxDQUE2QnJFLGFBQTdCO0FBQ0F5RSxrQkFBY3ZDLGFBQWQsR0FBOEIsSUFBOUI7O0FBRUEsVUFBTTZDLGlCQUFrQi9ELEtBQUQsSUFBVztBQUNoQyxVQUFJaUIsV0FBV2pCLE1BQU10QyxTQUFOLENBQWdCc0csSUFBaEIsQ0FBcUIxQyxLQUFLQSxFQUFFTixFQUFGLEtBQVM4QyxVQUFuQyxDQUFmO0FBQ0EsVUFBSSxDQUFDN0MsUUFBTCxFQUFlO0FBQ2IsYUFBSyxJQUFJZ0QsQ0FBVCxJQUFjLHVCQUFlakUsTUFBTWpDLGdCQUFyQixDQUFkLEVBQXNEO0FBQ3BELGNBQUlrRyxFQUFFLENBQUYsSUFBTyxJQUFJLEVBQUosR0FBUyxJQUFoQixHQUF1QmhCLEtBQUtDLEdBQUwsRUFBM0IsRUFBdUM7QUFDckMsbUJBQU9sRCxNQUFNakMsZ0JBQU4sQ0FBdUJrRyxFQUFFLENBQUYsQ0FBdkIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRGpFLGNBQU1qQyxnQkFBTixDQUF1QitGLFVBQXZCLElBQXFDYixLQUFLQyxHQUFMLEVBQXJDO0FBQ0QsT0FQRCxNQU9PO0FBQ0xsRCxjQUFNdEMsU0FBTixHQUFrQnNDLE1BQU10QyxTQUFOLENBQWdCK0IsTUFBaEIsQ0FBdUI2QixLQUFLQSxFQUFFTixFQUFGLEtBQVM4QyxVQUFyQyxDQUFsQjtBQUNEO0FBQ0YsS0FaRDtBQWFBQyxtQkFBZU4sYUFBZjtBQUNBTSxtQkFBZSxLQUFLeEcsY0FBcEI7QUFDRDs7QUFFRDs7Ozs7O0FBTUEyRywwQkFBd0JsRixhQUF4QixFQUF1Q3JCLE1BQXZDLEVBQStDO0FBQzdDLFFBQUlxQyxRQUFRLEtBQUtkLFNBQUwsQ0FBZUYsYUFBZixDQUFaO0FBQ0EsU0FBS3FFLHVCQUFMLENBQTZCckUsYUFBN0I7QUFDQWdCLFVBQU1vQixVQUFOLEdBQW1CLElBQW5CO0FBQ0FwQixVQUFNckMsTUFBTixHQUFlQSxNQUFmO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxRQUFNd0csMkJBQU4sQ0FBa0NuRixhQUFsQyxFQUFpRDRELGlCQUFqRCxFQUFvRTtBQUNsRSxRQUFJNUMsUUFBUSxLQUFLZCxTQUFMLENBQWVGLGFBQWYsQ0FBWjtBQUNBZ0IsVUFBTWxDLGVBQU4sR0FBd0IsRUFBeEI7QUFDQWtDLFVBQU0vQixvQkFBTixHQUE2QixJQUE3QjtBQUNBK0IsVUFBTWhDLGlCQUFOLEdBQTBCLElBQTFCO0FBQ0EsU0FBS1QsY0FBTCxDQUFvQkMsa0JBQXBCLEdBQXlDd0MsTUFBTXhDLGtCQUFOLEdBQTJCLHNCQUFjLEVBQWQsRUFBa0J3QyxNQUFNeEMsa0JBQXhCLENBQTNCLEdBQ3ZDQyxTQURGO0FBRUEsU0FBS0YsY0FBTCxDQUFvQkcsU0FBcEIsR0FBZ0MsQ0FBQ3NDLE1BQU10QyxTQUFOLElBQW1CLEVBQXBCLEVBQXdCMkQsR0FBeEIsQ0FBNEJDLEtBQUssc0JBQWMsRUFBZCxFQUFrQkEsQ0FBbEIsQ0FBakMsQ0FBaEM7QUFDQSxTQUFLL0QsY0FBTCxDQUFvQkksTUFBcEIsR0FBNkIsQ0FBQ3FDLE1BQU1yQyxNQUFOLElBQWdCLEVBQWpCLEVBQXFCMEQsR0FBckIsQ0FBeUJFLEtBQUssc0JBQWMsRUFBZCxFQUFrQkEsQ0FBbEIsQ0FBOUIsQ0FBN0I7QUFDQSxTQUFLaEUsY0FBTCxDQUFvQkssc0JBQXBCLEdBQTZDLHNCQUFjLEVBQWQsRUFBa0JvQyxNQUFNcEMsc0JBQXhCLENBQTdDO0FBQ0EsU0FBS1MsT0FBTCxDQUFhOEUsS0FBYixDQUFtQixNQUFPLEdBQUUsS0FBS2hHLFVBQVcsSUFBRzZCLGFBQWMsSUFBRzRELGlCQUFrQiwrQkFBekQsR0FDdkIsc0JBRHVCLEdBRXRCLEdBQUU1RCxhQUFjLEtBQUksb0JBQVlnQixNQUFNcEMsc0JBQU4sSUFBZ0MsRUFBNUMsRUFBZ0RpRCxNQUFPLDBCQUY5RTtBQUdBLFNBQUt0RCxjQUFMLENBQW9CVSxvQkFBcEIsR0FBMkMsSUFBM0M7QUFDQSxTQUFLVixjQUFMLENBQW9CUyxpQkFBcEIsR0FBd0MsSUFBeEM7QUFDQSxTQUFLVCxjQUFMLENBQW9CTyxlQUFwQixHQUFzQyxFQUF0QztBQUNBLFNBQUtQLGNBQUwsQ0FBb0JRLGdCQUFwQixHQUF1QyxFQUF2QztBQUNBLFNBQUksSUFBSWdGLFVBQVIsSUFBc0IsS0FBS0Qsb0NBQUwsQ0FBMEM5RCxhQUExQyxDQUF0QixFQUFnRjtBQUM5RSxVQUFJLENBQUMsS0FBSzNCLHFCQUFMLENBQTJCMEYsVUFBM0IsRUFBdUN2RSxTQUE1QyxFQUF1RDtBQUNyRCxlQUFPLEtBQUtuQixxQkFBTCxDQUEyQjBGLFVBQTNCLENBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BcUIsd0JBQXNCcEYsYUFBdEIsRUFBcUNtQyxLQUFyQyxFQUE0QztBQUMxQyxRQUFJc0MsZ0JBQWdCLEtBQUt2RSxTQUFMLENBQWVGLGFBQWYsQ0FBcEI7QUFDQSxTQUFLcUUsdUJBQUwsQ0FBNkJyRSxhQUE3QjtBQUNBeUUsa0JBQWNyQyxVQUFkLEdBQTJCLElBQTNCOztBQUVBLFVBQU1pRCxxQkFBc0JyRSxLQUFELElBQVc7QUFDcEMsVUFBSTJELFFBQVEzRCxNQUFNckMsTUFBTixDQUFhaUcsU0FBYixDQUF1QnJDLEtBQUtBLEVBQUVQLEVBQUYsS0FBU0csTUFBTUgsRUFBM0MsQ0FBWjtBQUNBLFVBQUkyQyxVQUFVLENBQUMsQ0FBZixFQUFrQjtBQUNoQjNELGNBQU1yQyxNQUFOLENBQWFnRyxLQUFiLElBQXNCeEMsS0FBdEI7QUFDRCxPQUZELE1BRU8sSUFBSSxDQUFDbkIsTUFBTWxDLGVBQU4sQ0FBc0JxRCxNQUFNSCxFQUE1QixDQUFMLEVBQXNDO0FBQzNDaEIsY0FBTXJDLE1BQU4sQ0FBYXdFLElBQWIsQ0FBa0JoQixLQUFsQjtBQUNEO0FBQ0YsS0FQRDtBQVFBa0QsdUJBQW1CWixhQUFuQjtBQUNBWSx1QkFBbUIsS0FBSzlHLGNBQXhCO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BK0csMEJBQXdCdEYsYUFBeEIsRUFBdUN1RixPQUF2QyxFQUFnRDtBQUM5QyxRQUFJZCxnQkFBZ0IsS0FBS3ZFLFNBQUwsQ0FBZUYsYUFBZixDQUFwQjtBQUNBLFNBQUtxRSx1QkFBTCxDQUE2QnJFLGFBQTdCO0FBQ0F5RSxrQkFBY3JDLFVBQWQsR0FBMkIsSUFBM0I7O0FBRUEsVUFBTW9ELGdCQUFpQnhFLEtBQUQsSUFBVztBQUMvQixVQUFJbUIsUUFBUW5CLE1BQU1yQyxNQUFOLENBQWFxRyxJQUFiLENBQWtCekMsS0FBS0EsRUFBRVAsRUFBRixLQUFTdUQsT0FBaEMsQ0FBWjtBQUNBLFVBQUksQ0FBQ3BELEtBQUwsRUFBWTtBQUNWLGFBQUssSUFBSThDLENBQVQsSUFBYyx1QkFBZWpFLE1BQU1sQyxlQUFyQixDQUFkLEVBQXFEO0FBQ25ELGNBQUltRyxFQUFFLENBQUYsSUFBTyxJQUFJLEVBQUosR0FBUyxJQUFoQixHQUF1QmhCLEtBQUtDLEdBQUwsRUFBM0IsRUFBdUM7QUFDckMsbUJBQU9sRCxNQUFNbEMsZUFBTixDQUFzQm1HLEVBQUUsQ0FBRixDQUF0QixDQUFQO0FBQ0Q7QUFDRjtBQUNEakUsY0FBTWxDLGVBQU4sQ0FBc0J5RyxPQUF0QixJQUFpQ3RCLEtBQUtDLEdBQUwsRUFBakM7QUFDRCxPQVBELE1BT087QUFDTGxELGNBQU1yQyxNQUFOLEdBQWVxQyxNQUFNckMsTUFBTixDQUFhOEIsTUFBYixDQUFvQjhCLEtBQUtBLEVBQUVQLEVBQUYsS0FBU3VELE9BQWxDLENBQWY7QUFDRDtBQUNGLEtBWkQ7QUFhQUMsa0JBQWNmLGFBQWQ7QUFDQWUsa0JBQWMsS0FBS2pILGNBQW5CO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1Ba0gsZ0NBQThCekYsYUFBOUIsRUFBNkNILGNBQTdDLEVBQTZENkYsY0FBN0QsRUFBNkU7QUFDM0UsUUFBSWpCLGdCQUFnQixLQUFLdkUsU0FBTCxDQUFlRixhQUFmLENBQXBCO0FBQ0EsU0FBS3FFLHVCQUFMLENBQTZCckUsYUFBN0I7QUFDQXlFLGtCQUFjN0Msa0JBQWQsR0FBbUMsSUFBbkM7O0FBRUEsVUFBTStELHVCQUF3QjNFLEtBQUQsSUFBVztBQUN0QyxXQUFLLElBQUlRLGFBQVQsSUFBMEIzQixjQUExQixFQUEwQztBQUN4Q21CLGNBQU1wQyxzQkFBTixDQUE2QjRDLGNBQWNtQixNQUEzQyxJQUFxRG5CLGFBQXJEO0FBQ0Q7QUFDRCxXQUFLLElBQUltQixNQUFULElBQW1CK0MsY0FBbkIsRUFBbUM7QUFDakMsZUFBTzFFLE1BQU1wQyxzQkFBTixDQUE2QitELE1BQTdCLENBQVA7QUFDRDtBQUNGLEtBUEQ7QUFRQWdELHlCQUFxQmxCLGFBQXJCO0FBQ0FrQix5QkFBcUIsS0FBS3BILGNBQTFCO0FBQ0EsU0FBS2MsT0FBTCxDQUFhOEUsS0FBYixDQUFtQixNQUFPLEdBQUUsS0FBS2hHLFVBQVcsSUFBRzZCLGFBQWMsYUFBWUgsZUFBZWdDLE1BQU8sbUJBQXRFLEdBQ3RCLFdBQVU2RCxlQUFlN0QsTUFBTyw2QkFEVixHQUV0QixHQUFFLG9CQUFZNEMsY0FBYzdGLHNCQUFkLElBQXdDLEVBQXBELEVBQXdEaUQsTUFBTyw4QkFGcEU7QUFHRDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDQStELHdCQUFzQjVGLGFBQXRCLEVBQXFDNkYsTUFBckMsRUFBNkNDLE1BQTdDLEVBQXFEQyxNQUFyRCxFQUE2REMsVUFBN0QsRUFBeUVDLFdBQXpFLEVBQXNGO0FBQ3BGLFFBQUl4QixnQkFBZ0IsS0FBS3ZFLFNBQUwsQ0FBZUYsYUFBZixDQUFwQjtBQUNBLFNBQUtxRSx1QkFBTCxDQUE2QnJFLGFBQTdCOztBQUVBO0FBQ0EsVUFBTWtHLHFCQUFzQmxGLEtBQUQsSUFBVztBQUNwQ0EsWUFBTTlCLGNBQU4sR0FBdUJpSCxLQUFLQyxHQUFMLENBQVNQLE9BQU94RCxHQUFQLENBQVdDLEtBQUtBLEVBQUVPLElBQUYsQ0FBT3dELE9BQVAsRUFBaEIsQ0FBVCxDQUF2QjtBQUNBLFVBQUlDLG9CQUFvQixLQUF4QjtBQUNBLFVBQUlDLGVBQWUsS0FBbkI7QUFDQSxXQUFLLElBQUkzRCxLQUFULElBQWtCaUQsVUFBVSxFQUE1QixFQUFnQztBQUM5QixZQUFJVyxlQUFleEYsTUFBTW5DLGNBQU4sQ0FBcUIrRCxNQUFNRCxNQUEzQixDQUFuQjtBQUNBLFlBQUk2RCxnQkFBZ0JBLGFBQWEzRCxJQUFiLENBQWtCd0QsT0FBbEIsS0FBOEJ6RCxNQUFNQyxJQUFOLENBQVd3RCxPQUFYLEVBQWxELEVBQXdFO0FBQ3RFO0FBQ0QsU0FGRCxNQUVPO0FBQ0xFLHlCQUFlLElBQWY7QUFDRDtBQUNELFlBQUksQ0FBQ3ZGLE1BQU03QixhQUFQLElBQXdCNkIsTUFBTTdCLGFBQU4sQ0FBb0JrSCxPQUFwQixLQUFnQ3pELE1BQU1DLElBQU4sQ0FBV3dELE9BQVgsRUFBNUQsRUFBa0Y7QUFDaEZyRixnQkFBTTdCLGFBQU4sR0FBc0J5RCxNQUFNQyxJQUE1QjtBQUNBN0IsZ0JBQU01QixtQkFBTixHQUE0QndELE1BQU1FLFVBQWxDO0FBQ0Q7QUFDRDlCLGNBQU1uQyxjQUFOLENBQXFCK0QsTUFBTUQsTUFBM0IsSUFBcUNDLEtBQXJDO0FBQ0EsWUFBSWxFLFlBQVlzQyxNQUFNdEMsU0FBTixDQUFnQitCLE1BQWhCLENBQXVCNkIsS0FBS0EsRUFBRUssTUFBRixLQUFhQyxNQUFNRCxNQUEvQyxDQUFoQjtBQUNBLFlBQUk4RCxpQkFBaUJ6RixNQUFNdEMsU0FBTixDQUFnQitCLE1BQWhCLENBQXVCNkIsS0FBS0EsRUFBRUssTUFBRixLQUFhQyxNQUFNRCxNQUEvQyxDQUFyQjtBQUNBLFlBQUloRSxTQUFTcUMsTUFBTXJDLE1BQU4sQ0FBYThCLE1BQWIsQ0FBb0I4QixLQUFLQSxFQUFFSSxNQUFGLEtBQWFDLE1BQU1ELE1BQTVDLENBQWI7QUFDQTJELDRCQUFvQixJQUFwQjtBQUNBLGFBQUssSUFBSXJFLFFBQVQsSUFBcUJ3RSxjQUFyQixFQUFxQztBQUNuQyxjQUFJbkUsSUFBSXRCLE1BQU1uQyxjQUFOLENBQXFCb0QsU0FBU1UsTUFBOUIsQ0FBUjtBQUNBLGNBQUlMLENBQUosRUFBTztBQUNMLGdCQUFJTCxTQUFTeUUsZ0JBQVQsS0FBOEJqSSxTQUFsQyxFQUE2QztBQUMzQyxtQkFBS2tJLHNCQUFMLENBQTRCMUUsUUFBNUIsRUFBc0NLLENBQXRDO0FBQ0Q7QUFDRixXQUpELE1BSU87QUFDTGdFLGdDQUFvQixLQUFwQjtBQUNEO0FBQ0Y7QUFDRCxhQUFLLElBQUlyRSxRQUFULElBQXFCdkQsU0FBckIsRUFBZ0M7QUFDOUIsZUFBS2lJLHNCQUFMLENBQTRCMUUsUUFBNUIsRUFBc0NXLEtBQXRDO0FBQ0Q7QUFDRCxhQUFLLElBQUlULEtBQVQsSUFBa0J4RCxNQUFsQixFQUEwQjtBQUN4QndELGdCQUFNcUUsWUFBTixHQUFxQnJFLE1BQU15RSxJQUFOLEtBQWUsZ0JBQWYsSUFBbUN6RSxNQUFNeUUsSUFBTixLQUFlLHNCQUFsRCxJQUNyQnpFLE1BQU15RSxJQUFOLEtBQWUscUJBRE0sSUFDbUJ6RSxNQUFNeUUsSUFBTixLQUFlLDJCQURsQyxHQUNnRWhFLE1BQU1pRSxHQUR0RSxHQUM0RWpFLE1BQU1rRSxHQUR2RztBQUVEO0FBQ0QsWUFBSUMsZ0JBQWdCLEtBQUt6SSxxQkFBTCxDQUEyQnNFLE1BQU1ELE1BQWpDLEtBQTRDLEVBQWhFO0FBQ0EsWUFBSW9FLGNBQWNsRixNQUFsQixFQUEwQjtBQUN4QixlQUFLLElBQUltRixPQUFULElBQW9CRCxhQUFwQixFQUFtQztBQUNqQ0M7QUFDRDtBQUNELGlCQUFPLEtBQUsxSSxxQkFBTCxDQUEyQnNFLE1BQU1ELE1BQWpDLENBQVA7QUFDRDtBQUNGO0FBQ0QsVUFBSTRELGdCQUFnQnZGLE1BQU14QyxrQkFBMUIsRUFBOEM7QUFDNUMsWUFBSXdDLE1BQU0vQixvQkFBTixJQUE4QnFILGlCQUFsQyxFQUFxRDtBQUNuRCxjQUFJdEYsTUFBTXhDLGtCQUFOLENBQXlCeUksUUFBekIsS0FBc0MsS0FBMUMsRUFBaUQ7QUFDL0NqRyxrQkFBTXhDLGtCQUFOLENBQXlCc0gsTUFBekIsR0FBa0NBLFdBQVdySCxTQUFYLEdBQXVCcUgsTUFBdkIsR0FBZ0M5RSxNQUFNeEMsa0JBQU4sQ0FBeUIwSSxPQUF6QixHQUNoRWxHLE1BQU10QyxTQUFOLENBQWdCZSxNQUFoQixDQUF1QixDQUFDQyxHQUFELEVBQU00QyxDQUFOLEtBQVk1QyxNQUNqQ3lHLEtBQUtnQixLQUFMLENBQVcsQ0FBQzdFLEVBQUVvRSxnQkFBRixJQUFzQixDQUF2QixJQUE0QixHQUF2QyxJQUE4QyxHQURiLEdBQ21CUCxLQUFLZ0IsS0FBTCxDQUFXLENBQUM3RSxFQUFFOEUsSUFBRixJQUFVLENBQVgsSUFBZ0IsR0FBM0IsSUFBa0MsR0FEeEYsRUFDNkYsQ0FEN0YsQ0FERjtBQUdELFdBSkQsTUFJTztBQUNMcEcsa0JBQU14QyxrQkFBTixDQUF5QnNILE1BQXpCLEdBQWtDQSxXQUFXckgsU0FBWCxHQUF1QnFILE1BQXZCLEdBQWdDOUUsTUFBTXhDLGtCQUFOLENBQXlCMEksT0FBekIsR0FDbEVsRyxNQUFNdEMsU0FBTixDQUFnQmUsTUFBaEIsQ0FBdUIsQ0FBQ0MsR0FBRCxFQUFNNEMsQ0FBTixLQUFZNUMsTUFBTXlHLEtBQUtnQixLQUFMLENBQVcsQ0FBQzdFLEVBQUU4RSxJQUFGLElBQVUsQ0FBWCxJQUFnQixHQUEzQixJQUFrQyxHQUF4QyxHQUNqQ2pCLEtBQUtnQixLQUFMLENBQVcsQ0FBQzdFLEVBQUUrRSxVQUFGLElBQWdCLENBQWpCLElBQXNCLEdBQWpDLElBQXdDLEdBRFAsR0FDYWxCLEtBQUtnQixLQUFMLENBQVcsQ0FBQzdFLEVBQUVvRSxnQkFBRixJQUFzQixDQUF2QixJQUE0QixHQUF2QyxJQUE4QyxHQUQ5RixFQUNtRyxDQURuRyxDQURBO0FBR0Q7QUFDRDFGLGdCQUFNeEMsa0JBQU4sQ0FBeUJzSCxNQUF6QixHQUFrQ0ssS0FBS2dCLEtBQUwsQ0FBV25HLE1BQU14QyxrQkFBTixDQUF5QnNILE1BQXpCLEdBQWtDLEdBQTdDLElBQW9ELEdBQXRGO0FBQ0QsU0FYRCxNQVdPO0FBQ0w5RSxnQkFBTXhDLGtCQUFOLENBQXlCc0gsTUFBekIsR0FBa0NBLFdBQVdySCxTQUFYLEdBQXVCcUgsTUFBdkIsR0FBZ0M5RSxNQUFNeEMsa0JBQU4sQ0FBeUJzSCxNQUEzRjtBQUNEO0FBQ0Q5RSxjQUFNeEMsa0JBQU4sQ0FBeUJ1SCxNQUF6QixHQUFrQ0EsV0FBV3RILFNBQVgsR0FBdUJzSCxNQUF2QixHQUFnQy9FLE1BQU14QyxrQkFBTixDQUF5QnVILE1BQTNGO0FBQ0EvRSxjQUFNeEMsa0JBQU4sQ0FBeUJ3SCxVQUF6QixHQUFzQ0EsZUFBZXZILFNBQWYsR0FBMkJ1SCxVQUEzQixHQUNwQ2hGLE1BQU14QyxrQkFBTixDQUF5QndILFVBRDNCO0FBRUFoRixjQUFNeEMsa0JBQU4sQ0FBeUJ5SCxXQUF6QixHQUF1Q0QsZUFBZXZILFNBQWYsR0FBMkJ3SCxXQUEzQixHQUNyQ2pGLE1BQU14QyxrQkFBTixDQUF5QnlILFdBRDNCO0FBRUQ7QUFDRixLQWxFRDtBQW1FQUMsdUJBQW1CekIsYUFBbkI7QUFDQXlCLHVCQUFtQixLQUFLM0gsY0FBeEI7QUFDRDs7QUFFRDs7Ozs7QUFLQSxRQUFNK0ksY0FBTixDQUFxQnRILGFBQXJCLEVBQW9DO0FBQ2xDLFFBQUcsS0FBSzNCLHFCQUFMLENBQTJCMkIsYUFBM0IsQ0FBSCxFQUE4QztBQUM1QyxXQUFJLElBQUkrRCxVQUFSLElBQXNCLEtBQUtELG9DQUFMLENBQTBDOUQsYUFBMUMsQ0FBdEIsRUFBZ0Y7QUFDOUUsY0FBTXlFLGdCQUFnQixLQUFLcEcscUJBQUwsQ0FBMkIwRixVQUEzQixDQUF0QjtBQUNBLFlBQUcsQ0FBQyxLQUFLMUYscUJBQUwsQ0FBMkIyQixhQUEzQixFQUEwQ2hCLGlCQUEzQyxJQUNJLEtBQUtYLHFCQUFMLENBQTJCMkIsYUFBM0IsRUFBMENlLGtCQUExQyxJQUFnRTBELGNBQWMxRCxrQkFEckYsRUFDeUc7QUFDdkcsaUJBQU8sS0FBSzFDLHFCQUFMLENBQTJCMkIsYUFBM0IsQ0FBUDtBQUNBO0FBQ0Q7QUFDRCxZQUFHeUUsY0FBY2pGLFNBQWQsSUFBMkJpRixjQUFjekYsaUJBQTVDLEVBQStEO0FBQzdELGlCQUFPLEtBQUtYLHFCQUFMLENBQTJCMkIsYUFBM0IsQ0FBUDtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRURxRSwwQkFBd0JyRSxhQUF4QixFQUFzQztBQUNwQyxVQUFNZ0IsUUFBUSxLQUFLM0MscUJBQUwsQ0FBMkIyQixhQUEzQixDQUFkO0FBQ0EsUUFBR2dCLFNBQVNBLE1BQU1oQyxpQkFBbEIsRUFBcUM7QUFDbkNnQyxZQUFNRCxrQkFBTixHQUEyQmtELEtBQUtDLEdBQUwsRUFBM0I7QUFDRDtBQUNGOztBQUVESix1Q0FBcUM5RCxhQUFyQyxFQUFvRDtBQUNsRCxVQUFNRyxTQUFTSCxjQUFjSSxLQUFkLENBQW9CLEdBQXBCLEVBQXlCLENBQXpCLENBQWY7QUFDQSxVQUFNRyxpQkFBaUJQLGNBQWNJLEtBQWQsQ0FBb0IsR0FBcEIsRUFBeUIsQ0FBekIsQ0FBdkI7QUFDQSxXQUFPLG9CQUFZLEtBQUsvQixxQkFBakIsRUFDSm9DLE1BREksQ0FDR0Msc0JBQXNCQSxtQkFBbUJDLFVBQW5CLENBQStCLEdBQUVSLE1BQU8sSUFBR0ksY0FBZSxHQUExRCxLQUM5QlAsa0JBQWtCVSxrQkFGYixDQUFQO0FBR0Q7O0FBRUQ7QUFDQWlHLHlCQUF1QjFFLFFBQXZCLEVBQWlDVyxLQUFqQyxFQUF3QztBQUN0QyxRQUFJcEIsZ0JBQWdCLEtBQUtBLGFBQUwsQ0FBbUJTLFNBQVNVLE1BQTVCLENBQXBCO0FBQ0EsUUFBSW5CLGFBQUosRUFBbUI7QUFDakIsVUFBSStGLGFBQWFwQixLQUFLcUIsR0FBTCxDQUFTLEVBQVQsRUFBYWhHLGNBQWNpRyxNQUEzQixDQUFqQjtBQUNBLFVBQUl4RixTQUFTeUYsTUFBVCxLQUFvQmpKLFNBQXhCLEVBQW1DO0FBQ2pDd0QsaUJBQVN5RixNQUFULEdBQWtCdkIsS0FBS2dCLEtBQUwsQ0FBV2xGLFNBQVN5RixNQUFULEdBQWtCSCxVQUE3QixJQUEyQ0EsVUFBN0Q7QUFDRDtBQUNELFVBQUl0RixTQUFTeUUsZ0JBQVQsS0FBOEJqSSxTQUE5QixJQUEyQ3dELFNBQVMwRixjQUFULEtBQTRCbEosU0FBM0UsRUFBc0Y7QUFDcEZ3RCxpQkFBU3lFLGdCQUFULEdBQTRCLENBQUN6RSxTQUFTMkUsSUFBVCxLQUFrQixtQkFBbEIsR0FBd0MsQ0FBeEMsR0FBNEMsQ0FBQyxDQUE5QyxLQUN6QjNFLFNBQVN1RSxZQUFULEdBQXdCdkUsU0FBUzJGLFNBRFIsSUFDcUIzRixTQUFTNEYsZ0JBRDlCLEdBRTFCNUYsU0FBUzZGLE1BRmlCLEdBRVJ0RyxjQUFjdUcsUUFGbEM7QUFHQTlGLGlCQUFTeUUsZ0JBQVQsR0FBNEJQLEtBQUtnQixLQUFMLENBQVdsRixTQUFTeUUsZ0JBQVQsR0FBNEJhLFVBQXZDLElBQXFEQSxVQUFqRjtBQUNBdEYsaUJBQVMwRixjQUFULEdBQTBCMUYsU0FBU3lGLE1BQVQsR0FBa0J6RixTQUFTeUUsZ0JBQXJEO0FBQ0Q7QUFDRCxVQUFJc0IsbUJBQW1CL0YsU0FBUzJFLElBQVQsS0FBa0IsbUJBQWxCLEdBQXdDaEUsTUFBTWtFLEdBQTlDLEdBQW9EbEUsTUFBTWlFLEdBQWpGO0FBQ0EsVUFBSW9CLGVBQWUsQ0FBQ2hHLFNBQVMyRSxJQUFULEtBQWtCLG1CQUFsQixHQUF3QyxDQUF4QyxHQUE0QyxDQUFDLENBQTlDLEtBQW9Eb0IsbUJBQW1CL0YsU0FBUzJGLFNBQWhGLENBQW5CO0FBQ0EsVUFBSUMsbUJBQW9CSSxlQUFlLENBQWYsR0FBbUJyRixNQUFNc0YsZUFBekIsR0FBMkN0RixNQUFNdUYsYUFBekU7QUFDQSxVQUFJekIsbUJBQW1CLENBQUN6RSxTQUFTMkUsSUFBVCxLQUFrQixtQkFBbEIsR0FBd0MsQ0FBeEMsR0FBNEMsQ0FBQyxDQUE5QyxLQUNwQm9CLG1CQUFtQi9GLFNBQVMyRixTQURSLElBQ3FCQyxnQkFEckIsR0FFckI1RixTQUFTNkYsTUFGWSxHQUVIdEcsY0FBY3VHLFFBRmxDO0FBR0FyQix5QkFBbUJQLEtBQUtnQixLQUFMLENBQVdULG1CQUFtQmEsVUFBOUIsSUFBNENBLFVBQS9EO0FBQ0F0RixlQUFTeUUsZ0JBQVQsR0FBNEJBLGdCQUE1QjtBQUNBekUsZUFBU3lGLE1BQVQsR0FBa0J6RixTQUFTeUUsZ0JBQVQsR0FBNEJ6RSxTQUFTMEYsY0FBdkQ7QUFDQTFGLGVBQVN5RixNQUFULEdBQWtCdkIsS0FBS2dCLEtBQUwsQ0FBV2xGLFNBQVN5RixNQUFULEdBQWtCSCxVQUE3QixJQUEyQ0EsVUFBN0Q7QUFDQXRGLGVBQVN1RSxZQUFULEdBQXdCd0IsZ0JBQXhCO0FBQ0EvRixlQUFTNEYsZ0JBQVQsR0FBNEJBLGdCQUE1QjtBQUNEO0FBQ0Y7O0FBRUQzSCxZQUFVRixhQUFWLEVBQXlCO0FBQ3ZCLFFBQUksQ0FBQyxLQUFLM0IscUJBQUwsQ0FBMkIsS0FBSzJCLGFBQWhDLENBQUwsRUFBcUQ7QUFDbkQsV0FBS1gsT0FBTCxDQUFhOEUsS0FBYixDQUFvQixHQUFFLEtBQUtoRyxVQUFXLElBQUc2QixhQUFjLHlCQUF2RDtBQUNBLFdBQUszQixxQkFBTCxDQUEyQixLQUFLMkIsYUFBaEMsSUFBaUQsS0FBS29JLHVCQUFMLENBQTZCcEksYUFBN0IsQ0FBakQ7QUFDRDtBQUNELFdBQU8sS0FBSzNCLHFCQUFMLENBQTJCLEtBQUsyQixhQUFoQyxDQUFQO0FBQ0Q7O0FBRURvSSwwQkFBd0JwSSxhQUF4QixFQUF1QztBQUNyQyxXQUFPO0FBQ0xBLG1CQURLO0FBRUxSLGlCQUFXLEtBRk47QUFHTEkseUJBQW1CLEtBSGQ7QUFJTHBCLDBCQUFvQkMsU0FKZjtBQUtMQyxpQkFBVyxFQUxOO0FBTUxDLGNBQVEsRUFOSDtBQU9MQyw4QkFBd0IsRUFQbkI7QUFRTEMsc0JBQWdCLEVBUlg7QUFTTEMsdUJBQWlCLEVBVFo7QUFVTEMsd0JBQWtCLEVBVmI7QUFXTEMseUJBQW1CLEtBWGQ7QUFZTEMsNEJBQXNCLEtBWmpCO0FBYUxDLHNCQUFnQixDQWJYO0FBY0w2QiwwQkFBb0IsQ0FkZjtBQWVMbUIscUJBQWUsSUFmVjtBQWdCTEUsa0JBQVksSUFoQlA7QUFpQkxSLDBCQUFvQixJQWpCZjtBQWtCTHpDLHFCQUFlVixTQWxCVjtBQW1CTFcsMkJBQXFCWDtBQW5CaEIsS0FBUDtBQXFCRDs7QUFFRHFELFdBQVN1RyxHQUFULEVBQWN0SSxXQUFkLEVBQTJCdUksV0FBM0IsRUFBd0M7QUFDdEMsUUFBSUMsV0FBVyxFQUFmO0FBQ0EsUUFBR3hJLGdCQUFnQixVQUFuQixFQUErQjtBQUM3QixZQUFNeUksWUFBWSxDQUFDQyxXQUFELEVBQWNySCxHQUFkLEtBQXNCO0FBQ3RDLFlBQUcsT0FBT3FILFdBQVAsS0FBdUIsUUFBMUIsRUFBb0M7QUFDbEMsY0FBR0gsWUFBWUksUUFBWixDQUFxQnRILEdBQXJCLENBQUgsRUFBOEI7QUFDNUIsbUJBQU9xSCxXQUFQO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsbUJBQU9BLFlBQVlFLE9BQVosQ0FBb0IsQ0FBcEIsQ0FBUDtBQUNEO0FBQ0YsU0FORCxNQU1PLElBQUdDLE1BQU1DLE9BQU4sQ0FBY0osV0FBZCxDQUFILEVBQStCO0FBQ3BDLGlCQUFRLElBQUdBLFlBQVlwRyxHQUFaLENBQWdCeUcsUUFBUU4sVUFBVU0sSUFBVixDQUF4QixFQUF5Q0MsSUFBekMsQ0FBOEMsR0FBOUMsQ0FBbUQsR0FBOUQ7QUFDRCxTQUZNLE1BRUEsSUFBSU4sZ0JBQWdCLElBQXBCLEVBQTBCO0FBQy9CLGlCQUFPQSxXQUFQO0FBQ0QsU0FGTSxNQUVBLElBQUksT0FBT0EsV0FBUCxLQUF1QixRQUF2QixJQUFtQ0EsWUFBWXBDLE9BQW5ELEVBQTJEO0FBQ2hFLGlCQUFPLHlCQUFlb0MsV0FBZixDQUFQO0FBQ0Q7O0FBRUQsWUFBSU8sUUFBUSxvQkFDSlAsV0FESSxFQUVUcEcsR0FGUyxDQUVMNEcsV0FBWSxJQUFHQSxPQUFRLEtBQUlULFVBQVVDLFlBQVlRLE9BQVosQ0FBVixFQUFnQ0EsT0FBaEMsQ0FBeUMsRUFGL0QsRUFHVEYsSUFIUyxDQUdKLEdBSEksQ0FBWjtBQUlBLGVBQVEsSUFBR0MsS0FBTSxHQUFqQjtBQUNELE9BcEJEOztBQXNCQVQsaUJBQVdDLFVBQVVILEdBQVYsQ0FBWDtBQUNELEtBeEJELE1Bd0JPLElBQUd0SSxnQkFBZ0IsVUFBbkIsRUFBK0I7QUFDcEMsWUFBTXlJLFlBQVksQ0FBQ0MsV0FBRCxFQUFjckgsR0FBZCxLQUFzQjtBQUN0QyxZQUFHLE9BQU9xSCxXQUFQLEtBQXVCLFFBQTFCLEVBQW9DO0FBQ2xDLGNBQUdILFlBQVlJLFFBQVosQ0FBcUJ0SCxHQUFyQixDQUFILEVBQThCO0FBQzVCLG1CQUFPcUgsV0FBUDtBQUNELFdBRkQsTUFFTztBQUNMLG1CQUFPUyxXQUFXVCxZQUFZRSxPQUFaLENBQW9CLENBQXBCLENBQVgsQ0FBUDtBQUNEO0FBQ0YsU0FORCxNQU1PLElBQUdDLE1BQU1DLE9BQU4sQ0FBY0osV0FBZCxDQUFILEVBQStCO0FBQ3BDLGlCQUFRLElBQUdBLFlBQVlwRyxHQUFaLENBQWdCeUcsUUFBUU4sVUFBVU0sSUFBVixDQUF4QixFQUF5Q0MsSUFBekMsQ0FBOEMsR0FBOUMsQ0FBbUQsR0FBOUQ7QUFDRCxTQUZNLE1BRUEsSUFBSU4sZ0JBQWdCLElBQXBCLEVBQTBCO0FBQy9CLGlCQUFPQSxXQUFQO0FBQ0QsU0FGTSxNQUVBLElBQUksT0FBT0EsV0FBUCxLQUF1QixRQUF2QixJQUFtQ0EsWUFBWXBDLE9BQW5ELEVBQTJEO0FBQ2hFLGlCQUFPLHlCQUFlb0MsV0FBZixDQUFQO0FBQ0Q7O0FBRUQsWUFBSU8sUUFBUSxvQkFDSlAsV0FESSxFQUVUcEcsR0FGUyxDQUVMNEcsV0FBWSxJQUFHQSxPQUFRLEtBQUlULFVBQVVDLFlBQVlRLE9BQVosQ0FBVixFQUFnQ0EsT0FBaEMsQ0FBeUMsRUFGL0QsRUFHVEYsSUFIUyxDQUdKLEdBSEksQ0FBWjtBQUlBLGVBQVEsSUFBR0MsS0FBTSxHQUFqQjtBQUNELE9BcEJEOztBQXNCQVQsaUJBQVdDLFVBQVVILEdBQVYsQ0FBWDtBQUNEO0FBQ0QsV0FBT2MsbUJBQU9DLEdBQVAsQ0FBV2IsUUFBWCxFQUFxQmMsUUFBckIsRUFBUDtBQUNEOztBQXZ1QmdFO2tCQUE5Q3ZMLGEiLCJmaWxlIjoidGVybWluYWxTdGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8tanMnO1xuaW1wb3J0IFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIGZyb20gJy4uL2NsaWVudHMvbWV0YUFwaS9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcic7XG5pbXBvcnQgTG9nZ2VyTWFuYWdlciBmcm9tICcuLi9sb2dnZXInO1xuXG4vKipcbiAqIFJlc3BvbnNpYmxlIGZvciBzdG9yaW5nIGEgbG9jYWwgY29weSBvZiByZW1vdGUgdGVybWluYWwgc3RhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybWluYWxTdGF0ZSBleHRlbmRzIFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgaW5zdGFuY2Ugb2YgdGVybWluYWwgc3RhdGUgY2xhc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7Q2xpZW50QXBpQ2xpZW50fSBjbGllbnRBcGlDbGllbnQgY2xpZW50IGFwaSBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFjY291bnRJZCwgY2xpZW50QXBpQ2xpZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9hY2NvdW50SWQgPSBhY2NvdW50SWQ7XG4gICAgdGhpcy5fY2xpZW50QXBpQ2xpZW50ID0gY2xpZW50QXBpQ2xpZW50O1xuICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4ID0ge307XG4gICAgdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXMgPSB7fTtcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlID0ge1xuICAgICAgYWNjb3VudEluZm9ybWF0aW9uOiB1bmRlZmluZWQsXG4gICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgb3JkZXJzOiBbXSxcbiAgICAgIHNwZWNpZmljYXRpb25zQnlTeW1ib2w6IHt9LFxuICAgICAgcHJpY2VzQnlTeW1ib2w6IHt9LFxuICAgICAgY29tcGxldGVkT3JkZXJzOiB7fSxcbiAgICAgIHJlbW92ZWRQb3NpdGlvbnM6IHt9LFxuICAgICAgb3JkZXJzSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgcG9zaXRpb25zSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgbGFzdFVwZGF0ZVRpbWU6IDAsXG4gICAgICBsYXN0UXVvdGVUaW1lOiB1bmRlZmluZWQsXG4gICAgICBsYXN0UXVvdGVCcm9rZXJUaW1lOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlck1hbmFnZXIuZ2V0TG9nZ2VyKCdUZXJtaW5hbFN0YXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIE1ldGFBcGkgaGF2ZSBjb25uZWN0ZWQgdG8gTWV0YVRyYWRlciB0ZXJtaW5hbFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIE1ldGFBcGkgaGF2ZSBjb25uZWN0ZWQgdG8gTWV0YVRyYWRlciB0ZXJtaW5hbFxuICAgKi9cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkucmVkdWNlKChhY2MsIHMpID0+IGFjYyB8fCBzLmNvbm5lY3RlZCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBNZXRhQXBpIGhhdmUgY29ubmVjdGVkIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgYW5kIE1ldGFUcmFkZXIgdGVybWluYWwgaXMgY29ubmVjdGVkIHRvIGJyb2tlclxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIE1ldGFBcGkgaGF2ZSBjb25uZWN0ZWQgdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBhbmQgTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb25uZWN0ZWQgdG9cbiAgICogYnJva2VyXG4gICAqL1xuICBnZXQgY29ubmVjdGVkVG9Ccm9rZXIoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLnJlZHVjZSgoYWNjLCBzKSA9PiBhY2MgfHwgcy5jb25uZWN0ZWRUb0Jyb2tlciwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbCBjb3B5IG9mIGFjY291bnQgaW5mb3JtYXRpb25cbiAgICogQHJldHVybnMge01ldGF0cmFkZXJBY2NvdW50SW5mb3JtYXRpb259IGxvY2FsIGNvcHkgb2YgYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgZ2V0IGFjY291bnRJbmZvcm1hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tYmluZWRTdGF0ZS5hY2NvdW50SW5mb3JtYXRpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsIGNvcHkgb2YgTWV0YVRyYWRlciBwb3NpdGlvbnMgb3BlbmVkXG4gICAqIEByZXR1cm5zIHtBcnJheTxNZXRhdHJhZGVyUG9zaXRpb24+fSBhIGxvY2FsIGNvcHkgb2YgTWV0YVRyYWRlciBwb3NpdGlvbnMgb3BlbmVkXG4gICAqL1xuICBnZXQgcG9zaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWwgY29weSBvZiBNZXRhVHJhZGVyIG9yZGVycyBvcGVuZWRcbiAgICogQHJldHVybnMge0FycmF5PE1ldGF0cmFkZXJPcmRlcj59IGEgbG9jYWwgY29weSBvZiBNZXRhVHJhZGVyIG9yZGVycyBvcGVuZWRcbiAgICovXG4gIGdldCBvcmRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbWJpbmVkU3RhdGUub3JkZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbCBjb3B5IG9mIHN5bWJvbCBzcGVjaWZpY2F0aW9ucyBhdmFpbGFibGUgaW4gTWV0YVRyYWRlciB0cmFkaW5nIHRlcm1pbmFsXG4gICAqIEByZXR1cm5zIHtBcnJheTxNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbj59IGEgbG9jYWwgY29weSBvZiBzeW1ib2wgc3BlY2lmaWNhdGlvbnMgYXZhaWxhYmxlIGluIE1ldGFUcmFkZXJcbiAgICogdHJhZGluZyB0ZXJtaW5hbFxuICAgKi9cbiAgZ2V0IHNwZWNpZmljYXRpb25zKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoYXNoZXMgb2YgdGVybWluYWwgc3RhdGUgZGF0YSBmb3IgaW5jcmVtZW50YWwgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50VHlwZSBhY2NvdW50IHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgaW5zdGFuY2UgdG8gZ2V0IGhhc2hlcyBvZlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGhhc2hlcyBvZiB0ZXJtaW5hbCBzdGF0ZSBkYXRhXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBhc3luYyBnZXRIYXNoZXMoYWNjb3VudFR5cGUsIGluc3RhbmNlSW5kZXgpIHtcbiAgICBsZXQgcmVxdWVzdGVkU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICAvLyBnZXQgbGF0ZXN0IGluc3RhbmNlIG51bWJlciBzdGF0ZVxuICAgIGNvbnN0IHJlZ2lvbiA9IGluc3RhbmNlSW5kZXguc3BsaXQoJzonKVswXTtcbiAgICBjb25zdCBoYXNoRmllbGRzID0gYXdhaXQgdGhpcy5fY2xpZW50QXBpQ2xpZW50LmdldEhhc2hpbmdJZ25vcmVkRmllbGRMaXN0cyhyZWdpb24pO1xuICAgIGNvbnN0IGluc3RhbmNlTnVtYmVyID0gaW5zdGFuY2VJbmRleC5zcGxpdCgnOicpWzFdO1xuICAgIGNvbnN0IGluc3RhbmNlTnVtYmVyU3RhdGVzID0gT2JqZWN0LmtleXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpXG4gICAgICAuZmlsdGVyKHN0YXRlSW5zdGFuY2VJbmRleCA9PiBzdGF0ZUluc3RhbmNlSW5kZXguc3RhcnRzV2l0aChgJHtyZWdpb259OiR7aW5zdGFuY2VOdW1iZXJ9OmApKTtcbiAgICBpbnN0YW5jZU51bWJlclN0YXRlcy5zb3J0KChhLGIpID0+IGIubGFzdFN5bmNVcGRhdGVUaW1lIC0gYS5sYXN0U3luY1VwZGF0ZVRpbWUpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VOdW1iZXJTdGF0ZXNbMF0pO1xuXG4gICAgY29uc3Qgc29ydEJ5S2V5ID0gKG9iajEsIG9iajIsIGtleSkgPT4ge1xuICAgICAgaWYob2JqMVtrZXldIDwgb2JqMltrZXldKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmKG9iajFba2V5XSA+IG9iajJba2V5XSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgY29uc3Qgc3BlY2lmaWNhdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KE9iamVjdC52YWx1ZXMoc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCkpKTtcbiAgICBzcGVjaWZpY2F0aW9ucy5zb3J0KChhLGIpID0+IHNvcnRCeUtleShhLCBiLCAnc3ltYm9sJykpO1xuICAgIHNwZWNpZmljYXRpb25zLmZvckVhY2goc3BlY2lmaWNhdGlvbiA9PiB7XG4gICAgICBpZihhY2NvdW50VHlwZSA9PT0gJ2Nsb3VkLWcxJykge1xuICAgICAgICBoYXNoRmllbGRzLmcxLnNwZWNpZmljYXRpb24uZm9yRWFjaChmaWVsZCA9PiBkZWxldGUgc3BlY2lmaWNhdGlvbltmaWVsZF0pO1xuICAgICAgfSBlbHNlIGlmKGFjY291bnRUeXBlID09PSAnY2xvdWQtZzInKSB7XG4gICAgICAgIGhhc2hGaWVsZHMuZzIuc3BlY2lmaWNhdGlvbi5mb3JFYWNoKGZpZWxkID0+IGRlbGV0ZSBzcGVjaWZpY2F0aW9uW2ZpZWxkXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3BlY2lmaWNhdGlvbnNIYXNoID0gc3BlY2lmaWNhdGlvbnMubGVuZ3RoID8gXG4gICAgICBzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggfHwgdGhpcy5fZ2V0SGFzaChzcGVjaWZpY2F0aW9ucywgYWNjb3VudFR5cGUsIFsnZGlnaXRzJ10pIDogbnVsbDtcbiAgICBzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggPSBzcGVjaWZpY2F0aW9uc0hhc2g7XG5cbiAgICBjb25zdCBwb3NpdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHN0YXRlLnBvc2l0aW9ucykpO1xuICAgIGlmKGFjY291bnRUeXBlID09PSAnY2xvdWQtZzEnKSB7XG4gICAgICBwb3NpdGlvbnMuc29ydCgoYSxiKSA9PiBOdW1iZXIoYS5pZCkgLSBOdW1iZXIoYi5pZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbnMuc29ydCgoYSxiKSA9PiBzb3J0QnlLZXkoYSwgYiwgJ2lkJykpO1xuICAgIH1cbiAgICBwb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiB7XG4gICAgICBpZihhY2NvdW50VHlwZSA9PT0gJ2Nsb3VkLWcxJykge1xuICAgICAgICBoYXNoRmllbGRzLmcxLnBvc2l0aW9uLmZvckVhY2goZmllbGQgPT4gZGVsZXRlIHBvc2l0aW9uW2ZpZWxkXSk7XG4gICAgICB9IGVsc2UgaWYoYWNjb3VudFR5cGUgPT09ICdjbG91ZC1nMicpIHtcbiAgICAgICAgaGFzaEZpZWxkcy5nMi5wb3NpdGlvbi5mb3JFYWNoKGZpZWxkID0+IGRlbGV0ZSBwb3NpdGlvbltmaWVsZF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHBvc2l0aW9uc0hhc2ggPSBzdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCA/IFxuICAgICAgc3RhdGUucG9zaXRpb25zSGFzaCB8fCB0aGlzLl9nZXRIYXNoKHBvc2l0aW9ucywgYWNjb3VudFR5cGUsIFsnbWFnaWMnXSkgOiBudWxsO1xuICAgIHN0YXRlLnBvc2l0aW9uc0hhc2ggPSBwb3NpdGlvbnNIYXNoO1xuXG4gICAgY29uc3Qgb3JkZXJzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGF0ZS5vcmRlcnMpKTtcbiAgICBpZihhY2NvdW50VHlwZSA9PT0gJ2Nsb3VkLWcxJykge1xuICAgICAgb3JkZXJzLnNvcnQoKGEsYikgPT4gTnVtYmVyKGEuaWQpIC0gTnVtYmVyKGIuaWQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJzLnNvcnQoKGEsYikgPT4gc29ydEJ5S2V5KGEsIGIsICdpZCcpKTtcbiAgICB9XG4gICAgb3JkZXJzLmZvckVhY2gob3JkZXIgPT4ge1xuICAgICAgaWYoYWNjb3VudFR5cGUgPT09ICdjbG91ZC1nMScpIHtcbiAgICAgICAgaGFzaEZpZWxkcy5nMS5vcmRlci5mb3JFYWNoKGZpZWxkID0+IGRlbGV0ZSBvcmRlcltmaWVsZF0pO1xuICAgICAgfSBlbHNlIGlmKGFjY291bnRUeXBlID09PSAnY2xvdWQtZzInKSB7XG4gICAgICAgIGhhc2hGaWVsZHMuZzIub3JkZXIuZm9yRWFjaChmaWVsZCA9PiBkZWxldGUgb3JkZXJbZmllbGRdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvcmRlcnNIYXNoID0gc3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQgPyBcbiAgICAgIHN0YXRlLm9yZGVyc0hhc2ggfHwgdGhpcy5fZ2V0SGFzaChvcmRlcnMsIGFjY291bnRUeXBlLCBbJ21hZ2ljJ10pIDogbnVsbDtcbiAgICBzdGF0ZS5vcmRlcnNIYXNoID0gb3JkZXJzSGFzaDtcblxuICAgIGlmIChyZXF1ZXN0ZWRTdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIHJlcXVlc3RlZFN0YXRlLnNwZWNpZmljYXRpb25zQnlTeW1ib2wgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sIHx8IHt9KTtcbiAgICAgIHJlcXVlc3RlZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IHNwZWNpZmljYXRpb25zSGFzaDtcbiAgICAgIHJlcXVlc3RlZFN0YXRlLnBvc2l0aW9ucyA9IChzdGF0ZS5wb3NpdGlvbnMgfHwgW10pLm1hcChwID0+IE9iamVjdC5hc3NpZ24oe30sIHApKTtcbiAgICAgIHJlcXVlc3RlZFN0YXRlLnBvc2l0aW9uc0hhc2ggPSBwb3NpdGlvbnNIYXNoO1xuICAgICAgcmVxdWVzdGVkU3RhdGUub3JkZXJzID0gKHN0YXRlLm9yZGVycyB8fCBbXSkubWFwKG8gPT4gT2JqZWN0LmFzc2lnbih7fSwgbykpO1xuICAgICAgcmVxdWVzdGVkU3RhdGUub3JkZXJzSGFzaCA9IG9yZGVyc0hhc2g7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNwZWNpZmljYXRpb25zTWQ1OiBzcGVjaWZpY2F0aW9uc0hhc2gsXG4gICAgICBwb3NpdGlvbnNNZDU6IHBvc2l0aW9uc0hhc2gsXG4gICAgICBvcmRlcnNNZDU6IG9yZGVyc0hhc2hcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YVRyYWRlciBzeW1ib2wgc3BlY2lmaWNhdGlvbiBieSBzeW1ib2xcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHJldHVybiB7TWV0YXRyYWRlclN5bWJvbFNwZWNpZmljYXRpb259IE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uIGZvdW5kIG9yIHVuZGVmaW5lZCBpZiBzcGVjaWZpY2F0aW9uIGZvciBhXG4gICAqIHN5bWJvbCBpcyBub3QgZm91bmRcbiAgICovXG4gIHNwZWNpZmljYXRpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbFtzeW1ib2xdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YVRyYWRlciBzeW1ib2wgcHJpY2UgYnkgc3ltYm9sXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJTeW1ib2xQcmljZX0gTWV0YXRyYWRlclN5bWJvbFByaWNlIGZvdW5kIG9yIHVuZGVmaW5lZCBpZiBwcmljZSBmb3IgYSBzeW1ib2wgaXMgbm90IGZvdW5kXG4gICAqL1xuICBwcmljZShzeW1ib2wpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tYmluZWRTdGF0ZS5wcmljZXNCeVN5bWJvbFtzeW1ib2xdO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1b3RlIHRpbWVcbiAgICogQHR5cGRlZiB7T2JqZWN0fSBRdW90ZVRpbWVcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIHF1b3RlIHRpbWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlclRpbWUgcXVvdGUgdGltZSBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyB0aW1lIG9mIHRoZSBsYXN0IHJlY2VpdmVkIHF1b3RlXG4gICAqIEByZXR1cm4ge1F1b3RlVGltZX0gdGltZSBvZiB0aGUgbGFzdCByZWNlaXZlZCBxdW90ZVxuICAgKi9cbiAgZ2V0IGxhc3RRdW90ZVRpbWUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbWJpbmVkU3RhdGUubGFzdFF1b3RlVGltZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGltZTogdGhpcy5fY29tYmluZWRTdGF0ZS5sYXN0UXVvdGVUaW1lLFxuICAgICAgICBicm9rZXJUaW1lOiB0aGlzLl9jb21iaW5lZFN0YXRlLmxhc3RRdW90ZUJyb2tlclRpbWUsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgcHJpY2UgdG8gYmUgcmVjZWl2ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgMzBcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyU3ltYm9sUHJpY2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHByaWNlIG9yIHVuZGVmaW5lZCBpZiBwcmljZSBoYXMgbm90IGJlZW4gcmVjZWl2ZWRcbiAgICovXG4gIGFzeW5jIHdhaXRGb3JQcmljZShzeW1ib2wsIHRpbWVvdXRJblNlY29uZHMgPSAzMCkge1xuICAgIHRoaXMuX3dhaXRGb3JQcmljZVJlc29sdmVzW3N5bWJvbF0gPSB0aGlzLl93YWl0Rm9yUHJpY2VSZXNvbHZlc1tzeW1ib2xdIHx8IFtdO1xuICAgIGlmICghdGhpcy5wcmljZShzeW1ib2wpKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICBuZXcgUHJvbWlzZShyZXMgPT4gdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXNbc3ltYm9sXS5wdXNoKHJlcykpLFxuICAgICAgICBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSlcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmljZShzeW1ib2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgZXN0YWJsaXNoZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICovXG4gIG9uQ29ubmVjdGVkKGluc3RhbmNlSW5kZXgpIHtcbiAgICB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KS5jb25uZWN0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgdGVybWluYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKi9cbiAgb25EaXNjb25uZWN0ZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHN0YXRlLmNvbm5lY3RlZFRvQnJva2VyID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGJyb2tlciBjb25uZWN0aW9uIHN0YXR1cyBoYXZlIGNoYW5nZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBjb25uZWN0ZWQgaXMgTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb25uZWN0ZWQgdG8gYnJva2VyXG4gICAqL1xuICBvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkKGluc3RhbmNlSW5kZXgsIGNvbm5lY3RlZCkge1xuICAgIHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpLmNvbm5lY3RlZFRvQnJva2VyID0gY29ubmVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvbiBpcyBzdGFydGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3BlY2lmaWNhdGlvbnNVcGRhdGVkIHdoZXRoZXIgc3BlY2lmaWNhdGlvbnMgYXJlIGdvaW5nIHRvIGJlIHVwZGF0ZWQgZHVyaW5nIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBvc2l0aW9uc1VwZGF0ZWQgd2hldGhlciBwb3NpdGlvbnMgYXJlIGdvaW5nIHRvIGJlIHVwZGF0ZWQgZHVyaW5nIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9yZGVyc1VwZGF0ZWQgd2hldGhlciBvcmRlcnMgYXJlIGdvaW5nIHRvIGJlIHVwZGF0ZWQgZHVyaW5nIHN5bmNocm9uaXphdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIG9uU3luY2hyb25pemF0aW9uU3RhcnRlZChpbnN0YW5jZUluZGV4LCBzcGVjaWZpY2F0aW9uc1VwZGF0ZWQsIHBvc2l0aW9uc1VwZGF0ZWQsIG9yZGVyc1VwZGF0ZWQsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgY29uc3QgdW5zeW5jaHJvbml6ZWRTdGF0ZXMgPSB0aGlzLl9nZXRTdGF0ZUluZGljZXNPZlNhbWVJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KVxuICAgICAgLmZpbHRlcihzdGF0ZUluZGV4ID0+ICF0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtzdGF0ZUluZGV4XS5vcmRlcnNJbml0aWFsaXplZCk7XG4gICAgdW5zeW5jaHJvbml6ZWRTdGF0ZXMuc29ydCgoYSxiKSA9PiBiLmxhc3RTeW5jVXBkYXRlVGltZSAtIGEubGFzdFN5bmNVcGRhdGVUaW1lKTtcbiAgICB1bnN5bmNocm9uaXplZFN0YXRlcy5zbGljZSgxKS5mb3JFYWNoKHN0YXRlSW5kZXggPT4gZGVsZXRlIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W3N0YXRlSW5kZXhdKTtcblxuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmxhc3RTeW5jVXBkYXRlVGltZSA9IERhdGUubm93KCk7XG4gICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLnByaWNlc0J5U3ltYm9sID0ge307XG4gICAgaWYocG9zaXRpb25zVXBkYXRlZCkge1xuICAgICAgc3RhdGUucG9zaXRpb25zID0gW107XG4gICAgICBzdGF0ZS5yZW1vdmVkUG9zaXRpb25zID0ge307XG4gICAgICBzdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgc3RhdGUucG9zaXRpb25zSGFzaCA9IG51bGw7XG4gICAgfVxuICAgIGlmKG9yZGVyc1VwZGF0ZWQpIHtcbiAgICAgIHN0YXRlLm9yZGVycyA9IFtdO1xuICAgICAgc3RhdGUuY29tcGxldGVkT3JkZXJzID0ge307XG4gICAgICBzdGF0ZS5vcmRlcnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgc3RhdGUub3JkZXJzSGFzaCA9IG51bGw7XG4gICAgfVxuICAgIGlmKHNwZWNpZmljYXRpb25zVXBkYXRlZCkge1xuICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKCgpID0+IGAke3RoaXMuX2FjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fToke3N5bmNocm9uaXphdGlvbklkfTogY2xlYXJlZCBzcGVjaWZpY2F0aW9ucyBgICtcbiAgICAgICAgJ29uIHN5bmNocm9uaXphdGlvbiBzdGFydCcpO1xuICAgICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCA9IHt9O1xuICAgICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKCgpID0+IGAke3RoaXMuX2FjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fToke3N5bmNocm9uaXphdGlvbklkfTogbm8gbmVlZCB0byBjbGVhciBgICtcbiAgICAgICAgYHNwZWNpZmljYXRpb25zIG9uIHN5bmNocm9uaXphdGlvbiBzdGFydCwgJHtPYmplY3Qua2V5cyhzdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sIHx8IHt9KS5sZW5ndGh9IGAgK1xuICAgICAgICAnc3BlY2lmaWNhdGlvbnMgcmV1c2VkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIGFjY291bnQgaW5mb3JtYXRpb24gaXMgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50SW5mb3JtYXRpb259IGFjY291bnRJbmZvcm1hdGlvbiB1cGRhdGVkIE1ldGFUcmFkZXIgYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIGFjY291bnRJbmZvcm1hdGlvbikge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID0gYWNjb3VudEluZm9ybWF0aW9uO1xuICAgIGlmIChhY2NvdW50SW5mb3JtYXRpb24pIHtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudEluZm9ybWF0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBwb3NpdGlvbnMgYXJlIHJlcGxhY2VkIGFzIGEgcmVzdWx0IG9mIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8TWV0YXRyYWRlclBvc2l0aW9uPn0gcG9zaXRpb25zIHVwZGF0ZWQgYXJyYXkgb2YgcG9zaXRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25Qb3NpdGlvbnNSZXBsYWNlZChpbnN0YW5jZUluZGV4LCBwb3NpdGlvbnMpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICBzdGF0ZS5wb3NpdGlvbnNIYXNoID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gcG9zaXRpb24gc3luY2hyb25pemF0aW9uIGZuaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW4gaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5yZW1vdmVkUG9zaXRpb25zID0ge307XG4gICAgc3RhdGUucG9zaXRpb25zSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHBvc2l0aW9uIGlzIHVwZGF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyUG9zaXRpb259IHBvc2l0aW9uIHVwZGF0ZWQgTWV0YVRyYWRlciBwb3NpdGlvblxuICAgKi9cbiAgb25Qb3NpdGlvblVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgcG9zaXRpb24pIHtcbiAgICBsZXQgaW5zdGFuY2VTdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgaW5zdGFuY2VTdGF0ZS5wb3NpdGlvbnNIYXNoID0gbnVsbDtcblxuICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9uID0gKHN0YXRlKSA9PiB7XG4gICAgICBsZXQgaW5kZXggPSBzdGF0ZS5wb3NpdGlvbnMuZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gcG9zaXRpb24uaWQpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb247XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZW1vdmVkUG9zaXRpb25zW3Bvc2l0aW9uLmlkXSkge1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGVQb3NpdGlvbihpbnN0YW5jZVN0YXRlKTtcbiAgICB1cGRhdGVQb3NpdGlvbih0aGlzLl9jb21iaW5lZFN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gTWV0YVRyYWRlciBwb3NpdGlvbiBpcyByZW1vdmVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHJlbW92ZWQgTWV0YVRyYWRlciBwb3NpdGlvbiBpZFxuICAgKi9cbiAgb25Qb3NpdGlvblJlbW92ZWQoaW5zdGFuY2VJbmRleCwgcG9zaXRpb25JZCkge1xuICAgIGxldCBpbnN0YW5jZVN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgdGhpcy5fcmVmcmVzaFN0YXRlVXBkYXRlVGltZShpbnN0YW5jZUluZGV4KTtcbiAgICBpbnN0YW5jZVN0YXRlLnBvc2l0aW9uc0hhc2ggPSBudWxsO1xuXG4gICAgY29uc3QgcmVtb3ZlUG9zaXRpb24gPSAoc3RhdGUpID0+IHtcbiAgICAgIGxldCBwb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9ucy5maW5kKHAgPT4gcC5pZCA9PT0gcG9zaXRpb25JZCk7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgT2JqZWN0LmVudHJpZXMoc3RhdGUucmVtb3ZlZFBvc2l0aW9ucykpIHtcbiAgICAgICAgICBpZiAoZVsxXSArIDUgKiA2MCAqIDEwMDAgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUucmVtb3ZlZFBvc2l0aW9uc1tlWzBdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucmVtb3ZlZFBvc2l0aW9uc1twb3NpdGlvbklkXSA9IERhdGUubm93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbnMgPSBzdGF0ZS5wb3NpdGlvbnMuZmlsdGVyKHAgPT4gcC5pZCAhPT0gcG9zaXRpb25JZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZW1vdmVQb3NpdGlvbihpbnN0YW5jZVN0YXRlKTtcbiAgICByZW1vdmVQb3NpdGlvbih0aGlzLl9jb21iaW5lZFN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIG9yZGVycyBhcmUgcmVwbGFjZWQgYXMgYSByZXN1bHQgb2YgaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtBcnJheTxNZXRhdHJhZGVyT3JkZXI+fSBvcmRlcnMgdXBkYXRlZCBhcnJheSBvZiBwZW5kaW5nIG9yZGVyc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIG9uUGVuZGluZ09yZGVyc1JlcGxhY2VkKGluc3RhbmNlSW5kZXgsIG9yZGVycykge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUub3JkZXJzSGFzaCA9IG51bGw7XG4gICAgc3RhdGUub3JkZXJzID0gb3JkZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwZW5kaW5nIG9yZGVyIHN5bmNocm9uaXphdGlvbiBmbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuIGluaXRpYWwgdGVybWluYWwgc3RhdGVcbiAgICogc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmNvbXBsZXRlZE9yZGVycyA9IHt9O1xuICAgIHN0YXRlLnBvc2l0aW9uc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5vcmRlcnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5fY29tYmluZWRTdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24gPSBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24gPyBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24pIDpcbiAgICAgIHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9ucyA9IChzdGF0ZS5wb3NpdGlvbnMgfHwgW10pLm1hcChwID0+IE9iamVjdC5hc3NpZ24oe30sIHApKTtcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVycyA9IChzdGF0ZS5vcmRlcnMgfHwgW10pLm1hcChvID0+IE9iamVjdC5hc3NpZ24oe30sIG8pKTtcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zQnlTeW1ib2wgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sKTtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoKCkgPT4gYCR7dGhpcy5fYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiR7c3luY2hyb25pemF0aW9uSWR9OiBhc3NpZ25lZCBzcGVjaWZpY2F0aW9ucyB0byBgICtcbiAgICAgICdjb21iaW5lZCBzdGF0ZSBmcm9tICcgK1xuICAgICAgYCR7aW5zdGFuY2VJbmRleH0sICR7T2JqZWN0LmtleXMoc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCB8fCB7fSkubGVuZ3RofSBzcGVjaWZpY2F0aW9ucyBhc3NpZ25lZGApO1xuICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUucG9zaXRpb25zSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuY29tcGxldGVkT3JkZXJzID0ge307XG4gICAgdGhpcy5fY29tYmluZWRTdGF0ZS5yZW1vdmVkUG9zaXRpb25zID0ge307XG4gICAgZm9yKGxldCBzdGF0ZUluZGV4IG9mIHRoaXMuX2dldFN0YXRlSW5kaWNlc09mU2FtZUluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpKSB7XG4gICAgICBpZiAoIXRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W3N0YXRlSW5kZXhdLmNvbm5lY3RlZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbc3RhdGVJbmRleF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXIgaXMgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJPcmRlcn0gb3JkZXIgdXBkYXRlZCBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBvblBlbmRpbmdPcmRlclVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgb3JkZXIpIHtcbiAgICBsZXQgaW5zdGFuY2VTdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgaW5zdGFuY2VTdGF0ZS5vcmRlcnNIYXNoID0gbnVsbDtcbiAgICBcbiAgICBjb25zdCB1cGRhdGVQZW5kaW5nT3JkZXIgPSAoc3RhdGUpID0+IHtcbiAgICAgIGxldCBpbmRleCA9IHN0YXRlLm9yZGVycy5maW5kSW5kZXgobyA9PiBvLmlkID09PSBvcmRlci5pZCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHN0YXRlLm9yZGVyc1tpbmRleF0gPSBvcmRlcjtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLmNvbXBsZXRlZE9yZGVyc1tvcmRlci5pZF0pIHtcbiAgICAgICAgc3RhdGUub3JkZXJzLnB1c2gob3JkZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlUGVuZGluZ09yZGVyKGluc3RhbmNlU3RhdGUpO1xuICAgIHVwZGF0ZVBlbmRpbmdPcmRlcih0aGlzLl9jb21iaW5lZFN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gTWV0YVRyYWRlciBwZW5kaW5nIG9yZGVyIGlzIGNvbXBsZXRlZCAoZXhlY3V0ZWQgb3IgY2FuY2VsZWQpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlcklkIGNvbXBsZXRlZCBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXIgaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBvblBlbmRpbmdPcmRlckNvbXBsZXRlZChpbnN0YW5jZUluZGV4LCBvcmRlcklkKSB7XG4gICAgbGV0IGluc3RhbmNlU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIGluc3RhbmNlU3RhdGUub3JkZXJzSGFzaCA9IG51bGw7XG5cbiAgICBjb25zdCBjb21wbGV0ZU9yZGVyID0gKHN0YXRlKSA9PiB7XG4gICAgICBsZXQgb3JkZXIgPSBzdGF0ZS5vcmRlcnMuZmluZChvID0+IG8uaWQgPT09IG9yZGVySWQpO1xuICAgICAgaWYgKCFvcmRlcikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIE9iamVjdC5lbnRyaWVzKHN0YXRlLmNvbXBsZXRlZE9yZGVycykpIHtcbiAgICAgICAgICBpZiAoZVsxXSArIDUgKiA2MCAqIDEwMDAgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuY29tcGxldGVkT3JkZXJzW2VbMF1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5jb21wbGV0ZWRPcmRlcnNbb3JkZXJJZF0gPSBEYXRlLm5vdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUub3JkZXJzID0gc3RhdGUub3JkZXJzLmZpbHRlcihvID0+IG8uaWQgIT09IG9yZGVySWQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29tcGxldGVPcmRlcihpbnN0YW5jZVN0YXRlKTtcbiAgICBjb21wbGV0ZU9yZGVyKHRoaXMuX2NvbWJpbmVkU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN5bWJvbCBzcGVjaWZpY2F0aW9uIHdhcyB1cGRhdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8TWV0YXRyYWRlclN5bWJvbFNwZWNpZmljYXRpb24+fSBzcGVjaWZpY2F0aW9ucyB1cGRhdGVkIHNwZWNpZmljYXRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gcmVtb3ZlZFN5bWJvbHMgcmVtb3ZlZCBzeW1ib2xzXG4gICAqL1xuICBvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZChpbnN0YW5jZUluZGV4LCBzcGVjaWZpY2F0aW9ucywgcmVtb3ZlZFN5bWJvbHMpIHtcbiAgICBsZXQgaW5zdGFuY2VTdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgaW5zdGFuY2VTdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggPSBudWxsO1xuXG4gICAgY29uc3QgdXBkYXRlU3BlY2lmaWNhdGlvbnMgPSAoc3RhdGUpID0+IHtcbiAgICAgIGZvciAobGV0IHNwZWNpZmljYXRpb24gb2Ygc3BlY2lmaWNhdGlvbnMpIHtcbiAgICAgICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbFtzcGVjaWZpY2F0aW9uLnN5bWJvbF0gPSBzcGVjaWZpY2F0aW9uO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgc3ltYm9sIG9mIHJlbW92ZWRTeW1ib2xzKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sW3N5bWJvbF07XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGVTcGVjaWZpY2F0aW9ucyhpbnN0YW5jZVN0YXRlKTtcbiAgICB1cGRhdGVTcGVjaWZpY2F0aW9ucyh0aGlzLl9jb21iaW5lZFN0YXRlKTtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoKCkgPT4gYCR7dGhpcy5fYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiB1cGRhdGVkICR7c3BlY2lmaWNhdGlvbnMubGVuZ3RofSBzcGVjaWZpY2F0aW9ucywgYCArXG4gICAgICBgcmVtb3ZlZCAke3JlbW92ZWRTeW1ib2xzLmxlbmd0aH0gc3BlY2lmaWNhdGlvbnMuIFRoZXJlIGFyZSBgICtcbiAgICAgIGAke09iamVjdC5rZXlzKGluc3RhbmNlU3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCB8fCB7fSkubGVuZ3RofSBzcGVjaWZpY2F0aW9ucyBhZnRlciB1cGRhdGVgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gcHJpY2VzIGZvciBzZXZlcmFsIHN5bWJvbHMgd2VyZSB1cGRhdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8TWV0YXRyYWRlclN5bWJvbFByaWNlPn0gcHJpY2VzIHVwZGF0ZWQgTWV0YVRyYWRlciBzeW1ib2wgcHJpY2VzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlcXVpdHkgYWNjb3VudCBsaXF1aWRhdGlvbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWFyZ2luIG1hcmdpbiB1c2VkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmVlTWFyZ2luIGZyZWUgbWFyZ2luXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXJnaW5MZXZlbCBtYXJnaW4gbGV2ZWwgY2FsY3VsYXRlZCBhcyAlIG9mIGVxdWl0eS9tYXJnaW5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIG9uU3ltYm9sUHJpY2VzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBwcmljZXMsIGVxdWl0eSwgbWFyZ2luLCBmcmVlTWFyZ2luLCBtYXJnaW5MZXZlbCkge1xuICAgIGxldCBpbnN0YW5jZVN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgdGhpcy5fcmVmcmVzaFN0YXRlVXBkYXRlVGltZShpbnN0YW5jZUluZGV4KTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LG1heC1zdGF0ZW1lbnRzXG4gICAgY29uc3QgdXBkYXRlU3ltYm9sUHJpY2VzID0gKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5sYXN0VXBkYXRlVGltZSA9IE1hdGgubWF4KHByaWNlcy5tYXAocCA9PiBwLnRpbWUuZ2V0VGltZSgpKSk7XG4gICAgICBsZXQgcHJpY2VzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBwcmljZVVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IHByaWNlIG9mIHByaWNlcyB8fCBbXSkge1xuICAgICAgICBsZXQgY3VycmVudFByaWNlID0gc3RhdGUucHJpY2VzQnlTeW1ib2xbcHJpY2Uuc3ltYm9sXTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmljZSAmJiBjdXJyZW50UHJpY2UudGltZS5nZXRUaW1lKCkgPiBwcmljZS50aW1lLmdldFRpbWUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaWNlVXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0ZS5sYXN0UXVvdGVUaW1lIHx8IHN0YXRlLmxhc3RRdW90ZVRpbWUuZ2V0VGltZSgpIDwgcHJpY2UudGltZS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICBzdGF0ZS5sYXN0UXVvdGVUaW1lID0gcHJpY2UudGltZTtcbiAgICAgICAgICBzdGF0ZS5sYXN0UXVvdGVCcm9rZXJUaW1lID0gcHJpY2UuYnJva2VyVGltZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wcmljZXNCeVN5bWJvbFtwcmljZS5zeW1ib2xdID0gcHJpY2U7XG4gICAgICAgIGxldCBwb3NpdGlvbnMgPSBzdGF0ZS5wb3NpdGlvbnMuZmlsdGVyKHAgPT4gcC5zeW1ib2wgPT09IHByaWNlLnN5bWJvbCk7XG4gICAgICAgIGxldCBvdGhlclBvc2l0aW9ucyA9IHN0YXRlLnBvc2l0aW9ucy5maWx0ZXIocCA9PiBwLnN5bWJvbCAhPT0gcHJpY2Uuc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IHN0YXRlLm9yZGVycy5maWx0ZXIobyA9PiBvLnN5bWJvbCA9PT0gcHJpY2Uuc3ltYm9sKTtcbiAgICAgICAgcHJpY2VzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBwb3NpdGlvbiBvZiBvdGhlclBvc2l0aW9ucykge1xuICAgICAgICAgIGxldCBwID0gc3RhdGUucHJpY2VzQnlTeW1ib2xbcG9zaXRpb24uc3ltYm9sXTtcbiAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvblByb2ZpdHMocG9zaXRpb24sIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmljZXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwb3NpdGlvbiBvZiBwb3NpdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvblByb2ZpdHMocG9zaXRpb24sIHByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvcmRlciBvZiBvcmRlcnMpIHtcbiAgICAgICAgICBvcmRlci5jdXJyZW50UHJpY2UgPSBvcmRlci50eXBlID09PSAnT1JERVJfVFlQRV9CVVknIHx8IG9yZGVyLnR5cGUgPT09ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcgfHxcbiAgICAgICAgICBvcmRlci50eXBlID09PSAnT1JERVJfVFlQRV9CVVlfU1RPUCcgfHwgb3JkZXIudHlwZSA9PT0gJ09SREVSX1RZUEVfQlVZX1NUT1BfTElNSVQnID8gcHJpY2UuYXNrIDogcHJpY2UuYmlkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmljZVJlc29sdmVzID0gdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXNbcHJpY2Uuc3ltYm9sXSB8fCBbXTtcbiAgICAgICAgaWYgKHByaWNlUmVzb2x2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChsZXQgcmVzb2x2ZSBvZiBwcmljZVJlc29sdmVzKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl93YWl0Rm9yUHJpY2VSZXNvbHZlc1twcmljZS5zeW1ib2xdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJpY2VVcGRhdGVkICYmIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbikge1xuICAgICAgICBpZiAoc3RhdGUucG9zaXRpb25zSW5pdGlhbGl6ZWQgJiYgcHJpY2VzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLnBsYXRmb3JtID09PSAnbXQ1Jykge1xuICAgICAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eSA9IGVxdWl0eSAhPT0gdW5kZWZpbmVkID8gZXF1aXR5IDogc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmJhbGFuY2UgK1xuICAgICAgICAgICAgICBzdGF0ZS5wb3NpdGlvbnMucmVkdWNlKChhY2MsIHApID0+IGFjYyArXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgocC51bnJlYWxpemVkUHJvZml0IHx8IDApICogMTAwKSAvIDEwMCArIE1hdGgucm91bmQoKHAuc3dhcCB8fCAwKSAqIDEwMCkgLyAxMDAsIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZXF1aXR5ID0gZXF1aXR5ICE9PSB1bmRlZmluZWQgPyBlcXVpdHkgOiBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uYmFsYW5jZSArXG4gICAgICAgICAgICBzdGF0ZS5wb3NpdGlvbnMucmVkdWNlKChhY2MsIHApID0+IGFjYyArIE1hdGgucm91bmQoKHAuc3dhcCB8fCAwKSAqIDEwMCkgLyAxMDAgK1xuICAgICAgICAgICAgICBNYXRoLnJvdW5kKChwLmNvbW1pc3Npb24gfHwgMCkgKiAxMDApIC8gMTAwICsgTWF0aC5yb3VuZCgocC51bnJlYWxpemVkUHJvZml0IHx8IDApICogMTAwKSAvIDEwMCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5lcXVpdHkgPSBNYXRoLnJvdW5kKHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5lcXVpdHkgKiAxMDApIC8gMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5lcXVpdHkgPSBlcXVpdHkgIT09IHVuZGVmaW5lZCA/IGVxdWl0eSA6IHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5lcXVpdHk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLm1hcmdpbiA9IG1hcmdpbiAhPT0gdW5kZWZpbmVkID8gbWFyZ2luIDogc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLm1hcmdpbjtcbiAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmZyZWVNYXJnaW4gPSBmcmVlTWFyZ2luICE9PSB1bmRlZmluZWQgPyBmcmVlTWFyZ2luIDogXG4gICAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmZyZWVNYXJnaW47XG4gICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5tYXJnaW5MZXZlbCA9IGZyZWVNYXJnaW4gIT09IHVuZGVmaW5lZCA/IG1hcmdpbkxldmVsIDpcbiAgICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24ubWFyZ2luTGV2ZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGVTeW1ib2xQcmljZXMoaW5zdGFuY2VTdGF0ZSk7XG4gICAgdXBkYXRlU3ltYm9sUHJpY2VzKHRoaXMuX2NvbWJpbmVkU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN0cmVhbSBmb3IgYW4gaW5zdGFuY2UgaW5kZXggaXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25TdHJlYW1DbG9zZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIGlmKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlSW5kZXhdKSB7XG4gICAgICBmb3IobGV0IHN0YXRlSW5kZXggb2YgdGhpcy5fZ2V0U3RhdGVJbmRpY2VzT2ZTYW1lSW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCkpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VTdGF0ZSA9IHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W3N0YXRlSW5kZXhdO1xuICAgICAgICBpZighdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF0ub3JkZXJzSW5pdGlhbGl6ZWQgXG4gICAgICAgICAgICAmJiB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtpbnN0YW5jZUluZGV4XS5sYXN0U3luY1VwZGF0ZVRpbWUgPD0gaW5zdGFuY2VTdGF0ZS5sYXN0U3luY1VwZGF0ZVRpbWUpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW5zdGFuY2VTdGF0ZS5jb25uZWN0ZWQgJiYgaW5zdGFuY2VTdGF0ZS5vcmRlcnNJbml0aWFsaXplZCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtpbnN0YW5jZUluZGV4XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpe1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gICAgaWYoc3RhdGUgJiYgc3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXRlLmxhc3RTeW5jVXBkYXRlVGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICB9XG5cbiAgX2dldFN0YXRlSW5kaWNlc09mU2FtZUluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpIHtcbiAgICBjb25zdCByZWdpb24gPSBpbnN0YW5jZUluZGV4LnNwbGl0KCc6JylbMF07XG4gICAgY29uc3QgaW5zdGFuY2VOdW1iZXIgPSBpbnN0YW5jZUluZGV4LnNwbGl0KCc6JylbMV07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KVxuICAgICAgLmZpbHRlcihzdGF0ZUluc3RhbmNlSW5kZXggPT4gc3RhdGVJbnN0YW5jZUluZGV4LnN0YXJ0c1dpdGgoYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfTpgKSAmJiBcbiAgICAgIGluc3RhbmNlSW5kZXggIT09IHN0YXRlSW5zdGFuY2VJbmRleCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBfdXBkYXRlUG9zaXRpb25Qcm9maXRzKHBvc2l0aW9uLCBwcmljZSkge1xuICAgIGxldCBzcGVjaWZpY2F0aW9uID0gdGhpcy5zcGVjaWZpY2F0aW9uKHBvc2l0aW9uLnN5bWJvbCk7XG4gICAgaWYgKHNwZWNpZmljYXRpb24pIHtcbiAgICAgIGxldCBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHNwZWNpZmljYXRpb24uZGlnaXRzKTtcbiAgICAgIGlmIChwb3NpdGlvbi5wcm9maXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi5wcm9maXQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnByb2ZpdCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24ucmVhbGl6ZWRQcm9maXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID0gKHBvc2l0aW9uLnR5cGUgPT09ICdQT1NJVElPTl9UWVBFX0JVWScgPyAxIDogLTEpICpcbiAgICAgICAgICAocG9zaXRpb24uY3VycmVudFByaWNlIC0gcG9zaXRpb24ub3BlblByaWNlKSAqIHBvc2l0aW9uLmN1cnJlbnRUaWNrVmFsdWUgKlxuICAgICAgICAgIHBvc2l0aW9uLnZvbHVtZSAvIHNwZWNpZmljYXRpb24udGlja1NpemU7XG4gICAgICAgIHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgICAgIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0ID0gcG9zaXRpb24ucHJvZml0IC0gcG9zaXRpb24udW5yZWFsaXplZFByb2ZpdDtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdQb3NpdGlvblByaWNlID0gcG9zaXRpb24udHlwZSA9PT0gJ1BPU0lUSU9OX1RZUEVfQlVZJyA/IHByaWNlLmJpZCA6IHByaWNlLmFzaztcbiAgICAgIGxldCBpc1Byb2ZpdGFibGUgPSAocG9zaXRpb24udHlwZSA9PT0gJ1BPU0lUSU9OX1RZUEVfQlVZJyA/IDEgOiAtMSkgKiAobmV3UG9zaXRpb25QcmljZSAtIHBvc2l0aW9uLm9wZW5QcmljZSk7XG4gICAgICBsZXQgY3VycmVudFRpY2tWYWx1ZSA9IChpc1Byb2ZpdGFibGUgPiAwID8gcHJpY2UucHJvZml0VGlja1ZhbHVlIDogcHJpY2UubG9zc1RpY2tWYWx1ZSk7XG4gICAgICBsZXQgdW5yZWFsaXplZFByb2ZpdCA9IChwb3NpdGlvbi50eXBlID09PSAnUE9TSVRJT05fVFlQRV9CVVknID8gMSA6IC0xKSAqXG4gICAgICAgIChuZXdQb3NpdGlvblByaWNlIC0gcG9zaXRpb24ub3BlblByaWNlKSAqIGN1cnJlbnRUaWNrVmFsdWUgKlxuICAgICAgICBwb3NpdGlvbi52b2x1bWUgLyBzcGVjaWZpY2F0aW9uLnRpY2tTaXplO1xuICAgICAgdW5yZWFsaXplZFByb2ZpdCA9IE1hdGgucm91bmQodW5yZWFsaXplZFByb2ZpdCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgIHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPSB1bnJlYWxpemVkUHJvZml0O1xuICAgICAgcG9zaXRpb24ucHJvZml0ID0gcG9zaXRpb24udW5yZWFsaXplZFByb2ZpdCArIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0O1xuICAgICAgcG9zaXRpb24ucHJvZml0ID0gTWF0aC5yb3VuZChwb3NpdGlvbi5wcm9maXQgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgICBwb3NpdGlvbi5jdXJyZW50UHJpY2UgPSBuZXdQb3NpdGlvblByaWNlO1xuICAgICAgcG9zaXRpb24uY3VycmVudFRpY2tWYWx1ZSA9IGN1cnJlbnRUaWNrVmFsdWU7XG4gICAgfVxuICB9XG4gIFxuICBfZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCkge1xuICAgIGlmICghdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSkge1xuICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGAke3RoaXMuX2FjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogY29uc3RydWN0ZWQgbmV3IHN0YXRlYCk7XG4gICAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdID0gdGhpcy5fY29uc3RydWN0VGVybWluYWxTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICBfY29uc3RydWN0VGVybWluYWxTdGF0ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3RhbmNlSW5kZXgsXG4gICAgICBjb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgY29ubmVjdGVkVG9Ccm9rZXI6IGZhbHNlLFxuICAgICAgYWNjb3VudEluZm9ybWF0aW9uOiB1bmRlZmluZWQsXG4gICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgb3JkZXJzOiBbXSxcbiAgICAgIHNwZWNpZmljYXRpb25zQnlTeW1ib2w6IHt9LFxuICAgICAgcHJpY2VzQnlTeW1ib2w6IHt9LFxuICAgICAgY29tcGxldGVkT3JkZXJzOiB7fSxcbiAgICAgIHJlbW92ZWRQb3NpdGlvbnM6IHt9LFxuICAgICAgb3JkZXJzSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgcG9zaXRpb25zSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgbGFzdFVwZGF0ZVRpbWU6IDAsXG4gICAgICBsYXN0U3luY1VwZGF0ZVRpbWU6IDAsXG4gICAgICBwb3NpdGlvbnNIYXNoOiBudWxsLFxuICAgICAgb3JkZXJzSGFzaDogbnVsbCxcbiAgICAgIHNwZWNpZmljYXRpb25zSGFzaDogbnVsbCxcbiAgICAgIGxhc3RRdW90ZVRpbWU6IHVuZGVmaW5lZCxcbiAgICAgIGxhc3RRdW90ZUJyb2tlclRpbWU6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICBfZ2V0SGFzaChvYmosIGFjY291bnRUeXBlLCBpbnRlZ2VyS2V5cykge1xuICAgIGxldCBqc29uSXRlbSA9ICcnO1xuICAgIGlmKGFjY291bnRUeXBlID09PSAnY2xvdWQtZzEnKSB7XG4gICAgICBjb25zdCBzdHJpbmdpZnkgPSAob2JqRnJvbUpzb24sIGtleSkgPT4ge1xuICAgICAgICBpZih0eXBlb2Ygb2JqRnJvbUpzb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgaWYoaW50ZWdlcktleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iakZyb21Kc29uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqRnJvbUpzb24udG9GaXhlZCg4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihBcnJheS5pc0FycmF5KG9iakZyb21Kc29uKSkge1xuICAgICAgICAgIHJldHVybiBgWyR7b2JqRnJvbUpzb24ubWFwKGl0ZW0gPT4gc3RyaW5naWZ5KGl0ZW0pKS5qb2luKCcsJyl9XWA7IFxuICAgICAgICB9IGVsc2UgaWYgKG9iakZyb21Kc29uID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG9iakZyb21Kc29uO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpGcm9tSnNvbiAhPT0gJ29iamVjdCcgfHwgb2JqRnJvbUpzb24uZ2V0VGltZSl7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iakZyb21Kc29uKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3RcbiAgICAgICAgICAua2V5cyhvYmpGcm9tSnNvbilcbiAgICAgICAgICAubWFwKGtleUl0ZW0gPT4gYFwiJHtrZXlJdGVtfVwiOiR7c3RyaW5naWZ5KG9iakZyb21Kc29uW2tleUl0ZW1dLCBrZXlJdGVtKX1gKVxuICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgICAgIHJldHVybiBgeyR7cHJvcHN9fWA7XG4gICAgICB9O1xuICAgIFxuICAgICAganNvbkl0ZW0gPSBzdHJpbmdpZnkob2JqKTtcbiAgICB9IGVsc2UgaWYoYWNjb3VudFR5cGUgPT09ICdjbG91ZC1nMicpIHtcbiAgICAgIGNvbnN0IHN0cmluZ2lmeSA9IChvYmpGcm9tSnNvbiwga2V5KSA9PiB7XG4gICAgICAgIGlmKHR5cGVvZiBvYmpGcm9tSnNvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBpZihpbnRlZ2VyS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqRnJvbUpzb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG9iakZyb21Kc29uLnRvRml4ZWQoOCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKEFycmF5LmlzQXJyYXkob2JqRnJvbUpzb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGBbJHtvYmpGcm9tSnNvbi5tYXAoaXRlbSA9PiBzdHJpbmdpZnkoaXRlbSkpLmpvaW4oJywnKX1dYDsgXG4gICAgICAgIH0gZWxzZSBpZiAob2JqRnJvbUpzb24gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb2JqRnJvbUpzb247XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iakZyb21Kc29uICE9PSAnb2JqZWN0JyB8fCBvYmpGcm9tSnNvbi5nZXRUaW1lKXtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqRnJvbUpzb24pO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGxldCBwcm9wcyA9IE9iamVjdFxuICAgICAgICAgIC5rZXlzKG9iakZyb21Kc29uKVxuICAgICAgICAgIC5tYXAoa2V5SXRlbSA9PiBgXCIke2tleUl0ZW19XCI6JHtzdHJpbmdpZnkob2JqRnJvbUpzb25ba2V5SXRlbV0sIGtleUl0ZW0pfWApXG4gICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgcmV0dXJuIGB7JHtwcm9wc319YDtcbiAgICAgIH07XG5cbiAgICAgIGpzb25JdGVtID0gc3RyaW5naWZ5KG9iaik7XG4gICAgfVxuICAgIHJldHVybiBjcnlwdG8uTUQ1KGpzb25JdGVtKS50b1N0cmluZygpO1xuICB9XG4gIFxufVxuIl19