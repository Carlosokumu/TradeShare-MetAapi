'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _timeoutError = require('../clients/timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _rpcMetaApiConnection = require('./rpcMetaApiConnection');

var _rpcMetaApiConnection2 = _interopRequireDefault(_rpcMetaApiConnection);

var _index = require('./historyDatabase/index');

var _index2 = _interopRequireDefault(_index);

var _expertAdvisor = require('./expertAdvisor');

var _expertAdvisor2 = _interopRequireDefault(_expertAdvisor);

var _errorHandler = require('../clients/errorHandler');

var _metatraderAccountReplica = require('./metatraderAccountReplica');

var _metatraderAccountReplica2 = _interopRequireDefault(_metatraderAccountReplica);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Implements a MetaTrader account entity
 */
class MetatraderAccount {

  /**
   * Constructs a MetaTrader account entity
   * @param {MetatraderAccountDto} data MetaTrader account data
   * @param {MetatraderAccountClient} metatraderAccountClient MetaTrader account REST API client
   * @param {MetaApiWebsocketClient} metaApiWebsocketClient MetaApi websocket client
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {ExpertAdvisorClient} expertAdvisorClient expert advisor REST API client
   * @param {HistoricalMarketDataClient} historicalMarketDataClient historical market data HTTP API client
   * @param {string} application application name
   */
  constructor(data, metatraderAccountClient, metaApiWebsocketClient, connectionRegistry, expertAdvisorClient, historicalMarketDataClient, application) {
    this._data = data;
    this._metatraderAccountClient = metatraderAccountClient;
    this._metaApiWebsocketClient = metaApiWebsocketClient;
    this._connectionRegistry = connectionRegistry;
    this._expertAdvisorClient = expertAdvisorClient;
    this._historicalMarketDataClient = historicalMarketDataClient;
    this._application = application;
    this._replicas = (data.accountReplicas || []).map(replica => new _metatraderAccountReplica2.default(replica, this, metatraderAccountClient));
  }

  /**
   * Returns account id
   * @return {String} account id
   */
  get id() {
    return this._data._id;
  }

  /**
   * Returns account name
   * @return {String} account name
   */
  get name() {
    return this._data.name;
  }

  /**
   * Returns account type. Possible values are cloud, cloud-g1, cloud-g2 and self-hosted.
   * @return {String} account type
   */
  get type() {
    return this._data.type;
  }

  /**
   * Returns account login
   * @return {String} account login
   */
  get login() {
    return this._data.login;
  }

  /**
   * Returns MetaTrader server which hosts the account
   * @return {String} MetaTrader server which hosts the account
   */
  get server() {
    return this._data.server;
  }

  /**
   * Returns id of the account's provisioning profile
   * @return {String} id of the account's provisioning profile
   */
  get provisioningProfileId() {
    return this._data.provisioningProfileId;
  }

  /**
   * Returns application name to connect the account to. Currently allowed values are MetaApi and AgiliumTrade
   * @return {String} application name to connect the account to
   */
  get application() {
    return this._data.application;
  }

  /**
   * Returns MetaTrader magic to place trades using
   * @return {Number} MetaTrader magic to place trades using
   */
  get magic() {
    return this._data.magic;
  }

  /**
   * Returns account deployment state. One of CREATED, DEPLOYING, DEPLOYED, UNDEPLOYING, UNDEPLOYED, DELETING
   * @return {String} account deployment state
   */
  get state() {
    return this._data.state;
  }

  /**
   * Returns terminal & broker connection status, one of CONNECTED, DISCONNECTED, DISCONNECTED_FROM_BROKER
   * @return {String} terminal & broker connection status
   */
  get connectionStatus() {
    return this._data.connectionStatus;
  }

  /**
   * Returns authorization access token to be used for accessing single account data.
   * Intended to be used in browser API.
   * @return {String} authorization token
   */
  get accessToken() {
    return this._data.accessToken;
  }

  /**
   * Returns flag indicating if trades should be placed as manual trades on this account
   * @return {Boolean} flag indicating if trades should be placed as manual trades on this account
   */
  get manualTrades() {
    return !!this._data.manualTrades;
  }

  /**
   * Returns extra information which can be stored together with your account
   * @return {Object} extra information which can be stored together with your account
   */
  get metadata() {
    return this._data.metadata;
  }

  /**
   * Returns user-defined account tags
   * @return {Array<string>} user-defined account tags
   */
  get tags() {
    return this._data.tags;
  }

  /**
   * Returns account roles for CopyFactory2 application
   * @return {Array<string>} account roles for CopyFactory2 application
   */
  get copyFactoryRoles() {
    return this._data.copyFactoryRoles;
  }

  /**
   * Returns number of resource slots to allocate to account. Allocating extra resource slots
   * results in better account performance under load which is useful for some applications. E.g. if you have many
   * accounts copying the same strategy via CooyFactory API, then you can increase resourceSlots to get a lower trade
   * copying latency. Please note that allocating extra resource slots is a paid option. Please note that high
   * reliability accounts use redundant infrastructure, so that each resource slot for a high reliability account
   * is billed as 2 standard resource slots.  Default is 1.
   * @return {number} number of resource slots to allocate to account
   */
  get resourceSlots() {
    return this._data.resourceSlots;
  }

  /**
   * Returns the number of CopyFactory 2 resource slots to allocate to account.
   * Allocating extra resource slots results in lower trade copying latency. Please note that allocating extra resource
   * slots is a paid option. Please also note that CopyFactory 2 uses redundant infrastructure so that
   * each CopyFactory resource slot is billed as 2 standard resource slots. You will be billed for CopyFactory 2
   * resource slots only if you have added your account to CopyFactory 2 by specifying copyFactoryRoles field.
   * Default is 1.
   * @return {number} number of CopyFactory 2 resource slots to allocate to account
   */
  get copyFactoryResourceSlots() {
    return this._data.copyFactoryResourceSlots;
  }

  /**
   * Returns 3-character ISO currency code of the account base currency. Default value is USD. The setting is to be used
   * for copy trading accounts which use national currencies only, such as some Brazilian brokers. You should not alter
   * this setting unless you understand what you are doing.
   * @return {number} 3-character ISO currency code of the account base currency
   */
  get baseCurrency() {
    return this._data.baseCurrency;
  }

  /**
   * Returns reliability value. Possible values are regular and high
   * @return {String} account reliability value
   */
  get reliability() {
    return this._data.reliability;
  }

  /**
   * Returns version value. Possible values are 4 and 5
   * @return {String} account version value
   */
  get version() {
    return this._data.version;
  }

  /**
   * Returns account region
   * @return {String} account region value
   */
  get region() {
    return this._data.region;
  }

  /**
   * Returns active account connections
   * @return {Array<AccountConnection>} active account connections
   */
  get connections() {
    return this._data.connections;
  }

  /**
   * Returns flag indicating that risk management API is enabled on account. Default is false.
   * @return {boolean} flag indicating that risk management API is enabled on account
   */
  get riskManagementApiEnabled() {
    return this._data.riskManagementApiEnabled;
  }

  /**
   * Returns user id
   * @return {String} user id
   */
  get userId() {
    return this._data.userId;
  }

  /**
   * Returns account replica instances
   * @return {MetatraderAccountReplica[]} account replica instances
   */
  get replicas() {
    return this._replicas;
  }

  /**
   * Returns a dictionary with account's available regions and replicas
   * @returns {[id: string]: string}
   */
  get accountRegions() {
    const regions = { [this.region]: this.id };
    this.replicas.forEach(replica => regions[replica.region] = replica.id);
    return regions;
  }

  /**
   * Reloads MetaTrader account from API
   * @return {Promise} promise resolving when MetaTrader account is updated
   */
  async reload() {
    this._data = await this._metatraderAccountClient.getAccount(this.id);
    const updatedReplicaData = this._data.accountReplicas || [];
    const regions = updatedReplicaData.map(replica => replica.region);
    const createdReplicaRegions = this._replicas.map(replica => replica.region);
    this._replicas = this._replicas.filter(replica => regions.includes(replica.region));
    this._replicas.forEach(replica => {
      const updatedData = updatedReplicaData.find(replicaData => replicaData._id === replica.id);
      replica.updateData(updatedData);
    });
    updatedReplicaData.forEach(replica => {
      if (!createdReplicaRegions.includes(replica.region)) {
        this._replicas.push(new _metatraderAccountReplica2.default(replica, this, this._metatraderAccountClient));
      }
    });
  }

  /**
   * Removes MetaTrader account. Cloud account transitions to DELETING state. 
   * It takes some time for an account to be eventually deleted. Self-hosted 
   * account is deleted immediately.
   * @return {Promise} promise resolving when account is scheduled for deletion
   */
  async remove() {
    this._connectionRegistry.remove(this.id);
    await this._metatraderAccountClient.deleteAccount(this.id);
    const fileManager = _index2.default.getInstance();
    await fileManager.clear(this.id, this._application);
    if (this.type !== 'self-hosted') {
      try {
        await this.reload();
      } catch (err) {
        if (err.name !== 'NotFoundError') {
          throw err;
        }
      }
    }
  }

  /**
   * Schedules account for deployment. It takes some time for API server to be started and account to reach the DEPLOYED
   * state
   * @returns {Promise} promise resolving when account is scheduled for deployment
   */
  async deploy() {
    await this._metatraderAccountClient.deployAccount(this.id);
    await this.reload();
  }

  /**
   * Schedules account for undeployment. It takes some time for API server to be stopped and account to reach the
   * UNDEPLOYED state
   * @returns {Promise} promise resolving when account is scheduled for undeployment
   */
  async undeploy() {
    this._connectionRegistry.remove(this.id);
    await this._metatraderAccountClient.undeployAccount(this.id);
    await this.reload();
  }

  /**
   * Schedules account for redeployment. It takes some time for API server to be restarted and account to reach the
   * DEPLOYED state
   * @returns {Promise} promise resolving when account is scheduled for redeployment
   */
  async redeploy() {
    await this._metatraderAccountClient.redeployAccount(this.id);
    await this.reload();
  }

  /**
   * Increases MetaTrader account reliability. The account will be temporary stopped to perform this action
   * @returns {Promise} promise resolving when account reliability is increased
   */
  async increaseReliability() {
    await this._metatraderAccountClient.increaseReliability(this.id);
    await this.reload();
  }

  /**
   * Waits until API server has finished deployment and account reached the DEPLOYED state
   * @param {Number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {Number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deployed
   * @throws {TimeoutError} if account have not reached the DEPLOYED state within timeout allowed
   */
  async waitDeployed(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
    let startTime = Date.now();
    await this.reload();
    while (this.state !== 'DEPLOYED' && startTime + timeoutInSeconds * 1000 > Date.now()) {
      await this._delay(intervalInMilliseconds);
      await this.reload();
    }
    if (this.state !== 'DEPLOYED') {
      throw new _timeoutError2.default('Timed out waiting for account ' + this.id + ' to be deployed');
    }
  }

  /**
   * Waits until API server has finished undeployment and account reached the UNDEPLOYED state
   * @param {Number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {Number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deployed
   * @throws {TimeoutError} if account have not reached the UNDEPLOYED state within timeout allowed
   */
  async waitUndeployed(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
    let startTime = Date.now();
    await this.reload();
    while (this.state !== 'UNDEPLOYED' && startTime + timeoutInSeconds * 1000 > Date.now()) {
      await this._delay(intervalInMilliseconds);
      await this.reload();
    }
    if (this.state !== 'UNDEPLOYED') {
      throw new _timeoutError2.default('Timed out waiting for account ' + this.id + ' to be undeployed');
    }
  }

  /**
   * Waits until account has been deleted
   * @param {Number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {Number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deleted
   * @throws {TimeoutError} if account was not deleted within timeout allowed
   */
  async waitRemoved(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
    let startTime = Date.now();
    try {
      await this.reload();
      while (startTime + timeoutInSeconds * 1000 > Date.now()) {
        await this._delay(intervalInMilliseconds);
        await this.reload();
      }
      throw new _timeoutError2.default('Timed out waiting for account ' + this.id + ' to be deleted');
    } catch (err) {
      if (err.name === 'NotFoundError') {
        return;
      } else {
        throw err;
      }
    }
  }

  /**
   * Waits until API server has connected to the terminal and terminal has connected to the broker
   * @param {Number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {Number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when API server is connected to the broker
   * @throws {TimeoutError} if account have not connected to the broker within timeout allowed
   */
  async waitConnected(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
    const checkConnected = () => {
      return [this.connectionStatus].concat(this.replicas.map(replica => replica.connectionStatus)).includes('CONNECTED');
    };

    let startTime = Date.now();
    await this.reload();
    while (!checkConnected() && startTime + timeoutInSeconds * 1000 > Date.now()) {
      await this._delay(intervalInMilliseconds);
      await this.reload();
    }
    if (!checkConnected()) {
      throw new _timeoutError2.default('Timed out waiting for account ' + this.id + ' to connect to the broker');
    }
  }

  /**
   * Connects to MetaApi. There is only one connection per account. Subsequent calls to this method will return the same connection.
   * @param {HistoryStorage} historyStorage optional history storage
   * @param {Date} [historyStartTime] history start time. Used for tests
   * @return {StreamingMetaApiConnection} MetaApi connection
   */
  getStreamingConnection(historyStorage, historyStartTime) {
    if (this._metaApiWebsocketClient.region && this._metaApiWebsocketClient.region !== this.region) {
      throw new _errorHandler.ValidationError(`Account ${this.id} is not on specified region ${this._metaApiWebsocketClient.region}`);
    }
    return this._connectionRegistry.connect(this, historyStorage, historyStartTime);
  }

  /**
   * Connects to MetaApi via RPC connection.
   * @returns {RpcMetaApiConnection} MetaApi connection
   */
  getRPCConnection() {
    if (this._metaApiWebsocketClient.region && this._metaApiWebsocketClient.region !== this.region) {
      throw new _errorHandler.ValidationError(`Account ${this.id} is not on specified region ${this._metaApiWebsocketClient.region}`);
    }
    return new _rpcMetaApiConnection2.default(this._metaApiWebsocketClient, this);
  }

  /**
   * Updates MetaTrader account data
   * @param {MetatraderAccountUpdateDto} account MetaTrader account update
   * @return {Promise} promise resolving when account is updated
   */
  async update(account) {
    await this._metatraderAccountClient.updateAccount(this.id, account);
    await this.reload();
  }

  /**
   * Creates a MetaTrader account replica
   * @param {NewMetatraderAccountDto} replica MetaTrader account replica data
   * @return {Promise<MetatraderAccountReplica>} promise resolving with MetaTrader account replica entity
   */
  async createReplica(replica) {
    await this._metatraderAccountClient.createAccountReplica(this.id, replica);
    await this.reload();
    return this._replicas.find(r => r.region === replica.region);
  }

  /**
   * Retrieves expert advisor of current account
   * @returns {Promise<ExpertAdvisor[]>} promise resolving with an array of expert advisor entities
   */
  async getExpertAdvisors() {
    this._checkExpertAdvisorAllowed();
    let expertAdvisors = await this._expertAdvisorClient.getExpertAdvisors(this.id);
    return expertAdvisors.map(e => new _expertAdvisor2.default(e, this.id, this._expertAdvisorClient));
  }

  /**
   * Retrieves a expert advisor of current account by id
   * @param {String} expertId expert advisor id
   * @returns {Promise<ExpertAdvisor>} promise resolving with expert advisor entity
   */
  async getExpertAdvisor(expertId) {
    this._checkExpertAdvisorAllowed();
    let expertAdvisor = await this._expertAdvisorClient.getExpertAdvisor(this.id, expertId);
    return new _expertAdvisor2.default(expertAdvisor, this.id, this._expertAdvisorClient);
  }

  /**
   * Creates an expert advisor
   * @param {String} expertId expert advisor id
   * @param {NewExpertAdvisorDto} expert expert advisor data
   * @returns {Promise<ExpertAdvisor>} promise resolving with expert advisor entity
   */
  async createExpertAdvisor(expertId, expert) {
    this._checkExpertAdvisorAllowed();
    await this._expertAdvisorClient.updateExpertAdvisor(this.id, expertId, expert);
    return this.getExpertAdvisor(expertId);
  }

  /**
   * Returns historical candles for a specific symbol and timeframe from the MetaTrader account.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalCandles/
   * @param {string} symbol symbol to retrieve candles for (e.g. a currency pair or an index)
   * @param {string} timeframe defines the timeframe according to which the candles must be generated. Allowed values
   * for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed
   * values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @param {Date} [startTime] time to start loading candles from. Note that candles are loaded in backwards direction, so
   * this should be the latest time. Leave empty to request latest candles.
   * @param {number} [limit] maximum number of candles to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderCandle>>} promise resolving with historical candles downloaded
   */
  getHistoricalCandles(symbol, timeframe, startTime, limit) {
    return this._historicalMarketDataClient.getHistoricalCandles(this.id, this.region, symbol, timeframe, startTime, limit);
  }

  /**
   * Returns historical ticks for a specific symbol from the MetaTrader account. This API is not supported by MT4
   * accounts.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalTicks/
   * @param {string} symbol symbol to retrieve ticks for (e.g. a currency pair or an index)
   * @param {Date} [startTime] time to start loading ticks from. Note that candles are loaded in forward direction, so
   * this should be the earliest time. Leave empty to request latest candles.
   * @param {number} [offset] number of ticks to skip (you can use it to avoid requesting ticks from previous request
   * twice)
   * @param {number} [limit] maximum number of ticks to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderTick>>} promise resolving with historical ticks downloaded
   */
  getHistoricalTicks(symbol, startTime, offset, limit) {
    return this._historicalMarketDataClient.getHistoricalTicks(this.id, this.region, symbol, startTime, offset, limit);
  }

  _checkExpertAdvisorAllowed() {
    if (this.version !== 4 || this.type !== 'cloud-g1') {
      throw new _errorHandler.ValidationError('Custom expert advisor is available only for MT4 G1 accounts');
    }
  }

  _delay(timeoutInMilliseconds) {
    return new _promise2.default(res => setTimeout(res, timeoutInMilliseconds));
  }

}
exports.default = MetatraderAccount;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9tZXRhQXBpL21ldGF0cmFkZXJBY2NvdW50LmVzNiJdLCJuYW1lcyI6WyJNZXRhdHJhZGVyQWNjb3VudCIsImNvbnN0cnVjdG9yIiwiZGF0YSIsIm1ldGF0cmFkZXJBY2NvdW50Q2xpZW50IiwibWV0YUFwaVdlYnNvY2tldENsaWVudCIsImNvbm5lY3Rpb25SZWdpc3RyeSIsImV4cGVydEFkdmlzb3JDbGllbnQiLCJoaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCIsImFwcGxpY2F0aW9uIiwiX2RhdGEiLCJfbWV0YXRyYWRlckFjY291bnRDbGllbnQiLCJfbWV0YUFwaVdlYnNvY2tldENsaWVudCIsIl9jb25uZWN0aW9uUmVnaXN0cnkiLCJfZXhwZXJ0QWR2aXNvckNsaWVudCIsIl9oaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCIsIl9hcHBsaWNhdGlvbiIsIl9yZXBsaWNhcyIsImFjY291bnRSZXBsaWNhcyIsIm1hcCIsInJlcGxpY2EiLCJNZXRhdHJhZGVyQWNjb3VudFJlcGxpY2EiLCJpZCIsIl9pZCIsIm5hbWUiLCJ0eXBlIiwibG9naW4iLCJzZXJ2ZXIiLCJwcm92aXNpb25pbmdQcm9maWxlSWQiLCJtYWdpYyIsInN0YXRlIiwiY29ubmVjdGlvblN0YXR1cyIsImFjY2Vzc1Rva2VuIiwibWFudWFsVHJhZGVzIiwibWV0YWRhdGEiLCJ0YWdzIiwiY29weUZhY3RvcnlSb2xlcyIsInJlc291cmNlU2xvdHMiLCJjb3B5RmFjdG9yeVJlc291cmNlU2xvdHMiLCJiYXNlQ3VycmVuY3kiLCJyZWxpYWJpbGl0eSIsInZlcnNpb24iLCJyZWdpb24iLCJjb25uZWN0aW9ucyIsInJpc2tNYW5hZ2VtZW50QXBpRW5hYmxlZCIsInVzZXJJZCIsInJlcGxpY2FzIiwiYWNjb3VudFJlZ2lvbnMiLCJyZWdpb25zIiwiZm9yRWFjaCIsInJlbG9hZCIsImdldEFjY291bnQiLCJ1cGRhdGVkUmVwbGljYURhdGEiLCJjcmVhdGVkUmVwbGljYVJlZ2lvbnMiLCJmaWx0ZXIiLCJpbmNsdWRlcyIsInVwZGF0ZWREYXRhIiwiZmluZCIsInJlcGxpY2FEYXRhIiwidXBkYXRlRGF0YSIsInB1c2giLCJyZW1vdmUiLCJkZWxldGVBY2NvdW50IiwiZmlsZU1hbmFnZXIiLCJIaXN0b3J5RGF0YWJhc2UiLCJnZXRJbnN0YW5jZSIsImNsZWFyIiwiZXJyIiwiZGVwbG95IiwiZGVwbG95QWNjb3VudCIsInVuZGVwbG95IiwidW5kZXBsb3lBY2NvdW50IiwicmVkZXBsb3kiLCJyZWRlcGxveUFjY291bnQiLCJpbmNyZWFzZVJlbGlhYmlsaXR5Iiwid2FpdERlcGxveWVkIiwidGltZW91dEluU2Vjb25kcyIsImludGVydmFsSW5NaWxsaXNlY29uZHMiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiX2RlbGF5IiwiVGltZW91dEVycm9yIiwid2FpdFVuZGVwbG95ZWQiLCJ3YWl0UmVtb3ZlZCIsIndhaXRDb25uZWN0ZWQiLCJjaGVja0Nvbm5lY3RlZCIsImNvbmNhdCIsImdldFN0cmVhbWluZ0Nvbm5lY3Rpb24iLCJoaXN0b3J5U3RvcmFnZSIsImhpc3RvcnlTdGFydFRpbWUiLCJWYWxpZGF0aW9uRXJyb3IiLCJjb25uZWN0IiwiZ2V0UlBDQ29ubmVjdGlvbiIsIlJwY01ldGFBcGlDb25uZWN0aW9uIiwidXBkYXRlIiwiYWNjb3VudCIsInVwZGF0ZUFjY291bnQiLCJjcmVhdGVSZXBsaWNhIiwiY3JlYXRlQWNjb3VudFJlcGxpY2EiLCJyIiwiZ2V0RXhwZXJ0QWR2aXNvcnMiLCJfY2hlY2tFeHBlcnRBZHZpc29yQWxsb3dlZCIsImV4cGVydEFkdmlzb3JzIiwiZSIsIkV4cGVydEFkdmlzb3IiLCJnZXRFeHBlcnRBZHZpc29yIiwiZXhwZXJ0SWQiLCJleHBlcnRBZHZpc29yIiwiY3JlYXRlRXhwZXJ0QWR2aXNvciIsImV4cGVydCIsInVwZGF0ZUV4cGVydEFkdmlzb3IiLCJnZXRIaXN0b3JpY2FsQ2FuZGxlcyIsInN5bWJvbCIsInRpbWVmcmFtZSIsImxpbWl0IiwiZ2V0SGlzdG9yaWNhbFRpY2tzIiwib2Zmc2V0IiwidGltZW91dEluTWlsbGlzZWNvbmRzIiwicmVzIiwic2V0VGltZW91dCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFFQTs7O0FBR2UsTUFBTUEsaUJBQU4sQ0FBd0I7O0FBRXJDOzs7Ozs7Ozs7O0FBVUFDLGNBQVlDLElBQVosRUFBa0JDLHVCQUFsQixFQUEyQ0Msc0JBQTNDLEVBQW1FQyxrQkFBbkUsRUFBdUZDLG1CQUF2RixFQUNFQywwQkFERixFQUM4QkMsV0FEOUIsRUFDMkM7QUFDekMsU0FBS0MsS0FBTCxHQUFhUCxJQUFiO0FBQ0EsU0FBS1Esd0JBQUwsR0FBZ0NQLHVCQUFoQztBQUNBLFNBQUtRLHVCQUFMLEdBQStCUCxzQkFBL0I7QUFDQSxTQUFLUSxtQkFBTCxHQUEyQlAsa0JBQTNCO0FBQ0EsU0FBS1Esb0JBQUwsR0FBNEJQLG1CQUE1QjtBQUNBLFNBQUtRLDJCQUFMLEdBQW1DUCwwQkFBbkM7QUFDQSxTQUFLUSxZQUFMLEdBQW9CUCxXQUFwQjtBQUNBLFNBQUtRLFNBQUwsR0FBaUIsQ0FBQ2QsS0FBS2UsZUFBTCxJQUF3QixFQUF6QixFQUNkQyxHQURjLENBQ1ZDLFdBQVcsSUFBSUMsa0NBQUosQ0FBNkJELE9BQTdCLEVBQXNDLElBQXRDLEVBQTRDaEIsdUJBQTVDLENBREQsQ0FBakI7QUFFRDs7QUFFRDs7OztBQUlBLE1BQUlrQixFQUFKLEdBQVM7QUFDUCxXQUFPLEtBQUtaLEtBQUwsQ0FBV2EsR0FBbEI7QUFDRDs7QUFFRDs7OztBQUlBLE1BQUlDLElBQUosR0FBVztBQUNULFdBQU8sS0FBS2QsS0FBTCxDQUFXYyxJQUFsQjtBQUNEOztBQUVEOzs7O0FBSUEsTUFBSUMsSUFBSixHQUFXO0FBQ1QsV0FBTyxLQUFLZixLQUFMLENBQVdlLElBQWxCO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxNQUFJQyxLQUFKLEdBQVk7QUFDVixXQUFPLEtBQUtoQixLQUFM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RUFBK0QsS0FBS29CLE1BQXBFLEVBQTRFdUUsTUFBNUUsRUFDTEMsU0FESyxFQUNNcEMsU0FETixFQUNpQnFDLEtBRGpCLENBQVA7QUFFRDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUFDLHFCQUFtQkgsTUFBbkIsRUFBMkJuQyxTQUEzQixFQUFzQ3VDLE1BQXRDLEVBQThDRixLQUE5QyxFQUFxRDtBQUNuRCxXQUFPLEtBQUtwRywyQkFBTCxDQUFpQ3FHLGtCQUFqQyxDQUFvRCxLQUFLOUYsRUFBekQsRUFBNkQsS0FBS29CLE1BQWxFLEVBQTBFdUUsTUFBMUUsRUFBa0ZuQyxTQUFsRixFQUE2RnVDLE1BQTdGLEVBQXFHRixLQUFyRyxDQUFQO0FBQ0Q7O0FBRURiLCtCQUE2QjtBQUMzQixRQUFJLEtBQUs3RCxPQUFMLEtBQWlCLENBQWpCLElBQXNCLEtBQUtoQixJQUFMLEtBQWMsVUFBeEMsRUFBb0Q7QUFDbEQsWUFBTSxJQUFJa0UsNkJBQUosQ0FBb0IsNkRBQXBCLENBQU47QUFDRDtBQUNGOztBQUVEVixTQUFPcUMscUJBQVAsRUFBOEI7QUFDNUIsV0FBTyxzQkFBWUMsT0FBT0MsV0FBV0QsR0FBWCxFQUFnQkQscUJBQWhCLENBQW5CLENBQVA7QUFDRDs7QUE3aEJvQztrQkFBbEJySCxpQiIsImZpbGUiOiJtZXRhdHJhZGVyQWNjb3VudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFRpbWVvdXRFcnJvciBmcm9tICcuLi9jbGllbnRzL3RpbWVvdXRFcnJvcic7XG5pbXBvcnQgUnBjTWV0YUFwaUNvbm5lY3Rpb24gZnJvbSAnLi9ycGNNZXRhQXBpQ29ubmVjdGlvbic7XG5pbXBvcnQgSGlzdG9yeURhdGFiYXNlIGZyb20gJy4vaGlzdG9yeURhdGFiYXNlL2luZGV4JztcbmltcG9ydCBFeHBlcnRBZHZpc29yIGZyb20gJy4vZXhwZXJ0QWR2aXNvcic7XG5pbXBvcnQge1ZhbGlkYXRpb25FcnJvcn0gZnJvbSAnLi4vY2xpZW50cy9lcnJvckhhbmRsZXInO1xuaW1wb3J0IE1ldGF0cmFkZXJBY2NvdW50UmVwbGljYSBmcm9tICcuL21ldGF0cmFkZXJBY2NvdW50UmVwbGljYSc7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIE1ldGFUcmFkZXIgYWNjb3VudCBlbnRpdHlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YXRyYWRlckFjY291bnQge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgTWV0YVRyYWRlciBhY2NvdW50IGVudGl0eVxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50RHRvfSBkYXRhIE1ldGFUcmFkZXIgYWNjb3VudCBkYXRhXG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnRDbGllbnR9IG1ldGF0cmFkZXJBY2NvdW50Q2xpZW50IE1ldGFUcmFkZXIgYWNjb3VudCBSRVNUIEFQSSBjbGllbnRcbiAgICogQHBhcmFtIHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50fSBtZXRhQXBpV2Vic29ja2V0Q2xpZW50IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudFxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25SZWdpc3RyeX0gY29ubmVjdGlvblJlZ2lzdHJ5IG1ldGF0cmFkZXIgYWNjb3VudCBjb25uZWN0aW9uIHJlZ2lzdHJ5XG4gICAqIEBwYXJhbSB7RXhwZXJ0QWR2aXNvckNsaWVudH0gZXhwZXJ0QWR2aXNvckNsaWVudCBleHBlcnQgYWR2aXNvciBSRVNUIEFQSSBjbGllbnRcbiAgICogQHBhcmFtIHtIaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudH0gaGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQgaGlzdG9yaWNhbCBtYXJrZXQgZGF0YSBIVFRQIEFQSSBjbGllbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFwcGxpY2F0aW9uIGFwcGxpY2F0aW9uIG5hbWVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIG1ldGF0cmFkZXJBY2NvdW50Q2xpZW50LCBtZXRhQXBpV2Vic29ja2V0Q2xpZW50LCBjb25uZWN0aW9uUmVnaXN0cnksIGV4cGVydEFkdmlzb3JDbGllbnQsIFxuICAgIGhpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50LCBhcHBsaWNhdGlvbikge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50ID0gbWV0YXRyYWRlckFjY291bnRDbGllbnQ7XG4gICAgdGhpcy5fbWV0YUFwaVdlYnNvY2tldENsaWVudCA9IG1ldGFBcGlXZWJzb2NrZXRDbGllbnQ7XG4gICAgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5ID0gY29ubmVjdGlvblJlZ2lzdHJ5O1xuICAgIHRoaXMuX2V4cGVydEFkdmlzb3JDbGllbnQgPSBleHBlcnRBZHZpc29yQ2xpZW50O1xuICAgIHRoaXMuX2hpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50ID0gaGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQ7XG4gICAgdGhpcy5fYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICB0aGlzLl9yZXBsaWNhcyA9IChkYXRhLmFjY291bnRSZXBsaWNhcyB8fCBbXSlcbiAgICAgIC5tYXAocmVwbGljYSA9PiBuZXcgTWV0YXRyYWRlckFjY291bnRSZXBsaWNhKHJlcGxpY2EsIHRoaXMsIG1ldGF0cmFkZXJBY2NvdW50Q2xpZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IGlkXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYWNjb3VudCBpZFxuICAgKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLl9pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjY291bnQgbmFtZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGFjY291bnQgbmFtZVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjY291bnQgdHlwZS4gUG9zc2libGUgdmFsdWVzIGFyZSBjbG91ZCwgY2xvdWQtZzEsIGNsb3VkLWcyIGFuZCBzZWxmLWhvc3RlZC5cbiAgICogQHJldHVybiB7U3RyaW5nfSBhY2NvdW50IHR5cGVcbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnR5cGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IGxvZ2luXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYWNjb3VudCBsb2dpblxuICAgKi9cbiAgZ2V0IGxvZ2luKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmxvZ2luO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YVRyYWRlciBzZXJ2ZXIgd2hpY2ggaG9zdHMgdGhlIGFjY291bnRcbiAgICogQHJldHVybiB7U3RyaW5nfSBNZXRhVHJhZGVyIHNlcnZlciB3aGljaCBob3N0cyB0aGUgYWNjb3VudFxuICAgKi9cbiAgZ2V0IHNlcnZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zZXJ2ZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZCBvZiB0aGUgYWNjb3VudCdzIHByb3Zpc2lvbmluZyBwcm9maWxlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gaWQgb2YgdGhlIGFjY291bnQncyBwcm92aXNpb25pbmcgcHJvZmlsZVxuICAgKi9cbiAgZ2V0IHByb3Zpc2lvbmluZ1Byb2ZpbGVJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5wcm92aXNpb25pbmdQcm9maWxlSWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhcHBsaWNhdGlvbiBuYW1lIHRvIGNvbm5lY3QgdGhlIGFjY291bnQgdG8uIEN1cnJlbnRseSBhbGxvd2VkIHZhbHVlcyBhcmUgTWV0YUFwaSBhbmQgQWdpbGl1bVRyYWRlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYXBwbGljYXRpb24gbmFtZSB0byBjb25uZWN0IHRoZSBhY2NvdW50IHRvXG4gICAqL1xuICBnZXQgYXBwbGljYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuYXBwbGljYXRpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNZXRhVHJhZGVyIG1hZ2ljIHRvIHBsYWNlIHRyYWRlcyB1c2luZ1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE1ldGFUcmFkZXIgbWFnaWMgdG8gcGxhY2UgdHJhZGVzIHVzaW5nXG4gICAqL1xuICBnZXQgbWFnaWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubWFnaWM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IGRlcGxveW1lbnQgc3RhdGUuIE9uZSBvZiBDUkVBVEVELCBERVBMT1lJTkcsIERFUExPWUVELCBVTkRFUExPWUlORywgVU5ERVBMT1lFRCwgREVMRVRJTkdcbiAgICogQHJldHVybiB7U3RyaW5nfSBhY2NvdW50IGRlcGxveW1lbnQgc3RhdGVcbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRlcm1pbmFsICYgYnJva2VyIGNvbm5lY3Rpb24gc3RhdHVzLCBvbmUgb2YgQ09OTkVDVEVELCBESVNDT05ORUNURUQsIERJU0NPTk5FQ1RFRF9GUk9NX0JST0tFUlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRlcm1pbmFsICYgYnJva2VyIGNvbm5lY3Rpb24gc3RhdHVzXG4gICAqL1xuICBnZXQgY29ubmVjdGlvblN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5jb25uZWN0aW9uU3RhdHVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXV0aG9yaXphdGlvbiBhY2Nlc3MgdG9rZW4gdG8gYmUgdXNlZCBmb3IgYWNjZXNzaW5nIHNpbmdsZSBhY2NvdW50IGRhdGEuXG4gICAqIEludGVuZGVkIHRvIGJlIHVzZWQgaW4gYnJvd3NlciBBUEkuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYXV0aG9yaXphdGlvbiB0b2tlblxuICAgKi9cbiAgZ2V0IGFjY2Vzc1Rva2VuKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmFjY2Vzc1Rva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmxhZyBpbmRpY2F0aW5nIGlmIHRyYWRlcyBzaG91bGQgYmUgcGxhY2VkIGFzIG1hbnVhbCB0cmFkZXMgb24gdGhpcyBhY2NvdW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZsYWcgaW5kaWNhdGluZyBpZiB0cmFkZXMgc2hvdWxkIGJlIHBsYWNlZCBhcyBtYW51YWwgdHJhZGVzIG9uIHRoaXMgYWNjb3VudFxuICAgKi9cbiAgZ2V0IG1hbnVhbFRyYWRlcygpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kYXRhLm1hbnVhbFRyYWRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGV4dHJhIGluZm9ybWF0aW9uIHdoaWNoIGNhbiBiZSBzdG9yZWQgdG9nZXRoZXIgd2l0aCB5b3VyIGFjY291bnRcbiAgICogQHJldHVybiB7T2JqZWN0fSBleHRyYSBpbmZvcm1hdGlvbiB3aGljaCBjYW4gYmUgc3RvcmVkIHRvZ2V0aGVyIHdpdGggeW91ciBhY2NvdW50XG4gICAqL1xuICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB1c2VyLWRlZmluZWQgYWNjb3VudCB0YWdzXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IHVzZXItZGVmaW5lZCBhY2NvdW50IHRhZ3NcbiAgICovXG4gIGdldCB0YWdzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnRhZ3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHJvbGVzIGZvciBDb3B5RmFjdG9yeTIgYXBwbGljYXRpb25cbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gYWNjb3VudCByb2xlcyBmb3IgQ29weUZhY3RvcnkyIGFwcGxpY2F0aW9uXG4gICAqL1xuICBnZXQgY29weUZhY3RvcnlSb2xlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5jb3B5RmFjdG9yeVJvbGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIHJlc291cmNlIHNsb3RzIHRvIGFsbG9jYXRlIHRvIGFjY291bnQuIEFsbG9jYXRpbmcgZXh0cmEgcmVzb3VyY2Ugc2xvdHNcbiAgICogcmVzdWx0cyBpbiBiZXR0ZXIgYWNjb3VudCBwZXJmb3JtYW5jZSB1bmRlciBsb2FkIHdoaWNoIGlzIHVzZWZ1bCBmb3Igc29tZSBhcHBsaWNhdGlvbnMuIEUuZy4gaWYgeW91IGhhdmUgbWFueVxuICAgKiBhY2NvdW50cyBjb3B5aW5nIHRoZSBzYW1lIHN0cmF0ZWd5IHZpYSBDb295RmFjdG9yeSBBUEksIHRoZW4geW91IGNhbiBpbmNyZWFzZSByZXNvdXJjZVNsb3RzIHRvIGdldCBhIGxvd2VyIHRyYWRlXG4gICAqIGNvcHlpbmcgbGF0ZW5jeS4gUGxlYXNlIG5vdGUgdGhhdCBhbGxvY2F0aW5nIGV4dHJhIHJlc291cmNlIHNsb3RzIGlzIGEgcGFpZCBvcHRpb24uIFBsZWFzZSBub3RlIHRoYXQgaGlnaFxuICAgKiByZWxpYWJpbGl0eSBhY2NvdW50cyB1c2UgcmVkdW5kYW50IGluZnJhc3RydWN0dXJlLCBzbyB0aGF0IGVhY2ggcmVzb3VyY2Ugc2xvdCBmb3IgYSBoaWdoIHJlbGlhYmlsaXR5IGFjY291bnRcbiAgICogaXMgYmlsbGVkIGFzIDIgc3RhbmRhcmQgcmVzb3VyY2Ugc2xvdHMuICBEZWZhdWx0IGlzIDEuXG4gICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIHJlc291cmNlIHNsb3RzIHRvIGFsbG9jYXRlIHRvIGFjY291bnRcbiAgICovXG4gIGdldCByZXNvdXJjZVNsb3RzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlc291cmNlU2xvdHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIENvcHlGYWN0b3J5IDIgcmVzb3VyY2Ugc2xvdHMgdG8gYWxsb2NhdGUgdG8gYWNjb3VudC5cbiAgICogQWxsb2NhdGluZyBleHRyYSByZXNvdXJjZSBzbG90cyByZXN1bHRzIGluIGxvd2VyIHRyYWRlIGNvcHlpbmcgbGF0ZW5jeS4gUGxlYXNlIG5vdGUgdGhhdCBhbGxvY2F0aW5nIGV4dHJhIHJlc291cmNlXG4gICAqIHNsb3RzIGlzIGEgcGFpZCBvcHRpb24uIFBsZWFzZSBhbHNvIG5vdGUgdGhhdCBDb3B5RmFjdG9yeSAyIHVzZXMgcmVkdW5kYW50IGluZnJhc3RydWN0dXJlIHNvIHRoYXRcbiAgICogZWFjaCBDb3B5RmFjdG9yeSByZXNvdXJjZSBzbG90IGlzIGJpbGxlZCBhcyAyIHN0YW5kYXJkIHJlc291cmNlIHNsb3RzLiBZb3Ugd2lsbCBiZSBiaWxsZWQgZm9yIENvcHlGYWN0b3J5IDJcbiAgICogcmVzb3VyY2Ugc2xvdHMgb25seSBpZiB5b3UgaGF2ZSBhZGRlZCB5b3VyIGFjY291bnQgdG8gQ29weUZhY3RvcnkgMiBieSBzcGVjaWZ5aW5nIGNvcHlGYWN0b3J5Um9sZXMgZmllbGQuXG4gICAqIERlZmF1bHQgaXMgMS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBudW1iZXIgb2YgQ29weUZhY3RvcnkgMiByZXNvdXJjZSBzbG90cyB0byBhbGxvY2F0ZSB0byBhY2NvdW50XG4gICAqL1xuICBnZXQgY29weUZhY3RvcnlSZXNvdXJjZVNsb3RzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmNvcHlGYWN0b3J5UmVzb3VyY2VTbG90cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIDMtY2hhcmFjdGVyIElTTyBjdXJyZW5jeSBjb2RlIG9mIHRoZSBhY2NvdW50IGJhc2UgY3VycmVuY3kuIERlZmF1bHQgdmFsdWUgaXMgVVNELiBUaGUgc2V0dGluZyBpcyB0byBiZSB1c2VkXG4gICAqIGZvciBjb3B5IHRyYWRpbmcgYWNjb3VudHMgd2hpY2ggdXNlIG5hdGlvbmFsIGN1cnJlbmNpZXMgb25seSwgc3VjaCBhcyBzb21lIEJyYXppbGlhbiBicm9rZXJzLiBZb3Ugc2hvdWxkIG5vdCBhbHRlclxuICAgKiB0aGlzIHNldHRpbmcgdW5sZXNzIHlvdSB1bmRlcnN0YW5kIHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICogQHJldHVybiB7bnVtYmVyfSAzLWNoYXJhY3RlciBJU08gY3VycmVuY3kgY29kZSBvZiB0aGUgYWNjb3VudCBiYXNlIGN1cnJlbmN5XG4gICAqL1xuICBnZXQgYmFzZUN1cnJlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmJhc2VDdXJyZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHJlbGlhYmlsaXR5IHZhbHVlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIHJlZ3VsYXIgYW5kIGhpZ2hcbiAgICogQHJldHVybiB7U3RyaW5nfSBhY2NvdW50IHJlbGlhYmlsaXR5IHZhbHVlXG4gICAqL1xuICBnZXQgcmVsaWFiaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVsaWFiaWxpdHk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB2ZXJzaW9uIHZhbHVlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIDQgYW5kIDVcbiAgICogQHJldHVybiB7U3RyaW5nfSBhY2NvdW50IHZlcnNpb24gdmFsdWVcbiAgICovXG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHJlZ2lvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGFjY291bnQgcmVnaW9uIHZhbHVlXG4gICAqL1xuICBnZXQgcmVnaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlZ2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjdGl2ZSBhY2NvdW50IGNvbm5lY3Rpb25zXG4gICAqIEByZXR1cm4ge0FycmF5PEFjY291bnRDb25uZWN0aW9uPn0gYWN0aXZlIGFjY291bnQgY29ubmVjdGlvbnNcbiAgICovXG4gIGdldCBjb25uZWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5jb25uZWN0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZsYWcgaW5kaWNhdGluZyB0aGF0IHJpc2sgbWFuYWdlbWVudCBBUEkgaXMgZW5hYmxlZCBvbiBhY2NvdW50LiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBmbGFnIGluZGljYXRpbmcgdGhhdCByaXNrIG1hbmFnZW1lbnQgQVBJIGlzIGVuYWJsZWQgb24gYWNjb3VudFxuICAgKi9cbiAgZ2V0IHJpc2tNYW5hZ2VtZW50QXBpRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5yaXNrTWFuYWdlbWVudEFwaUVuYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB1c2VyIGlkXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdXNlciBpZFxuICAgKi9cbiAgZ2V0IHVzZXJJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS51c2VySWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHJlcGxpY2EgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJBY2NvdW50UmVwbGljYVtdfSBhY2NvdW50IHJlcGxpY2EgaW5zdGFuY2VzXG4gICAqL1xuICBnZXQgcmVwbGljYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGxpY2FzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBkaWN0aW9uYXJ5IHdpdGggYWNjb3VudCdzIGF2YWlsYWJsZSByZWdpb25zIGFuZCByZXBsaWNhc1xuICAgKiBAcmV0dXJucyB7W2lkOiBzdHJpbmddOiBzdHJpbmd9XG4gICAqL1xuICBnZXQgYWNjb3VudFJlZ2lvbnMoKSB7XG4gICAgY29uc3QgcmVnaW9ucyA9IHtbdGhpcy5yZWdpb25dOiB0aGlzLmlkfTtcbiAgICB0aGlzLnJlcGxpY2FzLmZvckVhY2gocmVwbGljYSA9PiByZWdpb25zW3JlcGxpY2EucmVnaW9uXSA9IHJlcGxpY2EuaWQpO1xuICAgIHJldHVybiByZWdpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbG9hZHMgTWV0YVRyYWRlciBhY2NvdW50IGZyb20gQVBJXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gTWV0YVRyYWRlciBhY2NvdW50IGlzIHVwZGF0ZWRcbiAgICovXG4gIGFzeW5jIHJlbG9hZCgpIHtcbiAgICB0aGlzLl9kYXRhID0gYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQuZ2V0QWNjb3VudCh0aGlzLmlkKTtcbiAgICBjb25zdCB1cGRhdGVkUmVwbGljYURhdGEgPSAodGhpcy5fZGF0YS5hY2NvdW50UmVwbGljYXMgfHwgW10pO1xuICAgIGNvbnN0IHJlZ2lvbnMgPSB1cGRhdGVkUmVwbGljYURhdGEubWFwKHJlcGxpY2EgPT4gcmVwbGljYS5yZWdpb24pO1xuICAgIGNvbnN0IGNyZWF0ZWRSZXBsaWNhUmVnaW9ucyA9IHRoaXMuX3JlcGxpY2FzLm1hcChyZXBsaWNhID0+IHJlcGxpY2EucmVnaW9uKTtcbiAgICB0aGlzLl9yZXBsaWNhcyA9IHRoaXMuX3JlcGxpY2FzLmZpbHRlcihyZXBsaWNhID0+IHJlZ2lvbnMuaW5jbHVkZXMocmVwbGljYS5yZWdpb24pKTtcbiAgICB0aGlzLl9yZXBsaWNhcy5mb3JFYWNoKHJlcGxpY2EgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSB1cGRhdGVkUmVwbGljYURhdGEuZmluZChyZXBsaWNhRGF0YSA9PiByZXBsaWNhRGF0YS5faWQgPT09IHJlcGxpY2EuaWQpO1xuICAgICAgcmVwbGljYS51cGRhdGVEYXRhKHVwZGF0ZWREYXRhKTtcbiAgICB9KTtcbiAgICB1cGRhdGVkUmVwbGljYURhdGEuZm9yRWFjaChyZXBsaWNhID0+IHtcbiAgICAgIGlmKCFjcmVhdGVkUmVwbGljYVJlZ2lvbnMuaW5jbHVkZXMocmVwbGljYS5yZWdpb24pKSB7XG4gICAgICAgIHRoaXMuX3JlcGxpY2FzLnB1c2gobmV3IE1ldGF0cmFkZXJBY2NvdW50UmVwbGljYShyZXBsaWNhLCB0aGlzLCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgTWV0YVRyYWRlciBhY2NvdW50LiBDbG91ZCBhY2NvdW50IHRyYW5zaXRpb25zIHRvIERFTEVUSU5HIHN0YXRlLiBcbiAgICogSXQgdGFrZXMgc29tZSB0aW1lIGZvciBhbiBhY2NvdW50IHRvIGJlIGV2ZW50dWFsbHkgZGVsZXRlZC4gU2VsZi1ob3N0ZWQgXG4gICAqIGFjY291bnQgaXMgZGVsZXRlZCBpbW1lZGlhdGVseS5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhY2NvdW50IGlzIHNjaGVkdWxlZCBmb3IgZGVsZXRpb25cbiAgICovXG4gIGFzeW5jIHJlbW92ZSgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkucmVtb3ZlKHRoaXMuaWQpO1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmRlbGV0ZUFjY291bnQodGhpcy5pZCk7XG4gICAgY29uc3QgZmlsZU1hbmFnZXIgPSBIaXN0b3J5RGF0YWJhc2UuZ2V0SW5zdGFuY2UoKTtcbiAgICBhd2FpdCBmaWxlTWFuYWdlci5jbGVhcih0aGlzLmlkLCB0aGlzLl9hcHBsaWNhdGlvbik7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3NlbGYtaG9zdGVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm5hbWUgIT09ICdOb3RGb3VuZEVycm9yJykge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYWNjb3VudCBmb3IgZGVwbG95bWVudC4gSXQgdGFrZXMgc29tZSB0aW1lIGZvciBBUEkgc2VydmVyIHRvIGJlIHN0YXJ0ZWQgYW5kIGFjY291bnQgdG8gcmVhY2ggdGhlIERFUExPWUVEXG4gICAqIHN0YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGFjY291bnQgaXMgc2NoZWR1bGVkIGZvciBkZXBsb3ltZW50XG4gICAqL1xuICBhc3luYyBkZXBsb3koKSB7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQuZGVwbG95QWNjb3VudCh0aGlzLmlkKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhY2NvdW50IGZvciB1bmRlcGxveW1lbnQuIEl0IHRha2VzIHNvbWUgdGltZSBmb3IgQVBJIHNlcnZlciB0byBiZSBzdG9wcGVkIGFuZCBhY2NvdW50IHRvIHJlYWNoIHRoZVxuICAgKiBVTkRFUExPWUVEIHN0YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGFjY291bnQgaXMgc2NoZWR1bGVkIGZvciB1bmRlcGxveW1lbnRcbiAgICovXG4gIGFzeW5jIHVuZGVwbG95KCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5yZW1vdmUodGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQudW5kZXBsb3lBY2NvdW50KHRoaXMuaWQpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVzIGFjY291bnQgZm9yIHJlZGVwbG95bWVudC4gSXQgdGFrZXMgc29tZSB0aW1lIGZvciBBUEkgc2VydmVyIHRvIGJlIHJlc3RhcnRlZCBhbmQgYWNjb3VudCB0byByZWFjaCB0aGVcbiAgICogREVQTE9ZRUQgc3RhdGVcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWNjb3VudCBpcyBzY2hlZHVsZWQgZm9yIHJlZGVwbG95bWVudFxuICAgKi9cbiAgYXN5bmMgcmVkZXBsb3koKSB7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQucmVkZXBsb3lBY2NvdW50KHRoaXMuaWQpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2VzIE1ldGFUcmFkZXIgYWNjb3VudCByZWxpYWJpbGl0eS4gVGhlIGFjY291bnQgd2lsbCBiZSB0ZW1wb3Jhcnkgc3RvcHBlZCB0byBwZXJmb3JtIHRoaXMgYWN0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGFjY291bnQgcmVsaWFiaWxpdHkgaXMgaW5jcmVhc2VkXG4gICAqL1xuICBhc3luYyBpbmNyZWFzZVJlbGlhYmlsaXR5KCkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmluY3JlYXNlUmVsaWFiaWxpdHkodGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCBBUEkgc2VydmVyIGhhcyBmaW5pc2hlZCBkZXBsb3ltZW50IGFuZCBhY2NvdW50IHJlYWNoZWQgdGhlIERFUExPWUVEIHN0YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0SW5TZWNvbmRzIHdhaXQgdGltZW91dCBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDVtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbEluTWlsbGlzZWNvbmRzIGludGVydmFsIGJldHdlZW4gYWNjb3VudCByZWxvYWRzIHdoaWxlIHdhaXRpbmcgZm9yIGEgY2hhbmdlLCBkZWZhdWx0IGlzIDFzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBhY2NvdW50IGlzIGRlcGxveWVkXG4gICAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gaWYgYWNjb3VudCBoYXZlIG5vdCByZWFjaGVkIHRoZSBERVBMT1lFRCBzdGF0ZSB3aXRoaW4gdGltZW91dCBhbGxvd2VkXG4gICAqL1xuICBhc3luYyB3YWl0RGVwbG95ZWQodGltZW91dEluU2Vjb25kcyA9IDMwMCwgaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IDEwMDApIHtcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSAnREVQTE9ZRUQnICYmIChzdGFydFRpbWUgKyB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCB0aGlzLl9kZWxheShpbnRlcnZhbEluTWlsbGlzZWNvbmRzKTtcbiAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSAnREVQTE9ZRUQnKSB7XG4gICAgICB0aHJvdyBuZXcgVGltZW91dEVycm9yKCdUaW1lZCBvdXQgd2FpdGluZyBmb3IgYWNjb3VudCAnICsgdGhpcy5pZCArICcgdG8gYmUgZGVwbG95ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgdW50aWwgQVBJIHNlcnZlciBoYXMgZmluaXNoZWQgdW5kZXBsb3ltZW50IGFuZCBhY2NvdW50IHJlYWNoZWQgdGhlIFVOREVQTE9ZRUQgc3RhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRJblNlY29uZHMgd2FpdCB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgNW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsSW5NaWxsaXNlY29uZHMgaW50ZXJ2YWwgYmV0d2VlbiBhY2NvdW50IHJlbG9hZHMgd2hpbGUgd2FpdGluZyBmb3IgYSBjaGFuZ2UsIGRlZmF1bHQgaXMgMXNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGFjY291bnQgaXMgZGVwbG95ZWRcbiAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBpZiBhY2NvdW50IGhhdmUgbm90IHJlYWNoZWQgdGhlIFVOREVQTE9ZRUQgc3RhdGUgd2l0aGluIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgd2FpdFVuZGVwbG95ZWQodGltZW91dEluU2Vjb25kcyA9IDMwMCwgaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IDEwMDApIHtcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSAnVU5ERVBMT1lFRCcgJiYgKHN0YXJ0VGltZSArIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSA+IERhdGUubm93KCkpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2RlbGF5KGludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdVTkRFUExPWUVEJykge1xuICAgICAgdGhyb3cgbmV3IFRpbWVvdXRFcnJvcignVGltZWQgb3V0IHdhaXRpbmcgZm9yIGFjY291bnQgJyArIHRoaXMuaWQgKyAnIHRvIGJlIHVuZGVwbG95ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgdW50aWwgYWNjb3VudCBoYXMgYmVlbiBkZWxldGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0SW5TZWNvbmRzIHdhaXQgdGltZW91dCBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDVtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbEluTWlsbGlzZWNvbmRzIGludGVydmFsIGJldHdlZW4gYWNjb3VudCByZWxvYWRzIHdoaWxlIHdhaXRpbmcgZm9yIGEgY2hhbmdlLCBkZWZhdWx0IGlzIDFzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBhY2NvdW50IGlzIGRlbGV0ZWRcbiAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBpZiBhY2NvdW50IHdhcyBub3QgZGVsZXRlZCB3aXRoaW4gdGltZW91dCBhbGxvd2VkXG4gICAqL1xuICBhc3luYyB3YWl0UmVtb3ZlZCh0aW1lb3V0SW5TZWNvbmRzID0gMzAwLCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gMTAwMCkge1xuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgd2hpbGUgKHN0YXJ0VGltZSArIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwID4gRGF0ZS5ub3coKSkge1xuICAgICAgICBhd2FpdCB0aGlzLl9kZWxheShpbnRlcnZhbEluTWlsbGlzZWNvbmRzKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBhY2NvdW50ICcgKyB0aGlzLmlkICsgJyB0byBiZSBkZWxldGVkJyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIHVudGlsIEFQSSBzZXJ2ZXIgaGFzIGNvbm5lY3RlZCB0byB0aGUgdGVybWluYWwgYW5kIHRlcm1pbmFsIGhhcyBjb25uZWN0ZWQgdG8gdGhlIGJyb2tlclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dEluU2Vjb25kcyB3YWl0IHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyA1bVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyBpbnRlcnZhbCBiZXR3ZWVuIGFjY291bnQgcmVsb2FkcyB3aGlsZSB3YWl0aW5nIGZvciBhIGNoYW5nZSwgZGVmYXVsdCBpcyAxc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gQVBJIHNlcnZlciBpcyBjb25uZWN0ZWQgdG8gdGhlIGJyb2tlclxuICAgKiBAdGhyb3dzIHtUaW1lb3V0RXJyb3J9IGlmIGFjY291bnQgaGF2ZSBub3QgY29ubmVjdGVkIHRvIHRoZSBicm9rZXIgd2l0aGluIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgd2FpdENvbm5lY3RlZCh0aW1lb3V0SW5TZWNvbmRzID0gMzAwLCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gMTAwMCkge1xuICAgIGNvbnN0IGNoZWNrQ29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbm5lY3Rpb25TdGF0dXNdLmNvbmNhdCh0aGlzLnJlcGxpY2FzLm1hcChyZXBsaWNhID0+IFxuICAgICAgICByZXBsaWNhLmNvbm5lY3Rpb25TdGF0dXMpKS5pbmNsdWRlcygnQ09OTkVDVEVEJyk7XG4gICAgfTtcblxuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgd2hpbGUgKCFjaGVja0Nvbm5lY3RlZCgpICYmIChzdGFydFRpbWUgKyB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCB0aGlzLl9kZWxheShpbnRlcnZhbEluTWlsbGlzZWNvbmRzKTtcbiAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgfVxuICAgIGlmICghY2hlY2tDb25uZWN0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IFRpbWVvdXRFcnJvcignVGltZWQgb3V0IHdhaXRpbmcgZm9yIGFjY291bnQgJyArIHRoaXMuaWQgKyAnIHRvIGNvbm5lY3QgdG8gdGhlIGJyb2tlcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byBNZXRhQXBpLiBUaGVyZSBpcyBvbmx5IG9uZSBjb25uZWN0aW9uIHBlciBhY2NvdW50LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7SGlzdG9yeVN0b3JhZ2V9IGhpc3RvcnlTdG9yYWdlIG9wdGlvbmFsIGhpc3Rvcnkgc3RvcmFnZVxuICAgKiBAcGFyYW0ge0RhdGV9IFtoaXN0b3J5U3RhcnRUaW1lXSBoaXN0b3J5IHN0YXJ0IHRpbWUuIFVzZWQgZm9yIHRlc3RzXG4gICAqIEByZXR1cm4ge1N0cmVhbWluZ01ldGFBcGlDb25uZWN0aW9ufSBNZXRhQXBpIGNvbm5lY3Rpb25cbiAgICovXG4gIGdldFN0cmVhbWluZ0Nvbm5lY3Rpb24oaGlzdG9yeVN0b3JhZ2UsIGhpc3RvcnlTdGFydFRpbWUpIHtcbiAgICBpZih0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbiAmJiB0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbiAhPT0gdGhpcy5yZWdpb24pIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgIGBBY2NvdW50ICR7dGhpcy5pZH0gaXMgbm90IG9uIHNwZWNpZmllZCByZWdpb24gJHt0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbn1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LmNvbm5lY3QodGhpcywgaGlzdG9yeVN0b3JhZ2UsIGhpc3RvcnlTdGFydFRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIE1ldGFBcGkgdmlhIFJQQyBjb25uZWN0aW9uLlxuICAgKiBAcmV0dXJucyB7UnBjTWV0YUFwaUNvbm5lY3Rpb259IE1ldGFBcGkgY29ubmVjdGlvblxuICAgKi9cbiAgZ2V0UlBDQ29ubmVjdGlvbigpIHtcbiAgICBpZih0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbiAmJiB0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbiAhPT0gdGhpcy5yZWdpb24pIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgIGBBY2NvdW50ICR7dGhpcy5pZH0gaXMgbm90IG9uIHNwZWNpZmllZCByZWdpb24gJHt0aGlzLl9tZXRhQXBpV2Vic29ja2V0Q2xpZW50LnJlZ2lvbn1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJwY01ldGFBcGlDb25uZWN0aW9uKHRoaXMuX21ldGFBcGlXZWJzb2NrZXRDbGllbnQsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgTWV0YVRyYWRlciBhY2NvdW50IGRhdGFcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyQWNjb3VudFVwZGF0ZUR0b30gYWNjb3VudCBNZXRhVHJhZGVyIGFjY291bnQgdXBkYXRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWNjb3VudCBpcyB1cGRhdGVkXG4gICAqL1xuICBhc3luYyB1cGRhdGUoYWNjb3VudCkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LnVwZGF0ZUFjY291bnQodGhpcy5pZCwgYWNjb3VudCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTWV0YVRyYWRlciBhY2NvdW50IHJlcGxpY2FcbiAgICogQHBhcmFtIHtOZXdNZXRhdHJhZGVyQWNjb3VudER0b30gcmVwbGljYSBNZXRhVHJhZGVyIGFjY291bnQgcmVwbGljYSBkYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TWV0YXRyYWRlckFjY291bnRSZXBsaWNhPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBNZXRhVHJhZGVyIGFjY291bnQgcmVwbGljYSBlbnRpdHlcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVJlcGxpY2EocmVwbGljYSkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmNyZWF0ZUFjY291bnRSZXBsaWNhKHRoaXMuaWQsIHJlcGxpY2EpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGxpY2FzLmZpbmQociA9PiByLnJlZ2lvbiA9PT0gcmVwbGljYS5yZWdpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBleHBlcnQgYWR2aXNvciBvZiBjdXJyZW50IGFjY291bnRcbiAgICogQHJldHVybnMge1Byb21pc2U8RXhwZXJ0QWR2aXNvcltdPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhbiBhcnJheSBvZiBleHBlcnQgYWR2aXNvciBlbnRpdGllc1xuICAgKi9cbiAgYXN5bmMgZ2V0RXhwZXJ0QWR2aXNvcnMoKSB7XG4gICAgdGhpcy5fY2hlY2tFeHBlcnRBZHZpc29yQWxsb3dlZCgpO1xuICAgIGxldCBleHBlcnRBZHZpc29ycyA9IGF3YWl0IHRoaXMuX2V4cGVydEFkdmlzb3JDbGllbnQuZ2V0RXhwZXJ0QWR2aXNvcnModGhpcy5pZCk7XG4gICAgcmV0dXJuIGV4cGVydEFkdmlzb3JzLm1hcChlID0+IG5ldyBFeHBlcnRBZHZpc29yKGUsIHRoaXMuaWQsIHRoaXMuX2V4cGVydEFkdmlzb3JDbGllbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBleHBlcnQgYWR2aXNvciBvZiBjdXJyZW50IGFjY291bnQgYnkgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cGVydElkIGV4cGVydCBhZHZpc29yIGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEV4cGVydEFkdmlzb3I+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGV4cGVydCBhZHZpc29yIGVudGl0eVxuICAgKi9cbiAgYXN5bmMgZ2V0RXhwZXJ0QWR2aXNvcihleHBlcnRJZCkge1xuICAgIHRoaXMuX2NoZWNrRXhwZXJ0QWR2aXNvckFsbG93ZWQoKTtcbiAgICBsZXQgZXhwZXJ0QWR2aXNvciA9IGF3YWl0IHRoaXMuX2V4cGVydEFkdmlzb3JDbGllbnQuZ2V0RXhwZXJ0QWR2aXNvcih0aGlzLmlkLCBleHBlcnRJZCk7XG4gICAgcmV0dXJuIG5ldyBFeHBlcnRBZHZpc29yKGV4cGVydEFkdmlzb3IsIHRoaXMuaWQsIHRoaXMuX2V4cGVydEFkdmlzb3JDbGllbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXhwZXJ0IGFkdmlzb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cGVydElkIGV4cGVydCBhZHZpc29yIGlkXG4gICAqIEBwYXJhbSB7TmV3RXhwZXJ0QWR2aXNvckR0b30gZXhwZXJ0IGV4cGVydCBhZHZpc29yIGRhdGFcbiAgICogQHJldHVybnMge1Byb21pc2U8RXhwZXJ0QWR2aXNvcj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggZXhwZXJ0IGFkdmlzb3IgZW50aXR5XG4gICAqL1xuICBhc3luYyBjcmVhdGVFeHBlcnRBZHZpc29yKGV4cGVydElkLCBleHBlcnQpIHtcbiAgICB0aGlzLl9jaGVja0V4cGVydEFkdmlzb3JBbGxvd2VkKCk7XG4gICAgYXdhaXQgdGhpcy5fZXhwZXJ0QWR2aXNvckNsaWVudC51cGRhdGVFeHBlcnRBZHZpc29yKHRoaXMuaWQsIGV4cGVydElkLCBleHBlcnQpO1xuICAgIHJldHVybiB0aGlzLmdldEV4cGVydEFkdmlzb3IoZXhwZXJ0SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yaWNhbCBjYW5kbGVzIGZvciBhIHNwZWNpZmljIHN5bWJvbCBhbmQgdGltZWZyYW1lIGZyb20gdGhlIE1ldGFUcmFkZXIgYWNjb3VudC5cbiAgICogU2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9yZXN0QXBpL2FwaS9yZXRyaWV2ZU1hcmtldERhdGEvcmVhZEhpc3RvcmljYWxDYW5kbGVzL1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBjYW5kbGVzIGZvciAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lZnJhbWUgZGVmaW5lcyB0aGUgdGltZWZyYW1lIGFjY29yZGluZyB0byB3aGljaCB0aGUgY2FuZGxlcyBtdXN0IGJlIGdlbmVyYXRlZC4gQWxsb3dlZCB2YWx1ZXNcbiAgICogZm9yIE1UNSBhcmUgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW4uIEFsbG93ZWRcbiAgICogdmFsdWVzIGZvciBNVDQgYXJlIDFtLCA1bSwgMTVtIDMwbSwgMWgsIDRoLCAxZCwgMXcsIDFtblxuICAgKiBAcGFyYW0ge0RhdGV9IFtzdGFydFRpbWVdIHRpbWUgdG8gc3RhcnQgbG9hZGluZyBjYW5kbGVzIGZyb20uIE5vdGUgdGhhdCBjYW5kbGVzIGFyZSBsb2FkZWQgaW4gYmFja3dhcmRzIGRpcmVjdGlvbiwgc29cbiAgICogdGhpcyBzaG91bGQgYmUgdGhlIGxhdGVzdCB0aW1lLiBMZWF2ZSBlbXB0eSB0byByZXF1ZXN0IGxhdGVzdCBjYW5kbGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBtYXhpbXVtIG51bWJlciBvZiBjYW5kbGVzIHRvIHJldHJpZXZlLiBNdXN0IGJlIGxlc3Mgb3IgZXF1YWwgdG8gMTAwMFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE1ldGF0cmFkZXJDYW5kbGU+Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBoaXN0b3JpY2FsIGNhbmRsZXMgZG93bmxvYWRlZFxuICAgKi9cbiAgZ2V0SGlzdG9yaWNhbENhbmRsZXMoc3ltYm9sLCB0aW1lZnJhbWUsIHN0YXJ0VGltZSwgbGltaXQpIHtcbiAgICByZXR1cm4gdGhpcy5faGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQuZ2V0SGlzdG9yaWNhbENhbmRsZXModGhpcy5pZCwgdGhpcy5yZWdpb24sIHN5bWJvbCxcbiAgICAgIHRpbWVmcmFtZSwgc3RhcnRUaW1lLCBsaW1pdCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcmljYWwgdGlja3MgZm9yIGEgc3BlY2lmaWMgc3ltYm9sIGZyb20gdGhlIE1ldGFUcmFkZXIgYWNjb3VudC4gVGhpcyBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSBNVDRcbiAgICogYWNjb3VudHMuXG4gICAqIFNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvcmVzdEFwaS9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRIaXN0b3JpY2FsVGlja3MvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHRpY2tzIGZvciAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0VGltZV0gdGltZSB0byBzdGFydCBsb2FkaW5nIHRpY2tzIGZyb20uIE5vdGUgdGhhdCBjYW5kbGVzIGFyZSBsb2FkZWQgaW4gZm9yd2FyZCBkaXJlY3Rpb24sIHNvXG4gICAqIHRoaXMgc2hvdWxkIGJlIHRoZSBlYXJsaWVzdCB0aW1lLiBMZWF2ZSBlbXB0eSB0byByZXF1ZXN0IGxhdGVzdCBjYW5kbGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldF0gbnVtYmVyIG9mIHRpY2tzIHRvIHNraXAgKHlvdSBjYW4gdXNlIGl0IHRvIGF2b2lkIHJlcXVlc3RpbmcgdGlja3MgZnJvbSBwcmV2aW91cyByZXF1ZXN0XG4gICAqIHR3aWNlKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byByZXRyaWV2ZS4gTXVzdCBiZSBsZXNzIG9yIGVxdWFsIHRvIDEwMDBcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyVGljaz4+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGhpc3RvcmljYWwgdGlja3MgZG93bmxvYWRlZFxuICAgKi9cbiAgZ2V0SGlzdG9yaWNhbFRpY2tzKHN5bWJvbCwgc3RhcnRUaW1lLCBvZmZzZXQsIGxpbWl0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50LmdldEhpc3RvcmljYWxUaWNrcyh0aGlzLmlkLCB0aGlzLnJlZ2lvbiwgc3ltYm9sLCBzdGFydFRpbWUsIG9mZnNldCwgbGltaXQpO1xuICB9XG5cbiAgX2NoZWNrRXhwZXJ0QWR2aXNvckFsbG93ZWQoKSB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiAhPT0gNCB8fCB0aGlzLnR5cGUgIT09ICdjbG91ZC1nMScpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0N1c3RvbSBleHBlcnQgYWR2aXNvciBpcyBhdmFpbGFibGUgb25seSBmb3IgTVQ0IEcxIGFjY291bnRzJyk7XG4gICAgfVxuICB9XG5cbiAgX2RlbGF5KHRpbWVvdXRJbk1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIHRpbWVvdXRJbk1pbGxpc2Vjb25kcykpO1xuICB9XG5cbn1cbiJdfQ==