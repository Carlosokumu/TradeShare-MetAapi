'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _terminalState = require('./terminalState');

var _terminalState2 = _interopRequireDefault(_terminalState);

var _memoryHistoryStorage = require('./memoryHistoryStorage');

var _memoryHistoryStorage2 = _interopRequireDefault(_memoryHistoryStorage);

var _timeoutError = require('../clients/timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _randomstring = require('randomstring');

var _randomstring2 = _interopRequireDefault(_randomstring);

var _connectionHealthMonitor = require('./connectionHealthMonitor');

var _connectionHealthMonitor2 = _interopRequireDefault(_connectionHealthMonitor);

var _errorHandler = require('../clients/errorHandler');

var _optionsValidator = require('../clients/optionsValidator');

var _optionsValidator2 = _interopRequireDefault(_optionsValidator);

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var _metaApiConnection = require('./metaApiConnection');

var _metaApiConnection2 = _interopRequireDefault(_metaApiConnection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Exposes MetaApi MetaTrader streaming API connection to consumers
 */
class StreamingMetaApiConnection extends _metaApiConnection2.default {

  /**
   * Constructs MetaApi MetaTrader streaming Api connection
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {ClientApiClient} clientApiClient client api client
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   * @param {HistoryStorage} historyStorage terminal history storage. By default an instance of MemoryHistoryStorage
   * will be used.
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {Date} [historyStartTime] history start sync time
   * @param {RefreshSubscriptionsOpts} [refreshSubscriptionsOpts] subscriptions refresh options
   */
  constructor(websocketClient, clientApiClient, account, historyStorage, connectionRegistry, historyStartTime, refreshSubscriptionsOpts) {
    super(websocketClient, account);
    refreshSubscriptionsOpts = refreshSubscriptionsOpts || {};
    const validator = new _optionsValidator2.default();
    this._minSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.minDelayInSeconds, 1, 'refreshSubscriptionsOpts.minDelayInSeconds');
    this._maxSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.maxDelayInSeconds, 600, 'refreshSubscriptionsOpts.maxDelayInSeconds');
    this._connectionRegistry = connectionRegistry;
    this._historyStartTime = historyStartTime;
    this._terminalState = new _terminalState2.default(this._account.id, clientApiClient);
    this._historyStorage = historyStorage || new _memoryHistoryStorage2.default();
    this._healthMonitor = new _connectionHealthMonitor2.default(this);
    this._websocketClient.addSynchronizationListener(account.id, this);
    this._websocketClient.addSynchronizationListener(account.id, this._terminalState);
    this._websocketClient.addSynchronizationListener(account.id, this._historyStorage);
    this._websocketClient.addSynchronizationListener(account.id, this._healthMonitor);
    (0, _values2.default)(account.accountRegions).forEach(replicaId => this._websocketClient.addReconnectListener(this, replicaId));
    this._subscriptions = {};
    this._stateByInstanceIndex = {};
    this._refreshMarketDataSubscriptionSessions = {};
    this._refreshMarketDataSubscriptionTimeouts = {};
    this._synchronizationListeners = [];
    this._logger = _logger2.default.getLogger('MetaApiConnection');
  }

  /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @return {Promise} promise resolving when the connection is opened
   */
  async connect() {
    if (!this._opened) {
      this._logger.trace(`${this._account.id}: Opening connection`);
      this._opened = true;
      try {
        await this.initialize();
        await this.subscribe();
      } catch (err) {
        await this.close();
        throw err;
      }
    }
  }

  /**
   * Clears the order and transaction history of a specified application and removes application (see
   * https://metaapi.cloud/docs/client/websocket/api/removeApplication/).
   * @return {Promise} promise resolving when the history is cleared and application is removed
   */
  removeApplication() {
    this._checkIsConnectionActive();
    this._historyStorage.clear();
    return this._websocketClient.removeApplication(this._account.id);
  }

  /**
   * Requests the terminal to start synchronization process
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/)
   * @param {String} instanceIndex instance index
   * @returns {Promise} promise which resolves when synchronization started
   */
  async synchronize(instanceIndex) {
    this._checkIsConnectionActive();
    const region = this.getRegion(instanceIndex);
    const instance = this.getInstanceNumber(instanceIndex);
    const host = this.getHostName(instanceIndex);
    let startingHistoryOrderTime = new Date(Math.max((this._historyStartTime || new Date(0)).getTime(), (await this._historyStorage.lastHistoryOrderTime(instance)).getTime()));
    let startingDealTime = new Date(Math.max((this._historyStartTime || new Date(0)).getTime(), (await this._historyStorage.lastDealTime(instance)).getTime()));
    let synchronizationId = _randomstring2.default.generate(32);
    this._getState(instanceIndex).lastSynchronizationId = synchronizationId;
    const accountId = this._account.accountRegions[region];
    this._logger.debug(`${this._account.id}:${instanceIndex}: initiating synchronization ${synchronizationId}`);
    return this._websocketClient.synchronize(accountId, instance, host, synchronizationId, startingHistoryOrderTime, startingDealTime, async () => await this.terminalState.getHashes(this._account.type, instanceIndex));
  }

  /**
   * Initializes meta api connection
   * @return {Promise} promise which resolves when meta api connection is initialized
   */
  async initialize() {
    this._checkIsConnectionActive();
    await this._historyStorage.initialize(this._account.id, this._connectionRegistry.application);
    this._websocketClient.addAccountCache(this._account.id, this._account.accountRegions);
  }

  /**
   * Initiates subscription to MetaTrader terminal
   * @returns {Promise} promise which resolves when subscription is initiated
   */
  async subscribe() {
    this._checkIsConnectionActive();
    const accountRegions = this._account.accountRegions;
    (0, _values2.default)(accountRegions).forEach(replicaId => {
      this._websocketClient.ensureSubscribe(replicaId, 0);
      this._websocketClient.ensureSubscribe(replicaId, 1);
    });
  }

  /**
   * Subscribes on market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update. Please
   * note that this feature is not fully implemented on server-side yet
   * @param {number} [timeoutInSeconds] timeout to wait for prices in seconds, default is 30
   * @returns {Promise} promise which resolves when subscription request was processed
   */
  async subscribeToMarketData(symbol, subscriptions, timeoutInSeconds) {
    this._checkIsConnectionActive();
    if (!this._terminalState.specification(symbol)) {
      throw new _errorHandler.ValidationError(`Cannot subscribe to market data for symbol ${symbol} because ` + 'symbol does not exist');
    } else {
      subscriptions = subscriptions || [{ type: 'quotes' }];
      if (this._subscriptions[symbol]) {
        const prevSubscriptions = this._subscriptions[symbol].subscriptions;
        subscriptions.forEach(subscription => {
          const index = subscription.type === 'candles' ? prevSubscriptions.findIndex(item => item.type === subscription.type && item.timeframe === subscription.timeframe) : prevSubscriptions.findIndex(item => item.type === subscription.type);
          if (index === -1) {
            prevSubscriptions.push(subscription);
          } else {
            prevSubscriptions[index] = subscription;
          }
        });
      } else {
        this._subscriptions[symbol] = { subscriptions };
      }
      await this._websocketClient.subscribeToMarketData(this._account.id, symbol, subscriptions, this._account.reliability);
      return this.terminalState.waitForPrice(symbol, timeoutInSeconds);
    }
  }

  /**
   * Unsubscribes from market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */
  unsubscribeFromMarketData(symbol, subscriptions) {
    this._checkIsConnectionActive();
    if (!subscriptions) {
      delete this._subscriptions[symbol];
    } else if (this._subscriptions[symbol]) {
      this._subscriptions[symbol].subscriptions = this._subscriptions[symbol].subscriptions.filter(s => s.type === 'candles' ? !subscriptions.find(s2 => s.type === s2.type && s.timeframe === s2.timeframe) : !subscriptions.find(s2 => s.type === s2.type));
      if (!this._subscriptions[symbol].subscriptions.length) {
        delete this._subscriptions[symbol];
      }
    }
    return this._websocketClient.unsubscribeFromMarketData(this._account.id, symbol, subscriptions, this._account.reliability);
  }

  /**
   * Invoked when subscription downgrade has occurred
   * @param {String} instanceIndex index of an account instance connected
   * @param {string} symbol symbol to update subscriptions for
   * @param {Array<MarketDataSubscription>} updates array of market data subscription to update
   * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  // eslint-disable-next-line complexity
  async onSubscriptionDowngraded(instanceIndex, symbol, updates, unsubscriptions) {
    let subscriptions = this._subscriptions[symbol] || [];
    if (unsubscriptions && unsubscriptions.length) {
      if (subscriptions) {
        for (let subscription of unsubscriptions) {
          subscriptions = subscriptions.filter(s => s.type === subscription.type);
        }
      }
      this.unsubscribeFromMarketData(symbol, unsubscriptions).catch(err => {
        if (err.name !== _errorHandler.ValidationError) {
          this._logger.error(`${this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
        } else {
          this._logger.trace(`${this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
        }
      });
    }
    if (updates && updates.length) {
      if (subscriptions) {
        for (let subscription of updates) {
          subscriptions.filter(s => s.type === subscription.type).forEach(s => s.intervalInMilliiseconds = subscription.intervalInMilliseconds);
        }
      }
      this.subscribeToMarketData(symbol, updates).catch(err => {
        this._logger.error(`${this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
      });
    }
    if (subscriptions && !subscriptions.length) {
      delete this._subscriptions[symbol];
    }
  }

  /**
   * Returns list of the symbols connection is subscribed to
   * @returns {Array<String>} list of the symbols connection is subscribed to
   */
  get subscribedSymbols() {
    return (0, _keys2.default)(this._subscriptions);
  }

  /**
   * Returns subscriptions for a symbol
   * @param {string} symbol symbol to retrieve subscriptions for
   * @returns {Array<MarketDataSubscription>} list of market data subscriptions for the symbol
   */
  subscriptions(symbol) {
    this._checkIsConnectionActive();
    return (this._subscriptions[symbol] || {}).subscriptions;
  }

  /**
   * Sends client uptime stats to the server.
   * @param {Object} uptime uptime statistics to send to the server
   * @returns {Promise} promise which resolves when uptime statistics is submitted
   */
  saveUptime(uptime) {
    this._checkIsConnectionActive();
    return this._websocketClient.saveUptime(this._account.id, uptime);
  }

  /**
   * Returns local copy of terminal state
   * @returns {TerminalState} local copy of terminal state
   */
  get terminalState() {
    return this._terminalState;
  }

  /**
   * Returns local history storage
   * @returns {HistoryStorage} local history storage
   */
  get historyStorage() {
    return this._historyStorage;
  }

  /**
   * Adds synchronization listener
   * @param {SynchronizationListener} listener synchronization listener to add
   */
  addSynchronizationListener(listener) {
    this._synchronizationListeners.push(listener);
    this._websocketClient.addSynchronizationListener(this._account.id, listener);
  }

  /**
   * Removes synchronization listener for specific account
   * @param {SynchronizationListener} listener synchronization listener to remove
   */
  removeSynchronizationListener(listener) {
    this._synchronizationListeners = this._synchronizationListeners.filter(l => l !== listener);
    this._websocketClient.removeSynchronizationListener(this._account.id, listener);
  }

  /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   * @param {Number} replicas number of account replicas launched
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onConnected(instanceIndex, replicas) {
    let key = _randomstring2.default.generate(32);
    let state = this._getState(instanceIndex);
    state.shouldSynchronize = key;
    state.synchronizationRetryIntervalInSeconds = 1;
    state.synchronized = false;
    this._ensureSynchronized(instanceIndex, key);
    this._logger.debug(`${this._account.id}:${instanceIndex}: connected to broker`);
  }

  /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */
  async onDisconnected(instanceIndex) {
    let state = this._getState(instanceIndex);
    state.lastDisconnectedSynchronizationId = state.lastSynchronizationId;
    state.lastSynchronizationId = undefined;
    state.shouldSynchronize = undefined;
    state.synchronized = false;
    state.disconnected = true;
    const instanceNumber = this.getInstanceNumber(instanceIndex);
    const region = this.getRegion(instanceIndex);
    const instance = `${region}:${instanceNumber}`;
    delete this._refreshMarketDataSubscriptionSessions[instance];
    clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instance]);
    delete this._refreshMarketDataSubscriptionTimeouts[instance];
    if (state.synchronizationTimeout) {
      clearTimeout(state.synchronizationTimeout);
      delete state.synchronizationTimeout;
    }
    if (state.ensureSynchronizeTimeout) {
      clearTimeout(state.ensureSynchronizeTimeout);
      delete state.ensureSynchronizeTimeout;
    }
    this._logger.debug(`${this._account.id}:${instanceIndex}: disconnected from broker`);
  }

  /**
   * Invoked when a symbol specifications were updated
   * @param {String} instanceIndex index of account instance connected
   * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
   * @param {Array<String>} removedSymbols removed symbols
   */
  onSymbolSpecificationsUpdated(instanceIndex, specifications, removedSymbols) {
    this._scheduleSynchronizationTimeout(instanceIndex);
  }

  /**
   * Invoked when position synchronization finished to indicate progress of an initial terminal state synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */
  onPositionsSynchronized(instanceIndex, synchronizationId) {
    this._scheduleSynchronizationTimeout(instanceIndex);
  }

  /**
   * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
   * synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */
  onPendingOrdersSynchronized(instanceIndex, synchronizationId) {
    this._scheduleSynchronizationTimeout(instanceIndex);
  }

  /**
   * Invoked when a synchronization of history deals on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onDealsSynchronized(instanceIndex, synchronizationId) {
    let state = this._getState(instanceIndex);
    state.dealsSynchronized[synchronizationId] = true;
    this._scheduleSynchronizationTimeout(instanceIndex);
    this._logger.debug(`${this._account.id}:${instanceIndex}: finished synchronization ${synchronizationId}`);
  }

  /**
   * Invoked when a synchronization of history orders on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onHistoryOrdersSynchronized(instanceIndex, synchronizationId) {
    let state = this._getState(instanceIndex);
    state.ordersSynchronized[synchronizationId] = true;
    this._scheduleSynchronizationTimeout(instanceIndex);
  }

  /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect
   * @param {String} region reconnected region
   * @param {Number} instanceNumber reconnected instance number
   * @return {Promise} promise which resolves when connection to MetaApi websocket API restored after a disconnect
   */
  async onReconnected(region, instanceNumber) {
    const instanceTemplate = `${region}:${instanceNumber}`;
    (0, _keys2.default)(this._stateByInstanceIndex).filter(key => key.startsWith(`${instanceTemplate}:`)).forEach(key => {
      delete this._stateByInstanceIndex[key];
    });
    delete this._refreshMarketDataSubscriptionSessions[instanceTemplate];
    clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instanceTemplate]);
    delete this._refreshMarketDataSubscriptionTimeouts[instanceTemplate];
  }

  /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onStreamClosed(instanceIndex) {
    delete this._stateByInstanceIndex[instanceIndex];
  }

  /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {String} instanceIndex index of an account instance connected
   * @param {Boolean} specificationsUpdated whether specifications are going to be updated during synchronization
   * @param {Boolean} positionsUpdated whether positions are going to be updated during synchronization
   * @param {Boolean} ordersUpdated whether orders are going to be updated during synchronization
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onSynchronizationStarted(instanceIndex, specificationsUpdated, positionsUpdated, ordersUpdated, synchronizationId) {
    this._logger.debug(`${this._account.id}:${instanceIndex}: starting synchronization ${synchronizationId}`);
    const instanceNumber = this.getInstanceNumber(instanceIndex);
    const region = this.getRegion(instanceIndex);
    const instance = `${region}:${instanceNumber}`;
    const accountId = this._account.accountRegions[region];
    delete this._refreshMarketDataSubscriptionSessions[instance];
    let sessionId = _randomstring2.default.generate(32);
    this._refreshMarketDataSubscriptionSessions[instance] = sessionId;
    clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instance]);
    delete this._refreshMarketDataSubscriptionTimeouts[instance];
    await this._refreshMarketDataSubscriptions(accountId, instanceNumber, sessionId);
    this._scheduleSynchronizationTimeout(instanceIndex);
    let state = this._getState(instanceIndex);
    if (state && !this._closed) {
      state.lastSynchronizationId = synchronizationId;
    }
  }

  /**
   * Invoked when account region has been unsubscribed
   * @param {String} region account region unsubscribed
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onUnsubscribeRegion(region) {
    (0, _keys2.default)(this._refreshMarketDataSubscriptionTimeouts).filter(instance => instance.startsWith(`${region}:`)).forEach(instance => {
      clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instance]);
      delete this._refreshMarketDataSubscriptionTimeouts[instance];
      delete this._refreshMarketDataSubscriptionSessions[instance];
    });
    (0, _keys2.default)(this._stateByInstanceIndex).filter(instance => instance.startsWith(`${region}:`)).forEach(instance => delete this._stateByInstanceIndex[instance]);
  }

  /**
   * Returns flag indicating status of state synchronization with MetaTrader terminal
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId optional synchronization request id, last synchronization request id will be used
   * by default
   * @return {Promise<Boolean>} promise resolving with a flag indicating status of state synchronization with MetaTrader
   * terminal
   */
  async isSynchronized(instanceIndex, synchronizationId) {
    return (0, _values2.default)(this._stateByInstanceIndex).reduce((acc, s) => {
      if (instanceIndex !== undefined && s.instanceIndex !== instanceIndex) {
        return acc;
      }
      const checkSynchronizationId = synchronizationId || s.lastSynchronizationId;
      let synchronized = !!s.ordersSynchronized[checkSynchronizationId] && !!s.dealsSynchronized[checkSynchronizationId];
      return acc || synchronized;
    }, false);
  }

  /**
   * @typedef {Object} SynchronizationOptions
   * @property {String} [applicationPattern] application regular expression pattern, default is .*
   * @property {String} [synchronizationId] synchronization id, last synchronization request id will be used by
   * default
   * @property {Number} [instanceIndex] index of an account instance to ensure synchronization on, default is to wait
   * for the first instance to synchronize
   * @param {Number} [timeoutInSeconds] wait timeout in seconds, default is 5m
   * @param {Number} [intervalInMilliseconds] interval between account reloads while waiting for a change, default is 1s
   */

  /**
   * Waits until synchronization to MetaTrader terminal is completed
   * @param {SynchronizationOptions} synchronization options
   * @return {Promise} promise which resolves when synchronization to MetaTrader terminal is completed
   * @throws {TimeoutError} if application failed to synchronize with the teminal within timeout allowed
   */
  // eslint-disable-next-line complexity
  async waitSynchronized(opts) {
    this._checkIsConnectionActive();
    opts = opts || {};
    let instanceIndex = opts.instanceIndex;
    let synchronizationId = opts.synchronizationId;
    let timeoutInSeconds = opts.timeoutInSeconds || 300;
    let intervalInMilliseconds = opts.intervalInMilliseconds || 1000;
    let applicationPattern = opts.applicationPattern || (this._account.application === 'CopyFactory' ? 'CopyFactory.*|RPC' : 'RPC');
    let startTime = Date.now();
    let synchronized;
    while (!(synchronized = await this.isSynchronized(instanceIndex, synchronizationId)) && startTime + timeoutInSeconds * 1000 > Date.now()) {
      await new _promise2.default(res => setTimeout(res, intervalInMilliseconds));
    }
    let state;
    if (instanceIndex === undefined) {
      for (let s of (0, _values2.default)(this._stateByInstanceIndex)) {
        if (await this.isSynchronized(s.instanceIndex, synchronizationId)) {
          state = s;
          instanceIndex = s.instanceIndex;
        }
      }
    } else {
      state = (0, _values2.default)(this._stateByInstanceIndex).find(s => s.instanceIndex === instanceIndex);
    }
    if (!synchronized) {
      throw new _timeoutError2.default('Timed out waiting for MetaApi to synchronize to MetaTrader account ' + this._account.id + ', synchronization id ' + (synchronizationId || state && state.lastSynchronizationId || state && state.lastDisconnectedSynchronizationId));
    }
    let timeLeftInSeconds = Math.max(0, timeoutInSeconds - (Date.now() - startTime) / 1000);
    const region = this.getRegion(state.instanceIndex);
    const accountId = this._account.accountRegions[region];
    await this._websocketClient.waitSynchronized(accountId, this.getInstanceNumber(instanceIndex), applicationPattern, timeLeftInSeconds);
  }

  /**
   * Queues an event for processing among other synchronization events within same account
   * @param {String} name event label name
   * @param {Function} callable async or regular function to execute
   */
  queueEvent(name, callable) {
    this._websocketClient.queueEvent(this._account.id, name, callable);
  }

  /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   */
  async close() {
    if (!this._closed) {
      this._logger.debug(`${this._account.id}: Closing connection`);
      this._stateByInstanceIndex = {};
      this._connectionRegistry.remove(this._account.id);
      const accountRegions = this._account.accountRegions;
      await _promise2.default.all((0, _values2.default)(accountRegions).map(replicaId => this._websocketClient.unsubscribe(replicaId)));
      this._websocketClient.removeSynchronizationListener(this._account.id, this);
      this._websocketClient.removeSynchronizationListener(this._account.id, this._terminalState);
      this._websocketClient.removeSynchronizationListener(this._account.id, this._historyStorage);
      this._websocketClient.removeSynchronizationListener(this._account.id, this._healthMonitor);
      for (let listener of this._synchronizationListeners) {
        this._websocketClient.removeSynchronizationListener(this._account.id, listener);
      }
      this._synchronizationListeners = [];
      this._websocketClient.removeReconnectListener(this);
      this._healthMonitor.stop();
      this._refreshMarketDataSubscriptionSessions = {};
      (0, _values2.default)(this._refreshMarketDataSubscriptionTimeouts).forEach(timeout => clearTimeout(timeout));
      this._refreshMarketDataSubscriptionTimeouts = {};
      (0, _values2.default)(accountRegions).forEach(replicaId => this._websocketClient.removeAccountCache(replicaId));
      this._closed = true;
      this._logger.trace(`${this._account.id}: Closed connection`);
    }
  }

  /**
   * Returns synchronization status
   * @return {boolean} synchronization status
   */
  get synchronized() {
    return (0, _values2.default)(this._stateByInstanceIndex).reduce((acc, s) => acc || s.synchronized, false);
  }

  /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */
  get account() {
    return this._account;
  }

  /**
   * Returns connection health monitor instance
   * @return {ConnectionHealthMonitor} connection health monitor instance
   */
  get healthMonitor() {
    return this._healthMonitor;
  }

  async _refreshMarketDataSubscriptions(accountId, instanceNumber, session) {
    const region = this._websocketClient.getAccountRegion(accountId);
    const instance = `${region}:${instanceNumber}`;
    try {
      if (this._refreshMarketDataSubscriptionSessions[instance] === session) {
        const subscriptionsList = [];
        (0, _keys2.default)(this._subscriptions).forEach(key => {
          const subscriptions = this.subscriptions(key);
          const subscriptionsItem = { symbol: key };
          if (subscriptions) {
            subscriptionsItem.subscriptions = subscriptions;
          }
          subscriptionsList.push(subscriptionsItem);
        });
        await this._websocketClient.refreshMarketDataSubscriptions(accountId, instanceNumber, subscriptionsList);
      }
    } catch (err) {
      this._logger.error(`Error refreshing market data subscriptions job for account ${this._account.id} ` + `${instanceNumber}`, err);
    } finally {
      if (this._refreshMarketDataSubscriptionSessions[instance] === session) {
        let refreshInterval = (Math.random() * (this._maxSubscriptionRefreshInterval - this._minSubscriptionRefreshInterval) + this._minSubscriptionRefreshInterval) * 1000;
        this._refreshMarketDataSubscriptionTimeouts[instance] = setTimeout(() => this._refreshMarketDataSubscriptions(accountId, instanceNumber, session), refreshInterval);
      }
    }
  }

  _generateStopOptions(stopLoss, takeProfit) {
    let trade = {};
    if (typeof stopLoss === 'number') {
      trade.stopLoss = stopLoss;
    } else if (stopLoss) {
      trade.stopLoss = stopLoss.value;
      trade.stopLossUnits = stopLoss.units;
    }
    if (typeof takeProfit === 'number') {
      trade.takeProfit = takeProfit;
    } else if (takeProfit) {
      trade.takeProfit = takeProfit.value;
      trade.takeProfitUnits = takeProfit.units;
    }
    return trade;
  }

  async _ensureSynchronized(instanceIndex, key) {
    let state = this._getState(instanceIndex);
    if (state && state.shouldSynchronize && !this._closed) {
      try {
        const synchronizationResult = await this.synchronize(instanceIndex);
        if (synchronizationResult) {
          state.synchronized = true;
          state.synchronizationRetryIntervalInSeconds = 1;
          delete state.ensureSynchronizeTimeout;
        }
        this._scheduleSynchronizationTimeout(instanceIndex);
      } catch (err) {
        this._logger.error('MetaApi websocket client for account ' + this._account.id + ':' + instanceIndex + ' failed to synchronize', err);
        if (state.shouldSynchronize === key) {
          if (state.ensureSynchronizeTimeout) {
            clearTimeout(state.ensureSynchronizeTimeout);
          }
          state.ensureSynchronizeTimeout = setTimeout(this._ensureSynchronized.bind(this, instanceIndex, key), state.synchronizationRetryIntervalInSeconds * 1000);
          state.synchronizationRetryIntervalInSeconds = Math.min(state.synchronizationRetryIntervalInSeconds * 2, 300);
        }
      }
    }
  }

  _getState(instanceIndex) {
    if (!this._stateByInstanceIndex['' + instanceIndex]) {
      this._stateByInstanceIndex['' + instanceIndex] = {
        instanceIndex,
        ordersSynchronized: {},
        dealsSynchronized: {},
        shouldSynchronize: undefined,
        synchronizationRetryIntervalInSeconds: 1,
        synchronized: false,
        lastDisconnectedSynchronizationId: undefined,
        lastSynchronizationId: undefined,
        disconnected: false
      };
    }
    return this._stateByInstanceIndex['' + instanceIndex];
  }

  _scheduleSynchronizationTimeout(instanceIndex) {
    let state = this._getState(instanceIndex);
    if (state && !this._closed) {
      if (state.synchronizationTimeout) {
        clearTimeout(state.synchronizationTimeout);
      }
      let synchronizationTimeout = 2 * 60 * 1000;
      state.synchronizationTimeout = setTimeout(() => this._checkSynchronizationTimedOut(instanceIndex), synchronizationTimeout);
    }
  }

  _checkSynchronizationTimedOut(instanceIndex) {
    let state = this._getState(instanceIndex);
    if (state && !this._closed) {
      let synchronizationId = state.lastSynchronizationId;
      let synchronized = !!state.dealsSynchronized[synchronizationId];
      if (!synchronized && synchronizationId && state.shouldSynchronize) {
        this._logger.warn(`${this._account.id}:${instanceIndex}: resynchronized since latest synchronization ` + `${synchronizationId} did not finish in time`);
        this._ensureSynchronized(instanceIndex, state.shouldSynchronize);
      }
    }
  }

}
exports.default = StreamingMetaApiConnection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9tZXRhQXBpL3N0cmVhbWluZ01ldGFBcGlDb25uZWN0aW9uLmVzNiJdLCJuYW1lcyI6WyJTdHJlYW1pbmdNZXRhQXBpQ29ubmVjdGlvbiIsIk1ldGFBcGlDb25uZWN0aW9uIiwiY29uc3RydWN0b3IiLCJ3ZWJzb2NrZXRDbGllbnQiLCJjbGllbnRBcGlDbGllbnQiLCJhY2NvdW50IiwiaGlzdG9yeVN0b3JhZ2UiLCJjb25uZWN0aW9uUmVnaXN0cnkiLCJoaXN0b3J5U3RhcnRUaW1lIiwicmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzIiwidmFsaWRhdG9yIiwiT3B0aW9uc1ZhbGlkYXRvciIsIl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwiLCJ2YWxpZGF0ZU5vblplcm8iLCJtaW5EZWxheUluU2Vjb25kcyIsIl9tYXhTdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwiLCJtYXhEZWxheUluU2Vjb25kcyIsIl9jb25uZWN0aW9uUmVnaXN0cnkiLCJfaGlzdG9yeVN0YXJ0VGltZSIsIl90ZXJtaW5hbFN0YXRlIiwiVGVybWluYWxTdGF0ZSIsIl9hY2NvdW50IiwiaWQiLCJfaGlzdG9yeVN0b3JhZ2UiLCJNZW1vcnlIaXN0b3J5U3RvcmFnZSIsIl9oZWFsdGhNb25pdG9yIiwiQ29ubmVjdGlvbkhlYWx0aE1vbml0b3IiLCJfd2Vic29ja2V0Q2xpZW50IiwiYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIiLCJhY2NvdW50UmVnaW9ucyIsImZvckVhY2giLCJyZXBsaWNhSWQiLCJhZGRSZWNvbm5lY3RMaXN0ZW5lciIsIl9zdWJzY3JpcHRpb25zIiwiX3N0YXRlQnlJbnN0YW5jZUluZGV4IiwiX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnMiLCJfcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0cyIsIl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMiLCJfbG9nZ2VyIiwiTG9nZ2VyTWFuYWdlciIsImdldExvZ2dlciIsImNvbm5lY3QiLCJfb3BlbmVkIiwidHJhY2UiLCJpbml0aWFsaXplIiwic3Vic2NyaWJlIiwiZXJyIiwiY2xvc2UiLCJyZW1vdmVBcHBsaWNhdGlvbiIsIl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSIsImNsZWFyIiwic3luY2hyb25pemUiLCJpbnN0YW5jZUluZGV4IiwicmVnaW9uIiwiZ2V0UmVnaW9uIiwiaW5zdGFuY2UiLCJnZXRJbnN0YW5jZU51bWJlciIsImhvc3QiLCJnZXRIb3N0TmFtZSIsInN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSIsIkRhdGUiLCJNYXRoIiwibWF4IiwiZ2V0VGltZSIsImxhc3RIaXN0b3J5T3JkZXJUaW1lIiwic3RhcnRpbmdEZWFsVGltZSIsImxhc3REZWFsVGltZSIsInN5bmNocm9uaXphdGlvbklkIiwicmFuZG9tc3RyaW5nIiwiZ2VuZXJhdGUiLCJfZ2V0U3RhdGUiLCJsYXN0U3luY2hyb25pemF0aW9uSWQiLCJhY2NvdW50SWQiLCJkZWJ1ZyIsInRlcm1pbmFsU3RhdGUiLCJnZXRIYXNoZXMiLCJ0eXBlIiwiYXBwbGljYXRpb24iLCJhZGRBY2NvdW50Q2FjaGUiLCJlbnN1cmVTdWJzY3JpYmUiLCJzdWJzY3JpYmVUb01hcmtldERhdGEiLCJzeW1ib2wiLCJzdWJzY3JpcHRpb25zIiwidGltZW91dEluU2Vjb25kcyIsInNwZWNpZmljYXRpb24iLCJWYWxpZGF0aW9uRXJyb3IiLCJwcmV2U3Vic2NyaXB0aW9ucyIsInN1YnNjcmlwdGlvbiIsImluZGV4IiwiZmluZEluZGV4IiwiaXRlbSIsInRpbWVmcmFtZSIsInB1c2giLCJyZWxpYWJpbGl0eSIsIndhaXRGb3JQcmljZSIsInVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEiLCJmaWx0ZXIiLCJzIiwiZmluZCIsInMyIiwibGVuZ3RoIiwib25TdWJzY3JpcHRpb25Eb3duZ3JhZGVkIiwidXBkYXRlcyIsInVuc3Vic2NyaXB0aW9ucyIsImNhdGNoIiwibmFtZSIsImVycm9yIiwiaW50ZXJ2YWxJbk1pbGxpaXNlY29uZHMiLCJpbnRlcnZhbEluTWlsbGlzZWNvbmRzIiwic3Vic2NyaWJlZFN5bWJvbHMiLCJzYXZlVXB0aW1lIiwidXB0aW1lIiwibGlzdGVuZXIiLCJyZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsImwiLCJvbkNvbm5lY3RlZCIsInJlcGxpY2FzIiwia2V5Iiwic3RhdGUiLCJzaG91bGRTeW5jaHJvbml6ZSIsInN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMiLCJzeW5jaHJvbml6ZWQiLCJfZW5zdXJlU3luY2hyb25pemVkIiwib25EaXNjb25uZWN0ZWQiLCJsYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQiLCJ1bmRlZmluZWQiLCJkaXNjb25uZWN0ZWQiLCJpbnN0YW5jZU51bWJlciIsImNsZWFyVGltZW91dCIsInN5bmNocm9uaXphdGlvblRpbWVvdXQiLCJlbnN1cmVTeW5jaHJvbml6ZVRpbWVvdXQiLCJvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZCIsInNwZWNpZmljYXRpb25zIiwicmVtb3ZlZFN5bWJvbHMiLCJfc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0Iiwib25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQiLCJvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQiLCJvbkRlYWxzU3luY2hyb25pemVkIiwiZGVhbHNTeW5jaHJvbml6ZWQiLCJvbkhpc3RvcnlPcmRlcnNTeW5jaHJvbml6ZWQiLCJvcmRlcnNTeW5jaHJvbml6ZWQiLCJvblJlY29ubmVjdGVkIiwiaW5zdGFuY2VUZW1wbGF0ZSIsInN0YXJ0c1dpdGgiLCJvblN0cmVhbUNsb3NlZCIsIm9uU3luY2hyb25pemF0aW9uU3RhcnRlZCIsInNwZWNpZmljYXRpb25zVXBkYXRlZCIsInBvc2l0aW9uc1VwZGF0ZWQiLCJvcmRlcnNVcGRhdGVkIiwic2Vzc2lvbklkIiwiX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyIsIl9jbG9zZWQiLCJvblVuc3Vic2NyaWJlUmVnaW9uIiwiaXNTeW5jaHJvbml6ZWQiLCJyZWR1Y2UiLCJhY2MiLCJjaGVja1N5bmNocm9uaXphdGlvbklkIiwid2FpdFN5bmNocm9uaXplZCIsIm9wdHMiLCJhcHBsaWNhdGlvblBhdHRlcm4iLCJzdGFydFRpbWUiLCJub3ciLCJyZXMiLCJzZXRUaW1lb3V0IiwiVGltZW91dEVycm9yIiwidGltZUxlZnRJblNlY29uZHMiLCJxdWV1ZUV2ZW50IiwiY2FsbGFibGUiLCJyZW1vdmUiLCJhbGwiLCJtYXAiLCJ1bnN1YnNjcmliZSIsInJlbW92ZVJlY29ubmVjdExpc3RlbmVyIiwic3RvcCIsInRpbWVvdXQiLCJyZW1vdmVBY2NvdW50Q2FjaGUiLCJoZWFsdGhNb25pdG9yIiwic2Vzc2lvbiIsImdldEFjY291bnRSZWdpb24iLCJzdWJzY3JpcHRpb25zTGlzdCIsInN1YnNjcmlwdGlvbnNJdGVtIiwicmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zIiwicmVmcmVzaEludGVydmFsIiwicmFuZG9tIiwiX2dlbmVyYXRlU3RvcE9wdGlvbnMiLCJzdG9wTG9zcyIsInRha2VQcm9maXQiLCJ0cmFkZSIsInZhbHVlIiwic3RvcExvc3NVbml0cyIsInVuaXRzIiwidGFrZVByb2ZpdFVuaXRzIiwic3luY2hyb25pemF0aW9uUmVzdWx0IiwiYmluZCIsIm1pbiIsIl9jaGVja1N5bmNocm9uaXphdGlvblRpbWVkT3V0Iiwid2FybiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7QUFHZSxNQUFNQSwwQkFBTixTQUF5Q0MsMkJBQXpDLENBQTJEOztBQUV4RTs7Ozs7Ozs7Ozs7QUFXQUMsY0FBWUMsZUFBWixFQUE2QkMsZUFBN0IsRUFBOENDLE9BQTlDLEVBQXVEQyxjQUF2RCxFQUF1RUMsa0JBQXZFLEVBQTJGQyxnQkFBM0YsRUFDRUMsd0JBREYsRUFDNEI7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QUFLa0IsYUFBaEMsQ0FBUDtBQUNEOztBQUVEa0Ysa0NBQWdDbEYsYUFBaEMsRUFBK0M7QUFDN0MsUUFBSWtFLFFBQVEsS0FBS2hELFNBQUwsQ0FBZWxCLGFBQWYsQ0FBWjtBQUNBLFFBQUlrRSxTQUFTLENBQUMsS0FBS2lDLE9BQW5CLEVBQTRCO0FBQzFCLFVBQUlqQyxNQUFNVyxzQkFBVixFQUFrQztBQUNoQ0QscUJBQWFWLE1BQU1XLHNCQUFuQjtBQUNEO0FBQ0QsVUFBSUEseUJBQXlCLElBQUksRUFBSixHQUFTLElBQXRDO0FBQ0FYLFlBQU1XLHNCQUFOLEdBQ0VrQyxXQUFXLE1BQU0sS0FBS2dDLDZCQUFMLENBQW1DL0ksYUFBbkMsQ0FBakIsRUFBb0U2RSxzQkFBcEUsQ0FERjtBQUVEO0FBQ0Y7O0FBRURrRSxnQ0FBOEIvSSxhQUE5QixFQUE2QztBQUMzQyxRQUFJa0UsUUFBUSxLQUFLaEQsU0FBTCxDQUFlbEIsYUFBZixDQUFaO0FBQ0EsUUFBSWtFLFNBQVMsQ0FBQyxLQUFLaUMsT0FBbkIsRUFBNEI7QUFDMUIsVUFBSXBGLG9CQUFvQm1ELE1BQU0vQyxxQkFBOUI7QUFDQSxVQUFJa0QsZUFBZSxDQUFDLENBQUNILE1BQU1vQixpQkFBTixDQUF3QnZFLGlCQUF4QixDQUFyQjtBQUNBLFVBQUksQ0FBQ3NELFlBQUQsSUFBaUJ0RCxpQkFBakIsSUFBc0NtRCxNQUFNQyxpQkFBaEQsRUFBbUU7QUFDakUsYUFBS2pGLE9BQUwsQ0FBYThKLElBQWIsQ0FBbUIsR0FBRSxLQUFLL0ssUUFBTCxDQUFjQyxFQUFHLElBQUc4QixhQUFjLGdEQUFyQyxHQUNmLEdBQUVlLGlCQUFrQix5QkFEdkI7QUFFQSxhQUFLdUQsbUJBQUwsQ0FBeUJ0RSxhQUF6QixFQUF3Q2tFLE1BQU1DLGlCQUE5QztBQUNEO0FBQ0Y7QUFDRjs7QUE1c0J1RTtrQkFBckR2SCwwQiIsImZpbGUiOiJzdHJlYW1pbmdNZXRhQXBpQ29ubmVjdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFRlcm1pbmFsU3RhdGUgZnJvbSAnLi90ZXJtaW5hbFN0YXRlJztcbmltcG9ydCBNZW1vcnlIaXN0b3J5U3RvcmFnZSBmcm9tICcuL21lbW9yeUhpc3RvcnlTdG9yYWdlJztcbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vY2xpZW50cy90aW1lb3V0RXJyb3InO1xuaW1wb3J0IHJhbmRvbXN0cmluZyBmcm9tICdyYW5kb21zdHJpbmcnO1xuaW1wb3J0IENvbm5lY3Rpb25IZWFsdGhNb25pdG9yIGZyb20gJy4vY29ubmVjdGlvbkhlYWx0aE1vbml0b3InO1xuaW1wb3J0IHtWYWxpZGF0aW9uRXJyb3J9IGZyb20gJy4uL2NsaWVudHMvZXJyb3JIYW5kbGVyJztcbmltcG9ydCBPcHRpb25zVmFsaWRhdG9yIGZyb20gJy4uL2NsaWVudHMvb3B0aW9uc1ZhbGlkYXRvcic7XG5pbXBvcnQgTG9nZ2VyTWFuYWdlciBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IE1ldGFBcGlDb25uZWN0aW9uIGZyb20gJy4vbWV0YUFwaUNvbm5lY3Rpb24nO1xuXG4vKipcbiAqIEV4cG9zZXMgTWV0YUFwaSBNZXRhVHJhZGVyIHN0cmVhbWluZyBBUEkgY29ubmVjdGlvbiB0byBjb25zdW1lcnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyZWFtaW5nTWV0YUFwaUNvbm5lY3Rpb24gZXh0ZW5kcyBNZXRhQXBpQ29ubmVjdGlvbiB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgTWV0YUFwaSBNZXRhVHJhZGVyIHN0cmVhbWluZyBBcGkgY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9IHdlYnNvY2tldENsaWVudCBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnRcbiAgICogQHBhcmFtIHtDbGllbnRBcGlDbGllbnR9IGNsaWVudEFwaUNsaWVudCBjbGllbnQgYXBpIGNsaWVudFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50fSBhY2NvdW50IE1ldGFUcmFkZXIgYWNjb3VudCBpZCB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSB7SGlzdG9yeVN0b3JhZ2V9IGhpc3RvcnlTdG9yYWdlIHRlcm1pbmFsIGhpc3Rvcnkgc3RvcmFnZS4gQnkgZGVmYXVsdCBhbiBpbnN0YW5jZSBvZiBNZW1vcnlIaXN0b3J5U3RvcmFnZVxuICAgKiB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvblJlZ2lzdHJ5fSBjb25uZWN0aW9uUmVnaXN0cnkgbWV0YXRyYWRlciBhY2NvdW50IGNvbm5lY3Rpb24gcmVnaXN0cnlcbiAgICogQHBhcmFtIHtEYXRlfSBbaGlzdG9yeVN0YXJ0VGltZV0gaGlzdG9yeSBzdGFydCBzeW5jIHRpbWVcbiAgICogQHBhcmFtIHtSZWZyZXNoU3Vic2NyaXB0aW9uc09wdHN9IFtyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHNdIHN1YnNjcmlwdGlvbnMgcmVmcmVzaCBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3ZWJzb2NrZXRDbGllbnQsIGNsaWVudEFwaUNsaWVudCwgYWNjb3VudCwgaGlzdG9yeVN0b3JhZ2UsIGNvbm5lY3Rpb25SZWdpc3RyeSwgaGlzdG9yeVN0YXJ0VGltZSxcbiAgICByZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMpIHtcbiAgICBzdXBlcih3ZWJzb2NrZXRDbGllbnQsIGFjY291bnQpO1xuICAgIHJlZnJlc2hTdWJzY3JpcHRpb25zT3B0cyA9IHJlZnJlc2hTdWJzY3JpcHRpb25zT3B0cyB8fCB7fTtcbiAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgT3B0aW9uc1ZhbGlkYXRvcigpO1xuICAgIHRoaXMuX21pblN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ocmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzLm1pbkRlbGF5SW5TZWNvbmRzLCAxLFxuICAgICAgJ3JlZnJlc2hTdWJzY3JpcHRpb25zT3B0cy5taW5EZWxheUluU2Vjb25kcycpO1xuICAgIHRoaXMuX21heFN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ocmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzLm1heERlbGF5SW5TZWNvbmRzLCA2MDAsXG4gICAgICAncmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzLm1heERlbGF5SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5ID0gY29ubmVjdGlvblJlZ2lzdHJ5O1xuICAgIHRoaXMuX2hpc3RvcnlTdGFydFRpbWUgPSBoaXN0b3J5U3RhcnRUaW1lO1xuICAgIHRoaXMuX3Rlcm1pbmFsU3RhdGUgPSBuZXcgVGVybWluYWxTdGF0ZSh0aGlzLl9hY2NvdW50LmlkLCBjbGllbnRBcGlDbGllbnQpO1xuICAgIHRoaXMuX2hpc3RvcnlTdG9yYWdlID0gaGlzdG9yeVN0b3JhZ2UgfHwgbmV3IE1lbW9yeUhpc3RvcnlTdG9yYWdlKCk7XG4gICAgdGhpcy5faGVhbHRoTW9uaXRvciA9IG5ldyBDb25uZWN0aW9uSGVhbHRoTW9uaXRvcih0aGlzKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoYWNjb3VudC5pZCwgdGhpcyk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnQuaWQsIHRoaXMuX3Rlcm1pbmFsU3RhdGUpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzLl9oaXN0b3J5U3RvcmFnZSk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnQuaWQsIHRoaXMuX2hlYWx0aE1vbml0b3IpO1xuICAgIE9iamVjdC52YWx1ZXMoYWNjb3VudC5hY2NvdW50UmVnaW9ucylcbiAgICAgIC5mb3JFYWNoKHJlcGxpY2FJZCA9PiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkUmVjb25uZWN0TGlzdGVuZXIodGhpcywgcmVwbGljYUlkKSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4ID0ge307XG4gICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9ucyA9IHt9O1xuICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMgPSB7fTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignTWV0YUFwaUNvbm5lY3Rpb24nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgY29ubmVjdGlvbi4gQ2FuIG9ubHkgYmUgY2FsbGVkIHRoZSBmaXJzdCB0aW1lLCBuZXh0IGNhbGxzIHdpbGwgYmUgaWdub3JlZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWRcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShgJHt0aGlzLl9hY2NvdW50LmlkfTogT3BlbmluZyBjb25uZWN0aW9uYCk7XG4gICAgICB0aGlzLl9vcGVuZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgb3JkZXIgYW5kIHRyYW5zYWN0aW9uIGhpc3Rvcnkgb2YgYSBzcGVjaWZpZWQgYXBwbGljYXRpb24gYW5kIHJlbW92ZXMgYXBwbGljYXRpb24gKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZW1vdmVBcHBsaWNhdGlvbi8pLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBoaXN0b3J5IGlzIGNsZWFyZWQgYW5kIGFwcGxpY2F0aW9uIGlzIHJlbW92ZWRcbiAgICovXG4gIHJlbW92ZUFwcGxpY2F0aW9uKCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgdGhpcy5faGlzdG9yeVN0b3JhZ2UuY2xlYXIoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZUFwcGxpY2F0aW9uKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSB0ZXJtaW5hbCB0byBzdGFydCBzeW5jaHJvbml6YXRpb24gcHJvY2Vzc1xuICAgKiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvc3luY2hyb25pemluZy9zeW5jaHJvbml6ZS8pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluc3RhbmNlIGluZGV4XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIGFzeW5jIHN5bmNocm9uaXplKGluc3RhbmNlSW5kZXgpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCBob3N0ID0gdGhpcy5nZXRIb3N0TmFtZShpbnN0YW5jZUluZGV4KTtcbiAgICBsZXQgc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lID0gbmV3IERhdGUoTWF0aC5tYXgoXG4gICAgICAodGhpcy5faGlzdG9yeVN0YXJ0VGltZSB8fCBuZXcgRGF0ZSgwKSkuZ2V0VGltZSgpLFxuICAgICAgKGF3YWl0IHRoaXMuX2hpc3RvcnlTdG9yYWdlLmxhc3RIaXN0b3J5T3JkZXJUaW1lKGluc3RhbmNlKSkuZ2V0VGltZSgpXG4gICAgKSk7XG4gICAgbGV0IHN0YXJ0aW5nRGVhbFRpbWUgPSBuZXcgRGF0ZShNYXRoLm1heChcbiAgICAgICh0aGlzLl9oaXN0b3J5U3RhcnRUaW1lIHx8IG5ldyBEYXRlKDApKS5nZXRUaW1lKCksXG4gICAgICAoYXdhaXQgdGhpcy5faGlzdG9yeVN0b3JhZ2UubGFzdERlYWxUaW1lKGluc3RhbmNlKSkuZ2V0VGltZSgpXG4gICAgKSk7XG4gICAgbGV0IHN5bmNocm9uaXphdGlvbklkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KS5sYXN0U3luY2hyb25pemF0aW9uSWQgPSBzeW5jaHJvbml6YXRpb25JZDtcbiAgICBjb25zdCBhY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zW3JlZ2lvbl07XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IGluaXRpYXRpbmcgc3luY2hyb25pemF0aW9uICR7c3luY2hyb25pemF0aW9uSWR9YCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5zeW5jaHJvbml6ZShhY2NvdW50SWQsIGluc3RhbmNlLCBob3N0LCBzeW5jaHJvbml6YXRpb25JZCxcbiAgICAgIHN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSwgc3RhcnRpbmdEZWFsVGltZSxcbiAgICAgIGFzeW5jICgpID0+IGF3YWl0IHRoaXMudGVybWluYWxTdGF0ZS5nZXRIYXNoZXModGhpcy5fYWNjb3VudC50eXBlLCBpbnN0YW5jZUluZGV4KSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgbWV0YSBhcGkgY29ubmVjdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gbWV0YSBhcGkgY29ubmVjdGlvbiBpcyBpbml0aWFsaXplZFxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGF3YWl0IHRoaXMuX2hpc3RvcnlTdG9yYWdlLmluaXRpYWxpemUodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LmFwcGxpY2F0aW9uKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkQWNjb3VudENhY2hlKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBzdWJzY3JpcHRpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiBpcyBpbml0aWF0ZWRcbiAgICovXG4gIGFzeW5jIHN1YnNjcmliZSgpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGNvbnN0IGFjY291bnRSZWdpb25zID0gdGhpcy5fYWNjb3VudC5hY2NvdW50UmVnaW9ucztcbiAgICBPYmplY3QudmFsdWVzKGFjY291bnRSZWdpb25zKS5mb3JFYWNoKHJlcGxpY2FJZCA9PiB7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZW5zdXJlU3Vic2NyaWJlKHJlcGxpY2FJZCwgMCk7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZW5zdXJlU3Vic2NyaWJlKHJlcGxpY2FJZCwgMSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyBvbiBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3N1YnNjcmliZVRvTWFya2V0RGF0YS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFTdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbiB0byBjcmVhdGUgb3IgdXBkYXRlLiBQbGVhc2VcbiAgICogbm90ZSB0aGF0IHRoaXMgZmVhdHVyZSBpcyBub3QgZnVsbHkgaW1wbGVtZW50ZWQgb24gc2VydmVyLXNpZGUgeWV0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dEluU2Vjb25kc10gdGltZW91dCB0byB3YWl0IGZvciBwcmljZXMgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAzMFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIHN1YnNjcmliZVRvTWFya2V0RGF0YShzeW1ib2wsIHN1YnNjcmlwdGlvbnMsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGlmKCF0aGlzLl90ZXJtaW5hbFN0YXRlLnNwZWNpZmljYXRpb24oc3ltYm9sKSl7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBDYW5ub3Qgc3Vic2NyaWJlIHRvIG1hcmtldCBkYXRhIGZvciBzeW1ib2wgJHtzeW1ib2x9IGJlY2F1c2UgYCArXG4gICAgICAnc3ltYm9sIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zIHx8IFt7dHlwZTogJ3F1b3Rlcyd9XTtcbiAgICAgIGlmKHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXSkge1xuICAgICAgICBjb25zdCBwcmV2U3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zO1xuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goc3Vic2NyaXB0aW9uID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHN1YnNjcmlwdGlvbi50eXBlID09PSAnY2FuZGxlcycgPyBcbiAgICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0udHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUgJiYgXG4gICAgICAgICAgICBpdGVtLnRpbWVmcmFtZSA9PT0gc3Vic2NyaXB0aW9uLnRpbWVmcmFtZSkgOlxuICAgICAgICAgICAgcHJldlN1YnNjcmlwdGlvbnMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS50eXBlID09PSBzdWJzY3JpcHRpb24udHlwZSk7XG4gICAgICAgICAgaWYoaW5kZXggPT09IC0xKXtcbiAgICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldlN1YnNjcmlwdGlvbnNbaW5kZXhdID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0gPSB7c3Vic2NyaXB0aW9uc307XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc3Vic2NyaWJlVG9NYXJrZXREYXRhKHRoaXMuX2FjY291bnQuaWQsIHN5bWJvbCwgc3Vic2NyaXB0aW9ucyxcbiAgICAgICAgdGhpcy5fYWNjb3VudC5yZWxpYWJpbGl0eSk7XG4gICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbFN0YXRlLndhaXRGb3JQcmljZShzeW1ib2wsIHRpbWVvdXRJblNlY29uZHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3Vuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhVW5zdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gY2FuY2VsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdW5zdWJzY3JpcHRpb24gcmVxdWVzdCB3YXMgcHJvY2Vzc2VkXG4gICAqL1xuICB1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhKHN5bWJvbCwgc3Vic2NyaXB0aW9ucykge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25zKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0uc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zXG4gICAgICAgIC5maWx0ZXIocyA9PiBzLnR5cGUgPT09ICdjYW5kbGVzJyA/IFxuICAgICAgICAgICFzdWJzY3JpcHRpb25zLmZpbmQoczIgPT4gcy50eXBlID09PSBzMi50eXBlICYmIHMudGltZWZyYW1lID09PSBzMi50aW1lZnJhbWUpIDogXG4gICAgICAgICAgIXN1YnNjcmlwdGlvbnMuZmluZChzMiA9PiBzLnR5cGUgPT09IHMyLnR5cGUpKTtcbiAgICAgIGlmICghdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdLnN1YnNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YSh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMsXG4gICAgICB0aGlzLl9hY2NvdW50LnJlbGlhYmlsaXR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gc3Vic2NyaXB0aW9uIGRvd25ncmFkZSBoYXMgb2NjdXJyZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdXBkYXRlIHN1YnNjcmlwdGlvbnMgZm9yXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVN1YnNjcmlwdGlvbj59IHVwZGF0ZXMgYXJyYXkgb2YgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9uIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFVbnN1YnNjcmlwdGlvbj59IHVuc3Vic2NyaXB0aW9ucyBhcnJheSBvZiBzdWJzY3JpcHRpb25zIHRvIGNhbmNlbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGFzeW5jIG9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZChpbnN0YW5jZUluZGV4LCBzeW1ib2wsIHVwZGF0ZXMsIHVuc3Vic2NyaXB0aW9ucykge1xuICAgIGxldCBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdIHx8IFtdO1xuICAgIGlmICh1bnN1YnNjcmlwdGlvbnMgJiYgdW5zdWJzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgc3Vic2NyaXB0aW9uIG9mIHVuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zLmZpbHRlcihzID0+IHMudHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoc3ltYm9sLCB1bnN1YnNjcmlwdGlvbnMpXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIubmFtZSAhPT0gVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7dGhpcy5fYWNjb3VudC5pZH06IGZhaWxlZCBkbyB1bnN1YnNjcmliZSBmcm9tIG1hcmtldCBkYXRhIG9uIHN1YnNjcmlwdGlvbiBkb3duZ3JhZGVkYCxcbiAgICAgICAgICAgICAgZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGAke3RoaXMuX2FjY291bnQuaWR9OiBmYWlsZWQgZG8gdW5zdWJzY3JpYmUgZnJvbSBtYXJrZXQgZGF0YSBvbiBzdWJzY3JpcHRpb24gZG93bmdyYWRlZGAsXG4gICAgICAgICAgICAgIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZXMgJiYgdXBkYXRlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgIGZvciAobGV0IHN1YnNjcmlwdGlvbiBvZiB1cGRhdGVzKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5maWx0ZXIocyA9PiBzLnR5cGUgPT09IHN1YnNjcmlwdGlvbi50eXBlKVxuICAgICAgICAgICAgLmZvckVhY2gocyA9PiBzLmludGVydmFsSW5NaWxsaWlzZWNvbmRzID0gc3Vic2NyaXB0aW9uLmludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnN1YnNjcmliZVRvTWFya2V0RGF0YShzeW1ib2wsIHVwZGF0ZXMpXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHt0aGlzLl9hY2NvdW50LmlkfTogZmFpbGVkIGRvIHVuc3Vic2NyaWJlIGZyb20gbWFya2V0IGRhdGEgb24gc3Vic2NyaXB0aW9uIGRvd25ncmFkZWRgLFxuICAgICAgICAgICAgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdWJzY3JpcHRpb25zICYmICFzdWJzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIHRoZSBzeW1ib2xzIGNvbm5lY3Rpb24gaXMgc3Vic2NyaWJlZCB0b1xuICAgKiBAcmV0dXJucyB7QXJyYXk8U3RyaW5nPn0gbGlzdCBvZiB0aGUgc3ltYm9scyBjb25uZWN0aW9uIGlzIHN1YnNjcmliZWQgdG9cbiAgICovXG4gIGdldCBzdWJzY3JpYmVkU3ltYm9scygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdWJzY3JpcHRpb25zIGZvciBhIHN5bWJvbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBzdWJzY3JpcHRpb25zIGZvclxuICAgKiBAcmV0dXJucyB7QXJyYXk8TWFya2V0RGF0YVN1YnNjcmlwdGlvbj59IGxpc3Qgb2YgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9ucyBmb3IgdGhlIHN5bWJvbFxuICAgKi9cbiAgc3Vic2NyaXB0aW9ucyhzeW1ib2wpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdIHx8IHt9KS5zdWJzY3JpcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGNsaWVudCB1cHRpbWUgc3RhdHMgdG8gdGhlIHNlcnZlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IHVwdGltZSB1cHRpbWUgc3RhdGlzdGljcyB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1cHRpbWUgc3RhdGlzdGljcyBpcyBzdWJtaXR0ZWRcbiAgICovXG4gIHNhdmVVcHRpbWUodXB0aW1lKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnNhdmVVcHRpbWUodGhpcy5fYWNjb3VudC5pZCwgdXB0aW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGxvY2FsIGNvcHkgb2YgdGVybWluYWwgc3RhdGVcbiAgICogQHJldHVybnMge1Rlcm1pbmFsU3RhdGV9IGxvY2FsIGNvcHkgb2YgdGVybWluYWwgc3RhdGVcbiAgICovXG4gIGdldCB0ZXJtaW5hbFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXJtaW5hbFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbG9jYWwgaGlzdG9yeSBzdG9yYWdlXG4gICAqIEByZXR1cm5zIHtIaXN0b3J5U3RvcmFnZX0gbG9jYWwgaGlzdG9yeSBzdG9yYWdlXG4gICAqL1xuICBnZXQgaGlzdG9yeVN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpc3RvcnlTdG9yYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7U3luY2hyb25pemF0aW9uTGlzdGVuZXJ9IGxpc3RlbmVyIHN5bmNocm9uaXphdGlvbiBsaXN0ZW5lciB0byBhZGRcbiAgICovXG4gIGFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgZm9yIHNwZWNpZmljIGFjY291bnRcbiAgICogQHBhcmFtIHtTeW5jaHJvbml6YXRpb25MaXN0ZW5lcn0gbGlzdGVuZXIgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMgPSB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMuZmlsdGVyKGwgPT4gbCAhPT0gbGlzdGVuZXIpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBlc3RhYmxpc2hlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwbGljYXMgbnVtYmVyIG9mIGFjY291bnQgcmVwbGljYXMgbGF1bmNoZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvbkNvbm5lY3RlZChpbnN0YW5jZUluZGV4LCByZXBsaWNhcykge1xuICAgIGxldCBrZXkgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLnNob3VsZFN5bmNocm9uaXplID0ga2V5O1xuICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgPSAxO1xuICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vuc3VyZVN5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBrZXkpO1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBjb25uZWN0ZWQgdG8gYnJva2VyYCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCB0ZXJtaW5hdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqL1xuICBhc3luYyBvbkRpc2Nvbm5lY3RlZChpbnN0YW5jZUluZGV4KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUubGFzdERpc2Nvbm5lY3RlZFN5bmNocm9uaXphdGlvbklkID0gc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkO1xuICAgIHN0YXRlLmxhc3RTeW5jaHJvbml6YXRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5zeW5jaHJvbml6ZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgIGNvbnN0IGluc3RhbmNlTnVtYmVyID0gdGhpcy5nZXRJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldFJlZ2lvbihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn1gO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlXTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZV0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXTtcbiAgICBpZiAoc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnN5bmNocm9uaXphdGlvblRpbWVvdXQpO1xuICAgICAgZGVsZXRlIHN0YXRlLnN5bmNocm9uaXphdGlvblRpbWVvdXQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lbnN1cmVTeW5jaHJvbml6ZVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChzdGF0ZS5lbnN1cmVTeW5jaHJvbml6ZVRpbWVvdXQpO1xuICAgICAgZGVsZXRlIHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dDtcbiAgICB9XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IGRpc2Nvbm5lY3RlZCBmcm9tIGJyb2tlcmApO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN5bWJvbCBzcGVjaWZpY2F0aW9ucyB3ZXJlIHVwZGF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtBcnJheTxNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbj59IHNwZWNpZmljYXRpb25zIHVwZGF0ZWQgc3BlY2lmaWNhdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSByZW1vdmVkU3ltYm9scyByZW1vdmVkIHN5bWJvbHNcbiAgICovXG4gIG9uU3ltYm9sU3BlY2lmaWNhdGlvbnNVcGRhdGVkKGluc3RhbmNlSW5kZXgsIHNwZWNpZmljYXRpb25zLCByZW1vdmVkU3ltYm9scykge1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gcG9zaXRpb24gc3luY2hyb25pemF0aW9uIGZpbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKi9cbiAgb25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICB0aGlzLl9zY2hlZHVsZVN5bmNocm9uaXphdGlvblRpbWVvdXQoaW5zdGFuY2VJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHBlbmRpbmcgb3JkZXIgc3luY2hyb25pemF0aW9uIGZuaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW4gaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZVxuICAgKiBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqL1xuICBvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICB0aGlzLl9zY2hlZHVsZVN5bmNocm9uaXphdGlvblRpbWVvdXQoaW5zdGFuY2VJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3luY2hyb25pemF0aW9uIG9mIGhpc3RvcnkgZGVhbHMgb24gYSBNZXRhVHJhZGVyIGFjY291bnQgaGF2ZSBmaW5pc2hlZCB0byBpbmRpY2F0ZSBwcm9ncmVzcyBvZiBhblxuICAgKiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvbkRlYWxzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUuZGVhbHNTeW5jaHJvbml6ZWRbc3luY2hyb25pemF0aW9uSWRdID0gdHJ1ZTtcbiAgICB0aGlzLl9zY2hlZHVsZVN5bmNocm9uaXphdGlvblRpbWVvdXQoaW5zdGFuY2VJbmRleCk7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IGZpbmlzaGVkIHN5bmNocm9uaXphdGlvbiAke3N5bmNocm9uaXphdGlvbklkfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN5bmNocm9uaXphdGlvbiBvZiBoaXN0b3J5IG9yZGVycyBvbiBhIE1ldGFUcmFkZXIgYWNjb3VudCBoYXZlIGZpbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuXG4gICAqIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uSGlzdG9yeU9yZGVyc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLm9yZGVyc1N5bmNocm9uaXplZFtzeW5jaHJvbml6YXRpb25JZF0gPSB0cnVlO1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhQXBpIHdlYnNvY2tldCBBUEkgcmVzdG9yZWQgYWZ0ZXIgYSBkaXNjb25uZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWdpb24gcmVjb25uZWN0ZWQgcmVnaW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciByZWNvbm5lY3RlZCBpbnN0YW5jZSBudW1iZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YUFwaSB3ZWJzb2NrZXQgQVBJIHJlc3RvcmVkIGFmdGVyIGEgZGlzY29ubmVjdFxuICAgKi9cbiAgYXN5bmMgb25SZWNvbm5lY3RlZChyZWdpb24sIGluc3RhbmNlTnVtYmVyKSB7XG4gICAgY29uc3QgaW5zdGFuY2VUZW1wbGF0ZSA9IGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn1gO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KVxuICAgICAgLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoYCR7aW5zdGFuY2VUZW1wbGF0ZX06YCkpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2tleV07XG4gICAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9uc1tpbnN0YW5jZVRlbXBsYXRlXTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZVRlbXBsYXRlXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VUZW1wbGF0ZV07XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3RyZWFtIGZvciBhbiBpbnN0YW5jZSBpbmRleCBpcyBjbG9zZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblN0cmVhbUNsb3NlZChpbnN0YW5jZUluZGV4KSB7XG4gICAgZGVsZXRlIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlSW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvbiBpcyBzdGFydGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3BlY2lmaWNhdGlvbnNVcGRhdGVkIHdoZXRoZXIgc3BlY2lmaWNhdGlvbnMgYXJlIGdvaW5nIHRvIGJlIHVwZGF0ZWQgZHVyaW5nIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBvc2l0aW9uc1VwZGF0ZWQgd2hldGhlciBwb3NpdGlvbnMgYXJlIGdvaW5nIHRvIGJlIHVwZGF0ZWQgZHVyaW5nIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9yZGVyc1VwZGF0ZWQgd2hldGhlciBvcmRlcnMgYXJlIGdvaW5nIHRvIGJlIHVwZGF0ZWQgZHVyaW5nIHN5bmNocm9uaXphdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uU3luY2hyb25pemF0aW9uU3RhcnRlZChpbnN0YW5jZUluZGV4LCBzcGVjaWZpY2F0aW9uc1VwZGF0ZWQsIHBvc2l0aW9uc1VwZGF0ZWQsIG9yZGVyc1VwZGF0ZWQsXG4gICAgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogc3RhcnRpbmcgc3luY2hyb25pemF0aW9uICR7c3luY2hyb25pemF0aW9uSWR9YCk7XG4gICAgY29uc3QgaW5zdGFuY2VOdW1iZXIgPSB0aGlzLmdldEluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgY29uc3QgYWNjb3VudElkID0gdGhpcy5fYWNjb3VudC5hY2NvdW50UmVnaW9uc1tyZWdpb25dO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlXTtcbiAgICBsZXQgc2Vzc2lvbklkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlXSA9IHNlc3Npb25JZDtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZV0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXTtcbiAgICBhd2FpdCB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgc2Vzc2lvbklkKTtcbiAgICB0aGlzLl9zY2hlZHVsZVN5bmNocm9uaXphdGlvblRpbWVvdXQoaW5zdGFuY2VJbmRleCk7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYgKHN0YXRlICYmICF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIHN0YXRlLmxhc3RTeW5jaHJvbml6YXRpb25JZCA9IHN5bmNocm9uaXphdGlvbklkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYWNjb3VudCByZWdpb24gaGFzIGJlZW4gdW5zdWJzY3JpYmVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWdpb24gYWNjb3VudCByZWdpb24gdW5zdWJzY3JpYmVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25VbnN1YnNjcmliZVJlZ2lvbihyZWdpb24pIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzKVxuICAgICAgLmZpbHRlcihpbnN0YW5jZSA9PiBpbnN0YW5jZS5zdGFydHNXaXRoKGAke3JlZ2lvbn06YCkpXG4gICAgICAuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdO1xuICAgICAgfSk7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpXG4gICAgICAuZmlsdGVyKGluc3RhbmNlID0+IGluc3RhbmNlLnN0YXJ0c1dpdGgoYCR7cmVnaW9ufTpgKSlcbiAgICAgIC5mb3JFYWNoKGluc3RhbmNlID0+IGRlbGV0ZSB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtpbnN0YW5jZV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmxhZyBpbmRpY2F0aW5nIHN0YXR1cyBvZiBzdGF0ZSBzeW5jaHJvbml6YXRpb24gd2l0aCBNZXRhVHJhZGVyIHRlcm1pbmFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBvcHRpb25hbCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZCwgbGFzdCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZCB3aWxsIGJlIHVzZWRcbiAgICogYnkgZGVmYXVsdFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJvb2xlYW4+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGEgZmxhZyBpbmRpY2F0aW5nIHN0YXR1cyBvZiBzdGF0ZSBzeW5jaHJvbml6YXRpb24gd2l0aCBNZXRhVHJhZGVyXG4gICAqIHRlcm1pbmFsXG4gICAqL1xuICBhc3luYyBpc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KS5yZWR1Y2UoKGFjYywgcykgPT4ge1xuICAgICAgaWYgKGluc3RhbmNlSW5kZXggIT09IHVuZGVmaW5lZCAmJiBzLmluc3RhbmNlSW5kZXggIT09IGluc3RhbmNlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoZWNrU3luY2hyb25pemF0aW9uSWQgPSBzeW5jaHJvbml6YXRpb25JZCB8fCBzLmxhc3RTeW5jaHJvbml6YXRpb25JZDtcbiAgICAgIGxldCBzeW5jaHJvbml6ZWQgPSAhIXMub3JkZXJzU3luY2hyb25pemVkW2NoZWNrU3luY2hyb25pemF0aW9uSWRdICYmIFxuICAgICAgICAhIXMuZGVhbHNTeW5jaHJvbml6ZWRbY2hlY2tTeW5jaHJvbml6YXRpb25JZF07XG4gICAgICByZXR1cm4gYWNjIHx8IHN5bmNocm9uaXplZDtcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gU3luY2hyb25pemF0aW9uT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2FwcGxpY2F0aW9uUGF0dGVybl0gYXBwbGljYXRpb24gcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4sIGRlZmF1bHQgaXMgLipcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzeW5jaHJvbml6YXRpb25JZF0gc3luY2hyb25pemF0aW9uIGlkLCBsYXN0IHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkIHdpbGwgYmUgdXNlZCBieVxuICAgKiBkZWZhdWx0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbaW5zdGFuY2VJbmRleF0gaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSB0byBlbnN1cmUgc3luY2hyb25pemF0aW9uIG9uLCBkZWZhdWx0IGlzIHRvIHdhaXRcbiAgICogZm9yIHRoZSBmaXJzdCBpbnN0YW5jZSB0byBzeW5jaHJvbml6ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVvdXRJblNlY29uZHNdIHdhaXQgdGltZW91dCBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDVtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW50ZXJ2YWxJbk1pbGxpc2Vjb25kc10gaW50ZXJ2YWwgYmV0d2VlbiBhY2NvdW50IHJlbG9hZHMgd2hpbGUgd2FpdGluZyBmb3IgYSBjaGFuZ2UsIGRlZmF1bHQgaXMgMXNcbiAgICovXG5cbiAgLyoqXG4gICAqIFdhaXRzIHVudGlsIHN5bmNocm9uaXphdGlvbiB0byBNZXRhVHJhZGVyIHRlcm1pbmFsIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge1N5bmNocm9uaXphdGlvbk9wdGlvbnN9IHN5bmNocm9uaXphdGlvbiBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb21wbGV0ZWRcbiAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBpZiBhcHBsaWNhdGlvbiBmYWlsZWQgdG8gc3luY2hyb25pemUgd2l0aCB0aGUgdGVtaW5hbCB3aXRoaW4gdGltZW91dCBhbGxvd2VkXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBhc3luYyB3YWl0U3luY2hyb25pemVkKG9wdHMpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGxldCBpbnN0YW5jZUluZGV4ID0gb3B0cy5pbnN0YW5jZUluZGV4O1xuICAgIGxldCBzeW5jaHJvbml6YXRpb25JZCA9IG9wdHMuc3luY2hyb25pemF0aW9uSWQ7XG4gICAgbGV0IHRpbWVvdXRJblNlY29uZHMgPSBvcHRzLnRpbWVvdXRJblNlY29uZHMgfHwgMzAwO1xuICAgIGxldCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gb3B0cy5pbnRlcnZhbEluTWlsbGlzZWNvbmRzIHx8IDEwMDA7XG4gICAgbGV0IGFwcGxpY2F0aW9uUGF0dGVybiA9IG9wdHMuYXBwbGljYXRpb25QYXR0ZXJuIHx8XG4gICAgICAodGhpcy5fYWNjb3VudC5hcHBsaWNhdGlvbiA9PT0gJ0NvcHlGYWN0b3J5JyA/ICdDb3B5RmFjdG9yeS4qfFJQQycgOiAnUlBDJyk7XG4gICAgbGV0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHN5bmNocm9uaXplZDtcbiAgICB3aGlsZSAoIShzeW5jaHJvbml6ZWQgPSBhd2FpdCB0aGlzLmlzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSkgJiZcbiAgICAgIChzdGFydFRpbWUgKyB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIGludGVydmFsSW5NaWxsaXNlY29uZHMpKTtcbiAgICB9XG4gICAgbGV0IHN0YXRlO1xuICAgIGlmIChpbnN0YW5jZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAobGV0IHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkpIHtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuaXNTeW5jaHJvbml6ZWQocy5pbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkpIHtcbiAgICAgICAgICBzdGF0ZSA9IHM7XG4gICAgICAgICAgaW5zdGFuY2VJbmRleCA9IHMuaW5zdGFuY2VJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZSA9IE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLmZpbmQocyA9PiBzLmluc3RhbmNlSW5kZXggPT09IGluc3RhbmNlSW5kZXgpO1xuICAgIH1cbiAgICBpZiAoIXN5bmNocm9uaXplZCkge1xuICAgICAgdGhyb3cgbmV3IFRpbWVvdXRFcnJvcignVGltZWQgb3V0IHdhaXRpbmcgZm9yIE1ldGFBcGkgdG8gc3luY2hyb25pemUgdG8gTWV0YVRyYWRlciBhY2NvdW50ICcgK1xuICAgICAgICB0aGlzLl9hY2NvdW50LmlkICsgJywgc3luY2hyb25pemF0aW9uIGlkICcgKyAoc3luY2hyb25pemF0aW9uSWQgfHwgKHN0YXRlICYmIHN0YXRlLmxhc3RTeW5jaHJvbml6YXRpb25JZCkgfHxcbiAgICAgICAgICAoc3RhdGUgJiYgc3RhdGUubGFzdERpc2Nvbm5lY3RlZFN5bmNocm9uaXphdGlvbklkKSkpO1xuICAgIH1cbiAgICBsZXQgdGltZUxlZnRJblNlY29uZHMgPSBNYXRoLm1heCgwLCB0aW1lb3V0SW5TZWNvbmRzIC0gKERhdGUubm93KCkgLSBzdGFydFRpbWUpIC8gMTAwMCk7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRSZWdpb24oc3RhdGUuaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgYWNjb3VudElkID0gdGhpcy5fYWNjb3VudC5hY2NvdW50UmVnaW9uc1tyZWdpb25dO1xuICAgIGF3YWl0IHRoaXMuX3dlYnNvY2tldENsaWVudC53YWl0U3luY2hyb25pemVkKGFjY291bnRJZCwgdGhpcy5nZXRJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KSxcbiAgICAgIGFwcGxpY2F0aW9uUGF0dGVybiwgdGltZUxlZnRJblNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXVlcyBhbiBldmVudCBmb3IgcHJvY2Vzc2luZyBhbW9uZyBvdGhlciBzeW5jaHJvbml6YXRpb24gZXZlbnRzIHdpdGhpbiBzYW1lIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgZXZlbnQgbGFiZWwgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYWJsZSBhc3luYyBvciByZWd1bGFyIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICovXG4gIHF1ZXVlRXZlbnQobmFtZSwgY2FsbGFibGUpIHtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucXVldWVFdmVudCh0aGlzLl9hY2NvdW50LmlkLCBuYW1lLCBjYWxsYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLiBUaGUgaW5zdGFuY2Ugb2YgdGhlIGNsYXNzIHNob3VsZCBubyBsb25nZXIgYmUgdXNlZCBhZnRlciB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLlxuICAgKi9cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfTogQ2xvc2luZyBjb25uZWN0aW9uYCk7XG4gICAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCA9IHt9O1xuICAgICAgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LnJlbW92ZSh0aGlzLl9hY2NvdW50LmlkKTtcbiAgICAgIGNvbnN0IGFjY291bnRSZWdpb25zID0gdGhpcy5fYWNjb3VudC5hY2NvdW50UmVnaW9ucztcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoYWNjb3VudFJlZ2lvbnMpLm1hcChyZXBsaWNhSWQgPT4gXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC51bnN1YnNjcmliZShyZXBsaWNhSWQpKSk7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcyk7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5fdGVybWluYWxTdGF0ZSk7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5faGlzdG9yeVN0b3JhZ2UpO1xuICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2hlYWx0aE1vbml0b3IpO1xuICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMgPSBbXTtcbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVSZWNvbm5lY3RMaXN0ZW5lcih0aGlzKTtcbiAgICAgIHRoaXMuX2hlYWx0aE1vbml0b3Iuc3RvcCgpO1xuICAgICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9ucyA9IHt9O1xuICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzKS5mb3JFYWNoKHRpbWVvdXQgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpKTtcbiAgICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMgPSB7fTtcbiAgICAgIE9iamVjdC52YWx1ZXMoYWNjb3VudFJlZ2lvbnMpLmZvckVhY2gocmVwbGljYUlkID0+IFxuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlQWNjb3VudENhY2hlKHJlcGxpY2FJZCkpO1xuICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShgJHt0aGlzLl9hY2NvdW50LmlkfTogQ2xvc2VkIGNvbm5lY3Rpb25gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzeW5jaHJvbml6YXRpb24gc3RhdHVzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHN5bmNocm9uaXphdGlvbiBzdGF0dXNcbiAgICovXG4gIGdldCBzeW5jaHJvbml6ZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLnJlZHVjZSgoYWNjLCBzKSA9PiBhY2MgfHwgcy5zeW5jaHJvbml6ZWQsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1ldGFBcGkgYWNjb3VudFxuICAgKiBAcmV0dXJuIHtNZXRhdHJhZGVyQWNjb3VudH0gTWV0YUFwaSBhY2NvdW50XG4gICAqL1xuICBnZXQgYWNjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbm5lY3Rpb24gaGVhbHRoIG1vbml0b3IgaW5zdGFuY2VcbiAgICogQHJldHVybiB7Q29ubmVjdGlvbkhlYWx0aE1vbml0b3J9IGNvbm5lY3Rpb24gaGVhbHRoIG1vbml0b3IgaW5zdGFuY2VcbiAgICovXG4gIGdldCBoZWFsdGhNb25pdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFsdGhNb25pdG9yO1xuICB9XG5cbiAgYXN5bmMgX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyhhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBzZXNzaW9uKSB7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn1gO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9uc1tpbnN0YW5jZV0gPT09IHNlc3Npb24pIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uc0xpc3QgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMoa2V5KTtcbiAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zSXRlbSA9IHtzeW1ib2w6IGtleX07XG4gICAgICAgICAgaWYoc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uc0l0ZW0uc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YnNjcmlwdGlvbnNMaXN0LnB1c2goc3Vic2NyaXB0aW9uc0l0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyhhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLFxuICAgICAgICAgIHN1YnNjcmlwdGlvbnNMaXN0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgRXJyb3IgcmVmcmVzaGluZyBtYXJrZXQgZGF0YSBzdWJzY3JpcHRpb25zIGpvYiBmb3IgYWNjb3VudCAke3RoaXMuX2FjY291bnQuaWR9IGAgK1xuICAgICAgYCR7aW5zdGFuY2VOdW1iZXJ9YCwgZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdID09PSBzZXNzaW9uKSB7XG4gICAgICAgIGxldCByZWZyZXNoSW50ZXJ2YWwgPSAoTWF0aC5yYW5kb20oKSAqICh0aGlzLl9tYXhTdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwgLSBcbiAgICAgICAgICB0aGlzLl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwpICsgdGhpcy5fbWluU3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsKSAqIDEwMDA7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdID0gc2V0VGltZW91dCgoKSA9PlxuICAgICAgICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyhhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBzZXNzaW9uKSwgcmVmcmVzaEludGVydmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCkge1xuICAgIGxldCB0cmFkZSA9IHt9O1xuICAgIGlmICh0eXBlb2Ygc3RvcExvc3MgPT09ICdudW1iZXInKSB7XG4gICAgICB0cmFkZS5zdG9wTG9zcyA9IHN0b3BMb3NzO1xuICAgIH0gZWxzZSBpZiAoc3RvcExvc3MpIHtcbiAgICAgIHRyYWRlLnN0b3BMb3NzID0gc3RvcExvc3MudmFsdWU7XG4gICAgICB0cmFkZS5zdG9wTG9zc1VuaXRzID0gc3RvcExvc3MudW5pdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGFrZVByb2ZpdCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRyYWRlLnRha2VQcm9maXQgPSB0YWtlUHJvZml0O1xuICAgIH0gZWxzZSBpZiAodGFrZVByb2ZpdCkge1xuICAgICAgdHJhZGUudGFrZVByb2ZpdCA9IHRha2VQcm9maXQudmFsdWU7XG4gICAgICB0cmFkZS50YWtlUHJvZml0VW5pdHMgPSB0YWtlUHJvZml0LnVuaXRzO1xuICAgIH1cbiAgICByZXR1cm4gdHJhZGU7XG4gIH1cblxuICBhc3luYyBfZW5zdXJlU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGtleSkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSAmJiAhdGhpcy5fY2xvc2VkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzeW5jaHJvbml6YXRpb25SZXN1bHQgPSBhd2FpdCB0aGlzLnN5bmNocm9uaXplKGluc3RhbmNlSW5kZXgpO1xuICAgICAgICBpZihzeW5jaHJvbml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICBzdGF0ZS5zeW5jaHJvbml6ZWQgPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgPSAxO1xuICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnN1cmVTeW5jaHJvbml6ZVRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IGZvciBhY2NvdW50ICcgKyB0aGlzLl9hY2NvdW50LmlkICtcbiAgICAgICAgICAnOicgKyBpbnN0YW5jZUluZGV4ICsgJyBmYWlsZWQgdG8gc3luY2hyb25pemUnLCBlcnIpO1xuICAgICAgICBpZiAoc3RhdGUuc2hvdWxkU3luY2hyb25pemUgPT09IGtleSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5lbnN1cmVTeW5jaHJvbml6ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS5lbnN1cmVTeW5jaHJvbml6ZVRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5lbnN1cmVTeW5jaHJvbml6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX2Vuc3VyZVN5bmNocm9uaXplZC5iaW5kKHRoaXMsIGluc3RhbmNlSW5kZXgsIGtleSksXG4gICAgICAgICAgICBzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzICogMTAwMCk7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IE1hdGgubWluKHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgKiAyLCAzMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF0pIHtcbiAgICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF0gPSB7XG4gICAgICAgIGluc3RhbmNlSW5kZXgsXG4gICAgICAgIG9yZGVyc1N5bmNocm9uaXplZDoge30sXG4gICAgICAgIGRlYWxzU3luY2hyb25pemVkOiB7fSxcbiAgICAgICAgc2hvdWxkU3luY2hyb25pemU6IHVuZGVmaW5lZCxcbiAgICAgICAgc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kczogMSxcbiAgICAgICAgc3luY2hyb25pemVkOiBmYWxzZSxcbiAgICAgICAgbGFzdERpc2Nvbm5lY3RlZFN5bmNocm9uaXphdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICAgIGxhc3RTeW5jaHJvbml6YXRpb25JZDogdW5kZWZpbmVkLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XTtcbiAgfVxuXG4gIF9zY2hlZHVsZVN5bmNocm9uaXphdGlvblRpbWVvdXQoaW5zdGFuY2VJbmRleCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIGlmIChzdGF0ZSAmJiAhdGhpcy5fY2xvc2VkKSB7XG4gICAgICBpZiAoc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dCk7XG4gICAgICB9XG4gICAgICBsZXQgc3luY2hyb25pemF0aW9uVGltZW91dCA9IDIgKiA2MCAqIDEwMDA7XG4gICAgICBzdGF0ZS5zeW5jaHJvbml6YXRpb25UaW1lb3V0ID1cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9jaGVja1N5bmNocm9uaXphdGlvblRpbWVkT3V0KGluc3RhbmNlSW5kZXgpLCBzeW5jaHJvbml6YXRpb25UaW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICBfY2hlY2tTeW5jaHJvbml6YXRpb25UaW1lZE91dChpbnN0YW5jZUluZGV4KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYgKHN0YXRlICYmICF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIGxldCBzeW5jaHJvbml6YXRpb25JZCA9IHN0YXRlLmxhc3RTeW5jaHJvbml6YXRpb25JZDtcbiAgICAgIGxldCBzeW5jaHJvbml6ZWQgPSAhIXN0YXRlLmRlYWxzU3luY2hyb25pemVkW3N5bmNocm9uaXphdGlvbklkXTtcbiAgICAgIGlmICghc3luY2hyb25pemVkICYmIHN5bmNocm9uaXphdGlvbklkICYmIHN0YXRlLnNob3VsZFN5bmNocm9uaXplKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IHJlc3luY2hyb25pemVkIHNpbmNlIGxhdGVzdCBzeW5jaHJvbml6YXRpb24gYCArXG4gICAgICAgICAgYCR7c3luY2hyb25pemF0aW9uSWR9IGRpZCBub3QgZmluaXNoIGluIHRpbWVgKTtcbiAgICAgICAgdGhpcy5fZW5zdXJlU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN0YXRlLnNob3VsZFN5bmNocm9uaXplKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuIl19