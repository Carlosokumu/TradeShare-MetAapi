'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var _metaApiConnection = require('./metaApiConnection');

var _metaApiConnection2 = _interopRequireDefault(_metaApiConnection);

var _timeoutError = require('../clients/timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Exposes MetaApi MetaTrader RPC API connection to consumers
 */
class RpcMetaApiConnection extends _metaApiConnection2.default {

  /**
   * Constructs MetaApi MetaTrader RPC Api connection
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   */
  constructor(websocketClient, account) {
    super(websocketClient, account, 'RPC');
    this._logger = _logger2.default.getLogger('MetaApiConnection');
    this._websocketClient.addSynchronizationListener(account.id, this);
    this._stateByInstanceIndex = {};
  }

  /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @return {Promise} promise resolving when the connection is opened
   */
  async connect() {
    if (!this._opened) {
      this._opened = true;
      const accountRegions = this._account.accountRegions;
      this._websocketClient.addAccountCache(this._account.id, accountRegions);
      (0, _keys2.default)(accountRegions).forEach(region => {
        this._websocketClient.ensureSubscribe(accountRegions[region], 0);
        this._websocketClient.ensureSubscribe(accountRegions[region], 1);
      });
    }
  }

  /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   */
  async close() {
    if (!this._closed) {
      this._websocketClient.removeAccountCache(this.account.id);
      this._closed = true;
    }
  }

  /**
   * Returns account information (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readAccountInformation/).
   * @returns {Promise<MetatraderAccountInformation>} promise resolving with account information
   */
  getAccountInformation() {
    this._checkIsConnectionActive();
    return this._websocketClient.getAccountInformation(this._account.id);
  }

  /**
   * Returns positions (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPositions/).
   * @returns {Promise<Array<MetatraderPosition>} promise resolving with array of open positions
   */
  getPositions() {
    this._checkIsConnectionActive();
    return this._websocketClient.getPositions(this._account.id);
  }

  /**
   * Returns specific position (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPosition/).
   * @param {String} positionId position id
   * @return {Promise<MetatraderPosition>} promise resolving with MetaTrader position found
   */
  getPosition(positionId) {
    this._checkIsConnectionActive();
    return this._websocketClient.getPosition(this._account.id, positionId);
  }

  /**
   * Returns open orders (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrders/).
   * @return {Promise<Array<MetatraderOrder>>} promise resolving with open MetaTrader orders
   */
  getOrders() {
    this._checkIsConnectionActive();
    return this._websocketClient.getOrders(this._account.id);
  }

  /**
   * Returns specific open order (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrder/).
   * @param {String} orderId order id (ticket number)
   * @return {Promise<MetatraderOrder>} promise resolving with metatrader order found
   */
  getOrder(orderId) {
    this._checkIsConnectionActive();
    return this._websocketClient.getOrder(this._account.id, orderId);
  }

  /**
   * Returns the history of completed orders for a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTicket/).
   * @param {String} ticket ticket number (order id)
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  getHistoryOrdersByTicket(ticket) {
    this._checkIsConnectionActive();
    return this._websocketClient.getHistoryOrdersByTicket(this._account.id, ticket);
  }

  /**
   * Returns the history of completed orders for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByPosition/)
   * @param {String} positionId position id
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  getHistoryOrdersByPosition(positionId) {
    this._checkIsConnectionActive();
    return this._websocketClient.getHistoryOrdersByPosition(this._account.id, positionId);
  }

  /**
   * Returns the history of completed orders for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTimeRange/)
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  getHistoryOrdersByTimeRange(startTime, endTime, offset = 0, limit = 1000) {
    this._checkIsConnectionActive();
    return this._websocketClient.getHistoryOrdersByTimeRange(this._account.id, startTime, endTime, offset, limit);
  }

  /**
   * Returns history deals with a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTicket/).
   * @param {String} ticket ticket number (deal id for MT5 or order id for MT4)
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  getDealsByTicket(ticket) {
    this._checkIsConnectionActive();
    return this._websocketClient.getDealsByTicket(this._account.id, ticket);
  }

  /**
   * Returns history deals for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByPosition/).
   * @param {String} positionId position id
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  getDealsByPosition(positionId) {
    this._checkIsConnectionActive();
    return this._websocketClient.getDealsByPosition(this._account.id, positionId);
  }

  /**
   * Returns history deals with for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTimeRange/).
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  getDealsByTimeRange(startTime, endTime, offset = 0, limit = 1000) {
    this._checkIsConnectionActive();
    return this._websocketClient.getDealsByTimeRange(this._account.id, startTime, endTime, offset, limit);
  }

  /**
   * Retrieves available symbols for an account (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbols/).
   * @param {String} symbol symbol to retrieve symbols for
   * @returns {Promise<Array<string>>} promise which resolves when symbols are retrieved
   */
  getSymbols() {
    this._checkIsConnectionActive();
    return this._websocketClient.getSymbols(this._account.id);
  }

  /**
   * Retrieves specification for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolSpecification/).
   * @param {String} symbol symbol to retrieve specification for
   * @returns {Promise<MetatraderSymbolSpecification>} promise which resolves when specification is retrieved
   */
  getSymbolSpecification(symbol) {
    this._checkIsConnectionActive();
    return this._websocketClient.getSymbolSpecification(this._account.id, symbol);
  }

  /**
   * Retrieves latest price for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolPrice/).
   * @param {String} symbol symbol to retrieve price for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderSymbolPrice>} promise which resolves when price is retrieved
   */
  getSymbolPrice(symbol, keepSubscription) {
    this._checkIsConnectionActive();
    return this._websocketClient.getSymbolPrice(this._account.id, symbol, keepSubscription);
  }

  /**
   * Retrieves latest candle for a symbol and timeframe (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readCandle/).
   * @param {String} symbol symbol to retrieve candle for
   * @param {string} timeframe defines the timeframe according to which the candle must be generated. Allowed values for
   * MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values
   * for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderCandle>} promise which resolves when candle is retrieved
   */
  getCandle(symbol, timeframe, keepSubscription = false) {
    this._checkIsConnectionActive();
    return this._websocketClient.getCandle(this._account.id, symbol, timeframe, keepSubscription);
  }

  /**
   * Retrieves latest tick for a symbol. MT4 G1 accounts do not support this API (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readTick/).
   * @param {String} symbol symbol to retrieve tick for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderTick>} promise which resolves when tick is retrieved
   */
  getTick(symbol, keepSubscription = false) {
    this._checkIsConnectionActive();
    return this._websocketClient.getTick(this._account.id, symbol, keepSubscription);
  }

  /**
   * Retrieves latest order book for a symbol. MT4 accounts do not support this API (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readBook/).
   * @param {string} symbol symbol to retrieve order book for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderTick>} promise which resolves when order book is retrieved
   */
  getBook(symbol, keepSubscription = false) {
    this._checkIsConnectionActive();
    return this._websocketClient.getBook(this._account.id, symbol, keepSubscription);
  }

  /**
   * Returns server time for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readServerTime/).
   * @returns {Promise<ServerTime>} promise resolving with server time
   */
  async getServerTime() {
    this._checkIsConnectionActive();
    return this._websocketClient.getServerTime(this._account.id);
  }

  /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   * @param {Number} replicas number of account replicas launched
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onConnected(instanceIndex, replicas) {
    const state = this._getState(instanceIndex);
    state.synchronized = true;
  }

  /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onDisconnected(instanceIndex) {
    const state = this._getState(instanceIndex);
    state.synchronized = false;
    this._logger.debug(`${this._account.id}:${instanceIndex}: disconnected from broker`);
  }

  /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   */
  async onStreamClosed(instanceIndex) {
    delete this._stateByInstanceIndex[instanceIndex];
  }

  /**
   * Returns flag indicating status of state synchronization with MetaTrader terminal
   * @returns {Boolean} a flag indicating status of state synchronization with MetaTrader terminal
   */
  isSynchronized() {
    return (0, _values2.default)(this._stateByInstanceIndex).map(instance => instance.synchronized).includes(true);
  }

  /**
   * Waits until synchronization to RPC application is completed
   * @param {Number} timeoutInSeconds synchronization timeout in seconds
   * @return {Promise} promise which resolves when synchronization to RPC application is completed
   * @throws {TimeoutError} if application failed to synchronize with the teminal within timeout allowed
   */
  async waitSynchronized(timeoutInSeconds = 300) {
    this._checkIsConnectionActive();
    const startTime = Date.now();
    let synchronized = this.isSynchronized();
    while (!synchronized && startTime + timeoutInSeconds * 1000 > Date.now()) {
      await new _promise2.default(res => setTimeout(res, 1000));
      synchronized = this.isSynchronized();
    }
    if (!synchronized) {
      throw new _timeoutError2.default('Timed out waiting for MetaApi to synchronize to MetaTrader account ' + this._account.id);
    }
    // eslint-disable-next-line
    while (true) {
      try {
        await this._websocketClient.waitSynchronized(this._account.id, undefined, 'RPC', 5, 'RPC');
        break;
      } catch (err) {
        if (Date.now() > startTime + timeoutInSeconds * 1000) {
          throw err;
        }
      }
    }
  }

  _getState(instanceIndex) {
    if (!this._stateByInstanceIndex[instanceIndex]) {
      this._stateByInstanceIndex[instanceIndex] = {
        instanceIndex,
        synchronized: false
      };
    }
    return this._stateByInstanceIndex[instanceIndex];
  }

}
exports.default = RpcMetaApiConnection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9tZXRhQXBpL3JwY01ldGFBcGlDb25uZWN0aW9uLmVzNiJdLCJuYW1lcyI6WyJScGNNZXRhQXBpQ29ubmVjdGlvbiIsIk1ldGFBcGlDb25uZWN0aW9uIiwiY29uc3RydWN0b3IiLCJ3ZWJzb2NrZXRDbGllbnQiLCJhY2NvdW50IiwiX2xvZ2dlciIsIkxvZ2dlck1hbmFnZXIiLCJnZXRMb2dnZXIiLCJfd2Vic29ja2V0Q2xpZW50IiwiYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIiLCJpZCIsIl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCIsImNvbm5lY3QiLCJfb3BlbmVkIiwiYWNjb3VudFJlZ2lvbnMiLCJfYWNjb3VudCIsImFkZEFjY291bnRDYWNoZSIsImZvckVhY2giLCJyZWdpb24iLCJlbnN1cmVTdWJzY3JpYmUiLCJjbG9zZSIsIl9jbG9zZWQiLCJyZW1vdmVBY2NvdW50Q2FjaGUiLCJnZXRBY2NvdW50SW5mb3JtYXRpb24iLCJfY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUiLCJnZXRQb3NpdGlvbnMiLCJnZXRQb3NpdGlvbiIsInBvc2l0aW9uSWQiLCJnZXRPcmRlcnMiLCJnZXRPcmRlciIsIm9yZGVySWQiLCJnZXRIaXN0b3J5T3JkZXJzQnlUaWNrZXQiLCJ0aWNrZXQiLCJnZXRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbiIsImdldEhpc3RvcnlPcmRlcnNCeVRpbWVSYW5nZSIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJvZmZzZXQiLCJsaW1pdCIsImdldERlYWxzQnlUaWNrZXQiLCJnZXREZWFsc0J5UG9zaXRpb24iLCJnZXREZWFsc0J5VGltZVJhbmdlIiwiZ2V0U3ltYm9scyIsImdldFN5bWJvbFNwZWNpZmljYXRpb24iLCJzeW1ib2wiLCJnZXRTeW1ib2xQcmljZSIsImtlZXBTdWJzY3JpcHRpb24iLCJnZXRDYW5kbGUiLCJ0aW1lZnJhbWUiLCJnZXRUaWNrIiwiZ2V0Qm9vayIsImdldFNlcnZlclRpbWUiLCJvbkNvbm5lY3RlZCIsImluc3RhbmNlSW5kZXgiLCJyZXBsaWNhcyIsInN0YXRlIiwiX2dldFN0YXRlIiwic3luY2hyb25pemVkIiwib25EaXNjb25uZWN0ZWQiLCJkZWJ1ZyIsIm9uU3RyZWFtQ2xvc2VkIiwiaXNTeW5jaHJvbml6ZWQiLCJtYXAiLCJpbnN0YW5jZSIsImluY2x1ZGVzIiwid2FpdFN5bmNocm9uaXplZCIsInRpbWVvdXRJblNlY29uZHMiLCJEYXRlIiwibm93IiwicmVzIiwic2V0VGltZW91dCIsIlRpbWVvdXRFcnJvciIsInVuZGVmaW5lZCIsImVyciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7OztBQUdlLE1BQU1BLG9CQUFOLFNBQW1DQywyQkFBbkMsQ0FBcUQ7O0FBRWxFOzs7OztBQUtBQyxjQUFZQyxlQUFaLEVBQTZCQyxPQUE3QixFQUFzQztBQUNwQyxVQUFNRCxlQUFOLEVBQXVCQyxPQUF2QixFQUFnQyxLQUFoQztBQUNBLFNBQUtDLE9BQUwsR0FBZUMsaUJBQWNDLFNBQWQsQ0FBd0IsbUJBQXhCLENBQWY7QUFDQSxTQUFLQyxnQkFBTCxDQUFzQkMsMEJBQXRCLENBQWlETCxRQUFRTSxFQUF6RCxFQUE2RCxJQUE3RDtBQUNBLFNBQUtDLHFCQUFMLEdBQTZCLEVBQTdCO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxRQUFNQyxPQUFOLEdBQWdCO0FBQ2QsUUFBSSxDQUFDLEtBQUtDLE9BQVYsRUFBbUI7QUFDakIsV0FBS0EsT0FBTCxHQUFlLElBQWY7QUFDQSxZQUFNQyxpQkFBaUIsS0FBS0MsUUFBTCxDQUFjRCxjQUFyQztBQUNBLFdBQUtOLGdCQUFMLENBQXNCUSxlQUF0QixDQUFzQyxLQUFLRCxRQUFMLENBQWNMLEVBQXBELEVBQXdESSxjQUF4RDtBQUNBLDBCQUFZQSxjQUFaLEVBQTRCRyxPQUE1QixDQUFvQ0MsVUFBVTtBQUM1QyxhQUFLVixnQkFBTCxDQUFzQlcsZUFBdEIsQ0FBc0NMLGVBQWVJLE1BQWYsQ0FBdEMsRUFBOEQs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Q0QsV0FBTyxLQUFLOUMscUJBQUwsQ0FBMkIwQyxhQUEzQixDQUFQO0FBQ0Q7O0FBOVVpRTtrQkFBL0NyRCxvQiIsImZpbGUiOiJycGNNZXRhQXBpQ29ubmVjdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmltcG9ydCBMb2dnZXJNYW5hZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgTWV0YUFwaUNvbm5lY3Rpb24gZnJvbSAnLi9tZXRhQXBpQ29ubmVjdGlvbic7XG5pbXBvcnQgVGltZW91dEVycm9yIGZyb20gJy4uL2NsaWVudHMvdGltZW91dEVycm9yJztcblxuLyoqXG4gKiBFeHBvc2VzIE1ldGFBcGkgTWV0YVRyYWRlciBSUEMgQVBJIGNvbm5lY3Rpb24gdG8gY29uc3VtZXJzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJwY01ldGFBcGlDb25uZWN0aW9uIGV4dGVuZHMgTWV0YUFwaUNvbm5lY3Rpb24ge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIE1ldGFBcGkgTWV0YVRyYWRlciBSUEMgQXBpIGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50fSB3ZWJzb2NrZXRDbGllbnQgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50XG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnR9IGFjY291bnQgTWV0YVRyYWRlciBhY2NvdW50IGlkIHRvIGNvbm5lY3QgdG9cbiAgICovXG4gIGNvbnN0cnVjdG9yKHdlYnNvY2tldENsaWVudCwgYWNjb3VudCkge1xuICAgIHN1cGVyKHdlYnNvY2tldENsaWVudCwgYWNjb3VudCwgJ1JQQycpO1xuICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlck1hbmFnZXIuZ2V0TG9nZ2VyKCdNZXRhQXBpQ29ubmVjdGlvbicpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzKTtcbiAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBjb25uZWN0aW9uLiBDYW4gb25seSBiZSBjYWxsZWQgdGhlIGZpcnN0IHRpbWUsIG5leHQgY2FsbHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5lZFxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBpZiAoIXRoaXMuX29wZW5lZCkge1xuICAgICAgdGhpcy5fb3BlbmVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGFjY291bnRSZWdpb25zID0gdGhpcy5fYWNjb3VudC5hY2NvdW50UmVnaW9ucztcbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRBY2NvdW50Q2FjaGUodGhpcy5fYWNjb3VudC5pZCwgYWNjb3VudFJlZ2lvbnMpO1xuICAgICAgT2JqZWN0LmtleXMoYWNjb3VudFJlZ2lvbnMpLmZvckVhY2gocmVnaW9uID0+IHtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmVuc3VyZVN1YnNjcmliZShhY2NvdW50UmVnaW9uc1tyZWdpb25dLCAwKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmVuc3VyZVN1YnNjcmliZShhY2NvdW50UmVnaW9uc1tyZWdpb25dLCAxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uIFRoZSBpbnN0YW5jZSBvZiB0aGUgY2xhc3Mgc2hvdWxkIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyIHRoaXMgbWV0aG9kIGlzIGludm9rZWQuXG4gICAqL1xuICBhc3luYyBjbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZUFjY291bnRDYWNoZSh0aGlzLmFjY291bnQuaWQpO1xuICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IGluZm9ybWF0aW9uIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRBY2NvdW50SW5mb3JtYXRpb24vKS5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgZ2V0QWNjb3VudEluZm9ybWF0aW9uKCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRBY2NvdW50SW5mb3JtYXRpb24odGhpcy5fYWNjb3VudC5pZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBwb3NpdGlvbnMgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZFBvc2l0aW9ucy8pLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyUG9zaXRpb24+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGFycmF5IG9mIG9wZW4gcG9zaXRpb25zXG4gICAqL1xuICBnZXRQb3NpdGlvbnMoKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldFBvc2l0aW9ucyh0aGlzLl9hY2NvdW50LmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHNwZWNpZmljIHBvc2l0aW9uIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRQb3NpdGlvbi8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1ldGF0cmFkZXJQb3NpdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggTWV0YVRyYWRlciBwb3NpdGlvbiBmb3VuZFxuICAgKi9cbiAgZ2V0UG9zaXRpb24ocG9zaXRpb25JZCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRQb3NpdGlvbih0aGlzLl9hY2NvdW50LmlkLCBwb3NpdGlvbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9wZW4gb3JkZXJzIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRPcmRlcnMvKS5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyT3JkZXI+Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBvcGVuIE1ldGFUcmFkZXIgb3JkZXJzXG4gICAqL1xuICBnZXRPcmRlcnMoKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldE9yZGVycyh0aGlzLl9hY2NvdW50LmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHNwZWNpZmljIG9wZW4gb3JkZXIgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZE9yZGVyLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlcklkIG9yZGVyIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1ldGF0cmFkZXJPcmRlcj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggbWV0YXRyYWRlciBvcmRlciBmb3VuZFxuICAgKi9cbiAgZ2V0T3JkZXIob3JkZXJJZCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRPcmRlcih0aGlzLl9hY2NvdW50LmlkLCBvcmRlcklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaXN0b3J5IG9mIGNvbXBsZXRlZCBvcmRlcnMgZm9yIGEgc3BlY2lmaWMgdGlja2V0IG51bWJlciAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZEhpc3RvcnlPcmRlcnNCeVRpY2tldC8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGlja2V0IHRpY2tldCBudW1iZXIgKG9yZGVyIGlkKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVySGlzdG9yeU9yZGVycz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgaGlzdG9yeSBvcmRlcnMgZm91bmRcbiAgICovXG4gIGdldEhpc3RvcnlPcmRlcnNCeVRpY2tldCh0aWNrZXQpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0KHRoaXMuX2FjY291bnQuaWQsIHRpY2tldCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHBvc2l0aW9uIGlkIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkSGlzdG9yeU9yZGVyc0J5UG9zaXRpb24vKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVySGlzdG9yeU9yZGVycz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgaGlzdG9yeSBvcmRlcnMgZm91bmRcbiAgICovXG4gIGdldEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9uKHBvc2l0aW9uSWQpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24odGhpcy5fYWNjb3VudC5pZCwgcG9zaXRpb25JZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHRpbWUgcmFuZ2UgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZUhpc3RvcmljYWxEYXRhL3JlYWRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UvKVxuICAgKiBAcGFyYW0ge0RhdGV9IHN0YXJ0VGltZSBzdGFydCBvZiB0aW1lIHJhbmdlLCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtEYXRlfSBlbmRUaW1lIGVuZCBvZiB0aW1lIHJhbmdlLCBleGNsdXNpdmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBwYWdpbmF0aW9uIG9mZnNldCwgZGVmYXVsdCBpcyAwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCBwYWdpbmF0aW9uIGxpbWl0LCBkZWZhdWx0IGlzIDEwMDBcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckhpc3RvcnlPcmRlcnM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGhpc3Rvcnkgb3JkZXJzIGZvdW5kXG4gICAqL1xuICBnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2Uoc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQgPSAwLCBsaW1pdCA9IDEwMDApIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0SGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlKHRoaXMuX2FjY291bnQuaWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgb2Zmc2V0LCBsaW1pdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIHdpdGggYSBzcGVjaWZpYyB0aWNrZXQgbnVtYmVyIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkRGVhbHNCeVRpY2tldC8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGlja2V0IHRpY2tldCBudW1iZXIgKGRlYWwgaWQgZm9yIE1UNSBvciBvcmRlciBpZCBmb3IgTVQ0KVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyRGVhbHM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGRlYWxzIGZvdW5kXG4gICAqL1xuICBnZXREZWFsc0J5VGlja2V0KHRpY2tldCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXREZWFsc0J5VGlja2V0KHRoaXMuX2FjY291bnQuaWQsIHRpY2tldCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIGZvciBhIHNwZWNpZmljIHBvc2l0aW9uIGlkIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkRGVhbHNCeVBvc2l0aW9uLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGdldERlYWxzQnlQb3NpdGlvbihwb3NpdGlvbklkKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldERlYWxzQnlQb3NpdGlvbih0aGlzLl9hY2NvdW50LmlkLCBwb3NpdGlvbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcnkgZGVhbHMgd2l0aCBmb3IgYSBzcGVjaWZpYyB0aW1lIHJhbmdlIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkRGVhbHNCeVRpbWVSYW5nZS8pLlxuICAgKiBAcGFyYW0ge0RhdGV9IHN0YXJ0VGltZSBzdGFydCBvZiB0aW1lIHJhbmdlLCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtEYXRlfSBlbmRUaW1lIGVuZCBvZiB0aW1lIHJhbmdlLCBleGNsdXNpdmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBwYWdpbmF0aW9uIG9mZnNldCwgZGVmYXVsdCBpcyAwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCBwYWdpbmF0aW9uIGxpbWl0LCBkZWZhdWx0IGlzIDEwMDBcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckRlYWxzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBkZWFscyBmb3VuZFxuICAgKi9cbiAgZ2V0RGVhbHNCeVRpbWVSYW5nZShzdGFydFRpbWUsIGVuZFRpbWUsIG9mZnNldCA9IDAsIGxpbWl0ID0gMTAwMCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXREZWFsc0J5VGltZVJhbmdlKHRoaXMuX2FjY291bnQuaWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgb2Zmc2V0LCBsaW1pdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGF2YWlsYWJsZSBzeW1ib2xzIGZvciBhbiBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRTeW1ib2xzLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHN5bWJvbHMgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PHN0cmluZz4+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3ltYm9scyBhcmUgcmV0cmlldmVkXG4gICAqL1xuICBnZXRTeW1ib2xzKCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRTeW1ib2xzKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBzcGVjaWZpY2F0aW9uIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkU3ltYm9sU3BlY2lmaWNhdGlvbi8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBzcGVjaWZpY2F0aW9uIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbj59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzcGVjaWZpY2F0aW9uIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgZ2V0U3ltYm9sU3BlY2lmaWNhdGlvbihzeW1ib2wpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0U3ltYm9sU3BlY2lmaWNhdGlvbih0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBsYXRlc3QgcHJpY2UgZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRTeW1ib2xQcmljZS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBwcmljZSBmb3JcbiAgICogQHBhcmFtIHtib29sZWFufSBrZWVwU3Vic2NyaXB0aW9uIGlmIHNldCB0byB0cnVlLCB0aGUgYWNjb3VudCB3aWxsIGdldCBhIGxvbmctdGVybSBzdWJzY3JpcHRpb24gdG8gc3ltYm9sIG1hcmtldFxuICAgKiBkYXRhLiBMb25nLXRlcm0gc3Vic2NyaXB0aW9uIG1lYW5zIHRoYXQgb24gc3Vic2VxdWVudCBjYWxscyB5b3Ugd2lsbCBnZXQgdXBkYXRlZCB2YWx1ZSBmYXN0ZXIuIElmIHNldCB0byBmYWxzZSBvclxuICAgKiBub3Qgc2V0LCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgc2V0IHRvIGV4cGlyZSBpbiAxMiBtaW51dGVzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyU3ltYm9sUHJpY2U+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gcHJpY2UgaXMgcmV0cmlldmVkXG4gICAqL1xuICBnZXRTeW1ib2xQcmljZShzeW1ib2wsIGtlZXBTdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0U3ltYm9sUHJpY2UodGhpcy5fYWNjb3VudC5pZCwgc3ltYm9sLCBrZWVwU3Vic2NyaXB0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbGF0ZXN0IGNhbmRsZSBmb3IgYSBzeW1ib2wgYW5kIHRpbWVmcmFtZSAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkQ2FuZGxlLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIGNhbmRsZSBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWVmcmFtZSBkZWZpbmVzIHRoZSB0aW1lZnJhbWUgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZSBjYW5kbGUgbXVzdCBiZSBnZW5lcmF0ZWQuIEFsbG93ZWQgdmFsdWVzIGZvclxuICAgKiBNVDUgYXJlIDFtLCAybSwgM20sIDRtLCA1bSwgNm0sIDEwbSwgMTJtLCAxNW0sIDIwbSwgMzBtLCAxaCwgMmgsIDNoLCA0aCwgNmgsIDhoLCAxMmgsIDFkLCAxdywgMW1uLiBBbGxvd2VkIHZhbHVlc1xuICAgKiBmb3IgTVQ0IGFyZSAxbSwgNW0sIDE1bSAzMG0sIDFoLCA0aCwgMWQsIDF3LCAxbW5cbiAgICogQHBhcmFtIHtib29sZWFufSBrZWVwU3Vic2NyaXB0aW9uIGlmIHNldCB0byB0cnVlLCB0aGUgYWNjb3VudCB3aWxsIGdldCBhIGxvbmctdGVybSBzdWJzY3JpcHRpb24gdG8gc3ltYm9sIG1hcmtldFxuICAgKiBkYXRhLiBMb25nLXRlcm0gc3Vic2NyaXB0aW9uIG1lYW5zIHRoYXQgb24gc3Vic2VxdWVudCBjYWxscyB5b3Ugd2lsbCBnZXQgdXBkYXRlZCB2YWx1ZSBmYXN0ZXIuIElmIHNldCB0byBmYWxzZSBvclxuICAgKiBub3Qgc2V0LCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgc2V0IHRvIGV4cGlyZSBpbiAxMiBtaW51dGVzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyQ2FuZGxlPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGNhbmRsZSBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGdldENhbmRsZShzeW1ib2wsIHRpbWVmcmFtZSwga2VlcFN1YnNjcmlwdGlvbiA9IGZhbHNlKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldENhbmRsZSh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wsIHRpbWVmcmFtZSwga2VlcFN1YnNjcmlwdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGxhdGVzdCB0aWNrIGZvciBhIHN5bWJvbC4gTVQ0IEcxIGFjY291bnRzIGRvIG5vdCBzdXBwb3J0IHRoaXMgQVBJIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRUaWNrLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHRpY2sgZm9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFN1YnNjcmlwdGlvbiBpZiBzZXQgdG8gdHJ1ZSwgdGhlIGFjY291bnQgd2lsbCBnZXQgYSBsb25nLXRlcm0gc3Vic2NyaXB0aW9uIHRvIHN5bWJvbCBtYXJrZXRcbiAgICogZGF0YS4gTG9uZy10ZXJtIHN1YnNjcmlwdGlvbiBtZWFucyB0aGF0IG9uIHN1YnNlcXVlbnQgY2FsbHMgeW91IHdpbGwgZ2V0IHVwZGF0ZWQgdmFsdWUgZmFzdGVyLiBJZiBzZXQgdG8gZmFsc2Ugb3JcbiAgICogbm90IHNldCwgdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIHNldCB0byBleHBpcmUgaW4gMTIgbWludXRlcy5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclRpY2s+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGljayBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGdldFRpY2soc3ltYm9sLCBrZWVwU3Vic2NyaXB0aW9uID0gZmFsc2UpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0VGljayh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wsIGtlZXBTdWJzY3JpcHRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBsYXRlc3Qgb3JkZXIgYm9vayBmb3IgYSBzeW1ib2wuIE1UNCBhY2NvdW50cyBkbyBub3Qgc3VwcG9ydCB0aGlzIEFQSSAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkQm9vay8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBvcmRlciBib29rIGZvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBTdWJzY3JpcHRpb24gaWYgc2V0IHRvIHRydWUsIHRoZSBhY2NvdW50IHdpbGwgZ2V0IGEgbG9uZy10ZXJtIHN1YnNjcmlwdGlvbiB0byBzeW1ib2wgbWFya2V0XG4gICAqIGRhdGEuIExvbmctdGVybSBzdWJzY3JpcHRpb24gbWVhbnMgdGhhdCBvbiBzdWJzZXF1ZW50IGNhbGxzIHlvdSB3aWxsIGdldCB1cGRhdGVkIHZhbHVlIGZhc3Rlci4gSWYgc2V0IHRvIGZhbHNlIG9yXG4gICAqIG5vdCBzZXQsIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSBzZXQgdG8gZXhwaXJlIGluIDEyIG1pbnV0ZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJUaWNrPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIG9yZGVyIGJvb2sgaXMgcmV0cmlldmVkXG4gICAqL1xuICBnZXRCb29rKHN5bWJvbCwga2VlcFN1YnNjcmlwdGlvbiA9IGZhbHNlKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldEJvb2sodGhpcy5fYWNjb3VudC5pZCwgc3ltYm9sLCBrZWVwU3Vic2NyaXB0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlcnZlciB0aW1lIGZvciBhIHNwZWNpZmllZCBNZXRhVHJhZGVyIGFjY291bnQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZFNlcnZlclRpbWUvKS5cbiAgICogQHJldHVybnMge1Byb21pc2U8U2VydmVyVGltZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggc2VydmVyIHRpbWVcbiAgICovXG4gIGFzeW5jIGdldFNlcnZlclRpbWUoKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldFNlcnZlclRpbWUodGhpcy5fYWNjb3VudC5pZCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBlc3RhYmxpc2hlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwbGljYXMgbnVtYmVyIG9mIGFjY291bnQgcmVwbGljYXMgbGF1bmNoZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvbkNvbm5lY3RlZChpbnN0YW5jZUluZGV4LCByZXBsaWNhcykge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUuc3luY2hyb25pemVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhVHJhZGVyIHRlcm1pbmFsIHRlcm1pbmF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvbkRpc2Nvbm5lY3RlZChpbnN0YW5jZUluZGV4KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5zeW5jaHJvbml6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogZGlzY29ubmVjdGVkIGZyb20gYnJva2VyYCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3RyZWFtIGZvciBhbiBpbnN0YW5jZSBpbmRleCBpcyBjbG9zZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICovXG4gIGFzeW5jIG9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGEgZmxhZyBpbmRpY2F0aW5nIHN0YXR1cyBvZiBzdGF0ZSBzeW5jaHJvbml6YXRpb24gd2l0aCBNZXRhVHJhZGVyIHRlcm1pbmFsXG4gICAqL1xuICBpc1N5bmNocm9uaXplZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleClcbiAgICAgIC5tYXAoaW5zdGFuY2UgPT4gaW5zdGFuY2Uuc3luY2hyb25pemVkKVxuICAgICAgLmluY2x1ZGVzKHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIHVudGlsIHN5bmNocm9uaXphdGlvbiB0byBSUEMgYXBwbGljYXRpb24gaXMgY29tcGxldGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0SW5TZWNvbmRzIHN5bmNocm9uaXphdGlvbiB0aW1lb3V0IGluIHNlY29uZHNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiB0byBSUEMgYXBwbGljYXRpb24gaXMgY29tcGxldGVkXG4gICAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gaWYgYXBwbGljYXRpb24gZmFpbGVkIHRvIHN5bmNocm9uaXplIHdpdGggdGhlIHRlbWluYWwgd2l0aGluIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgd2FpdFN5bmNocm9uaXplZCh0aW1lb3V0SW5TZWNvbmRzPTMwMCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgc3luY2hyb25pemVkID0gdGhpcy5pc1N5bmNocm9uaXplZCgpO1xuICAgIHdoaWxlKCFzeW5jaHJvbml6ZWQgJiYgc3RhcnRUaW1lICsgdGltZW91dEluU2Vjb25kcyAqIDEwMDAgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMDApKTtcbiAgICAgIHN5bmNocm9uaXplZCA9IHRoaXMuaXNTeW5jaHJvbml6ZWQoKTtcbiAgICB9XG4gICAgaWYgKCFzeW5jaHJvbml6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBNZXRhQXBpIHRvIHN5bmNocm9uaXplIHRvIE1ldGFUcmFkZXIgYWNjb3VudCAnICtcbiAgICAgICAgdGhpcy5fYWNjb3VudC5pZCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3dlYnNvY2tldENsaWVudC53YWl0U3luY2hyb25pemVkKHRoaXMuX2FjY291bnQuaWQsIHVuZGVmaW5lZCwgJ1JQQycsIDUsICdSUEMnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYoRGF0ZS5ub3coKSA+IHN0YXJ0VGltZSArIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpIHtcbiAgICBpZighdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF0pIHtcbiAgICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlSW5kZXhdID0ge1xuICAgICAgICBpbnN0YW5jZUluZGV4LFxuICAgICAgICBzeW5jaHJvbml6ZWQ6IGZhbHNlLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlSW5kZXhdO1xuICB9XG5cbn1cbiJdfQ==