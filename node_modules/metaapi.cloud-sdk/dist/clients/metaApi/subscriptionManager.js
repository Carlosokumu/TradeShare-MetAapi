'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _logger = require('../../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Subscription manager to handle account subscription logic
 */
class SubscriptionManager {

  /**
   * Constructs the subscription manager
   * @param {MetaApiWebsocketClient} websocketClient websocket client to use for sending requests
   */
  constructor(websocketClient) {
    this._websocketClient = websocketClient;
    this._subscriptions = {};
    this._awaitingResubscribe = {};
    this._subscriptionState = {};
    this._logger = _logger2.default.getLogger('SubscriptionManager');
  }

  /**
   * Returns whether an account is currently subscribing
   * @param {String} accountId account id
   * @param {Number} instanceNumber instance index number
   * @returns {Boolean} whether an account is currently subscribing
   */
  isAccountSubscribing(accountId, instanceNumber) {
    if (instanceNumber !== undefined) {
      return (0, _keys2.default)(this._subscriptions).includes(accountId + ':' + instanceNumber);
    } else {
      for (let key of (0, _keys2.default)(this._subscriptions)) {
        if (key.startsWith(accountId)) {
          return true;
        }
      }
      return false;
    }
  }

  /**
   * Returns whether an instance is in disconnected retry mode
   * @param {String} accountId account id
   * @param {Number} instanceNumber instance index number
   * @returns {Boolean} whether an account is currently subscribing
   */
  isDisconnectedRetryMode(accountId, instanceNumber) {
    let instanceId = accountId + ':' + (instanceNumber || 0);
    return this._subscriptions[instanceId] ? this._subscriptions[instanceId].isDisconnectedRetryMode : false;
  }

  /**
   * Returns whether an account subscription is active
   * @param {String} accountId account id
   * @returns {Boolean} instance actual subscribe state
   */
  isSubscriptionActive(accountId) {
    return !!this._subscriptionState[accountId];
  }

  /**
   * Subscribes to the Metatrader terminal events
   * @param {String} accountId id of the MetaTrader account to subscribe to
   * @param {Number} instanceNumber instance index number
   * @returns {Promise} promise which resolves when subscription started
   */
  subscribe(accountId, instanceNumber) {
    this._subscriptionState[accountId] = true;
    return this._websocketClient.rpcRequest(accountId, { type: 'subscribe', instanceIndex: instanceNumber });
  }

  /**
   * Schedules to send subscribe requests to an account until cancelled
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   * @param {Boolean} isDisconnectedRetryMode whether to start subscription in disconnected retry
   * mode. Subscription task in disconnected mode will be immediately replaced when the status packet is received
   */
  async scheduleSubscribe(accountId, instanceNumber, isDisconnectedRetryMode = false) {
    const client = this._websocketClient;
    let instanceId = accountId + ':' + (instanceNumber || 0);
    if (!this._subscriptions[instanceId]) {
      this._subscriptions[instanceId] = {
        shouldRetry: true,
        task: null,
        waitTask: null,
        future: null,
        isDisconnectedRetryMode
      };
      let subscribeRetryIntervalInSeconds = 3;
      while (this._subscriptions[instanceId].shouldRetry) {
        let resolveSubscribe;
        this._subscriptions[instanceId].task = { promise: new _promise2.default(res => {
            resolveSubscribe = res;
          }) };
        this._subscriptions[instanceId].task.resolve = resolveSubscribe;
        // eslint-disable-next-line no-inner-declarations
        let subscribeTask = async () => {
          try {
            await this.subscribe(accountId, instanceNumber);
          } catch (err) {
            if (err.name === 'TooManyRequestsError') {
              const socketInstanceIndex = client.socketInstancesByAccounts[instanceNumber][accountId];
              if (err.metadata.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER') {
                this._logger.error(`${instanceId}: Failed to subscribe`, err);
              }
              if (['LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER', 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_SERVER', 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER_PER_SERVER'].includes(err.metadata.type)) {
                delete client.socketInstancesByAccounts[instanceNumber][accountId];
                client.lockSocketInstance(instanceNumber, socketInstanceIndex, this._websocketClient.getAccountRegion(accountId), err.metadata);
              } else {
                const retryTime = new Date(err.metadata.recommendedRetryTime).getTime();
                if (Date.now() + subscribeRetryIntervalInSeconds * 1000 < retryTime) {
                  await new _promise2.default(res => setTimeout(res, retryTime - Date.now() - subscribeRetryIntervalInSeconds * 1000));
                }
              }
            }
          }
          resolveSubscribe();
        };
        subscribeTask();
        await this._subscriptions[instanceId].task.promise;
        if (!this._subscriptions[instanceId].shouldRetry) {
          break;
        }
        const retryInterval = subscribeRetryIntervalInSeconds;
        subscribeRetryIntervalInSeconds = Math.min(subscribeRetryIntervalInSeconds * 2, 300);
        let resolve;
        let subscribePromise = new _promise2.default(res => {
          resolve = res;
        });
        this._subscriptions[instanceId].waitTask = setTimeout(() => {
          resolve(true);
        }, retryInterval * 1000);
        this._subscriptions[instanceId].future = { resolve, promise: subscribePromise };
        const result = await this._subscriptions[instanceId].future.promise;
        this._subscriptions[instanceId].future = null;
        if (!result) {
          break;
        }
      }
      delete this._subscriptions[instanceId];
    }
  }

  /**
   * Unsubscribe from account
   * @param {String} accountId id of the MetaTrader account to unsubscribe
   * @param {Number} instanceNumber instance index number
   * @returns {Promise} promise which resolves when socket unsubscribed
   */
  async unsubscribe(accountId, instanceNumber) {
    this.cancelAccount(accountId);
    delete this._subscriptionState[accountId];
    return this._websocketClient.rpcRequest(accountId, { type: 'unsubscribe', instanceIndex: instanceNumber });
  }

  /**
   * Cancels active subscription tasks for an instance id
   * @param {String} instanceId instance id to cancel subscription task for
   */
  cancelSubscribe(instanceId) {
    if (this._subscriptions[instanceId]) {
      const subscription = this._subscriptions[instanceId];
      if (subscription.future) {
        subscription.future.resolve(false);
        clearTimeout(subscription.waitTask);
      }
      if (subscription.task) {
        subscription.task.resolve(false);
      }
      subscription.shouldRetry = false;
    }
  }

  /**
   * Cancels active subscription tasks for an account
   * @param {String} accountId account id to cancel subscription tasks for
   */
  cancelAccount(accountId) {
    for (let instanceId of (0, _keys2.default)(this._subscriptions).filter(key => key.startsWith(accountId))) {
      this.cancelSubscribe(instanceId);
    }
    (0, _keys2.default)(this._awaitingResubscribe).forEach(instanceNumber => delete this._awaitingResubscribe[instanceNumber][accountId]);
  }

  /**
   * Invoked on account timeout.
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   */
  onTimeout(accountId, instanceNumber) {
    const region = this._websocketClient.getAccountRegion(accountId);
    if (this._websocketClient.socketInstancesByAccounts[instanceNumber][accountId] !== undefined && this._websocketClient.connected(instanceNumber, this._websocketClient.socketInstancesByAccounts[instanceNumber][accountId], region)) {
      this._logger.debug(`${accountId}:${instanceNumber}: scheduling subscribe because of account timeout`);
      this.scheduleSubscribe(accountId, instanceNumber, true);
    }
  }

  /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   */
  async onDisconnected(accountId, instanceNumber) {
    await new _promise2.default(res => setTimeout(res, Math.max(Math.random() * 5, 1) * 1000));
    if (this._websocketClient.socketInstancesByAccounts[instanceNumber][accountId] !== undefined) {
      this._logger.debug(`${accountId}:${instanceNumber}: scheduling subscribe because account disconnected`);
      this.scheduleSubscribe(accountId, instanceNumber, true);
    }
  }

  /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect.
   * @param {Number} instanceNumber instance index number
   * @param {Number} socketInstanceIndex socket instance index
   * @param {String[]} reconnectAccountIds account ids to reconnect
   */
  onReconnected(instanceNumber, socketInstanceIndex, reconnectAccountIds) {
    if (!this._awaitingResubscribe[instanceNumber]) {
      this._awaitingResubscribe[instanceNumber] = {};
    }
    try {
      const socketInstancesByAccounts = this._websocketClient.socketInstancesByAccounts[instanceNumber];
      for (let instanceId of (0, _keys2.default)(this._subscriptions)) {
        const accountId = instanceId.split(':')[0];
        if (socketInstancesByAccounts[accountId] === socketInstanceIndex) {
          this.cancelSubscribe(instanceId);
        }
      }
      reconnectAccountIds.forEach(async accountId => {
        try {
          if (!this._awaitingResubscribe[instanceNumber][accountId]) {
            this._awaitingResubscribe[instanceNumber][accountId] = true;
            while (this.isAccountSubscribing(accountId, instanceNumber)) {
              await new _promise2.default(res => setTimeout(res, 1000));
            }
            await new _promise2.default(res => setTimeout(res, Math.random() * 5000));
            if (this._awaitingResubscribe[instanceNumber][accountId]) {
              delete this._awaitingResubscribe[instanceNumber][accountId];
              this._logger.debug(`${accountId}:${instanceNumber}: scheduling subscribe because account reconnected`);
              this.scheduleSubscribe(accountId, instanceNumber);
            }
          }
        } catch (err) {
          this._logger.error(`${accountId}: Account resubscribe task failed`, err);
        }
      });
    } catch (err) {
      this._logger.error('Failed to process subscribe manager reconnected event', err);
    }
  }
}
exports.default = SubscriptionManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvc3Vic2NyaXB0aW9uTWFuYWdlci5lczYiXSwibmFtZXMiOlsiU3Vic2NyaXB0aW9uTWFuYWdlciIsImNvbnN0cnVjdG9yIiwid2Vic29ja2V0Q2xpZW50IiwiX3dlYnNvY2tldENsaWVudCIsIl9zdWJzY3JpcHRpb25zIiwiX2F3YWl0aW5nUmVzdWJzY3JpYmUiLCJfc3Vic2NyaXB0aW9uU3RhdGUiLCJfbG9nZ2VyIiwiTG9nZ2VyTWFuYWdlciIsImdldExvZ2dlciIsImlzQWNjb3VudFN1YnNjcmliaW5nIiwiYWNjb3VudElkIiwiaW5zdGFuY2VOdW1iZXIiLCJ1bmRlZmluZWQiLCJpbmNsdWRlcyIsImtleSIsInN0YXJ0c1dpdGgiLCJpc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZSIsImluc3RhbmNlSWQiLCJpc1N1YnNjcmlwdGlvbkFjdGl2ZSIsInN1YnNjcmliZSIsInJwY1JlcXVlc3QiLCJ0eXBlIiwiaW5zdGFuY2VJbmRleCIsInNjaGVkdWxlU3Vic2NyaWJlIiwiY2xpZW50Iiwic2hvdWxkUmV0cnkiLCJ0YXNrIiwid2FpdFRhc2siLCJmdXR1cmUiLCJzdWJzY3JpYmVSZXRyeUludGVydmFsSW5TZWNvbmRzIiwicmVzb2x2ZVN1YnNjcmliZSIsInByb21pc2UiLCJyZXMiLCJyZXNvbHZlIiwic3Vic2NyaWJlVGFzayIsImVyciIsIm5hbWUiLCJzb2NrZXRJbnN0YW5jZUluZGV4Iiwic29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cyIsIm1ldGFkYXRhIiwiZXJyb3IiLCJsb2NrU29ja2V0SW5zdGFuY2UiLCJnZXRBY2NvdW50UmVnaW9uIiwicmV0cnlUaW1lIiwiRGF0ZSIsInJlY29tbWVuZGVkUmV0cnlUaW1lIiwiZ2V0VGltZSIsIm5vdyIsInNldFRpbWVvdXQiLCJyZXRyeUludGVydmFsIiwiTWF0aCIsIm1pbiIsInN1YnNjcmliZVByb21pc2UiLCJyZXN1bHQiLCJ1bnN1YnNjcmliZSIsImNhbmNlbEFjY291bnQiLCJjYW5jZWxTdWJzY3JpYmUiLCJzdWJzY3JpcHRpb24iLCJjbGVhclRpbWVvdXQiLCJmaWx0ZXIiLCJmb3JFYWNoIiwib25UaW1lb3V0IiwicmVnaW9uIiwiY29ubmVjdGVkIiwiZGVidWciLCJvbkRpc2Nvbm5lY3RlZCIsIm1heCIsInJhbmRvbSIsIm9uUmVjb25uZWN0ZWQiLCJyZWNvbm5lY3RBY2NvdW50SWRzIiwic3BsaXQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7QUFFQTs7O0FBR2UsTUFBTUEsbUJBQU4sQ0FBMEI7O0FBRXZDOzs7O0FBSUFDLGNBQVlDLGVBQVosRUFBNkI7QUFDM0IsU0FBS0MsZ0JBQUwsR0FBd0JELGVBQXhCO0FBQ0EsU0FBS0UsY0FBTCxHQUFzQixFQUF0QjtBQUNBLFNBQUtDLG9CQUFMLEdBQTRCLEVBQTVCO0FBQ0EsU0FBS0Msa0JBQUwsR0FBMEIsRUFBMUI7QUFDQSxTQUFLQyxPQUFMLEdBQWVDLGlCQUFjQyxTQUFkLENBQXdCLHFCQUF4QixDQUFmO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BQyx1QkFBcUJDLFNBQXJCLEVBQWdDQyxjQUFoQyxFQUFnRDtBQUM5QyxRQUFHQSxtQkFBbUJDLFNBQXRCLEVBQWlDO0FBQy9CLGFBQU8sb0JBQVksS0FBS1QsY0FBakIsRUFBaUNVLFFBQWpDLENBQTBDSCxZQUFZLEdBQVosR0FBa0JDLGNBQTVELENBQVA7QUFDRCxLQUZELE1BRU87QUFDTCxXQUFLLElBQUlHLEdBQVQsSUFBZ0Isb0JBQVksS0FBS1gsY0FBakIsQ0FBaEIsRUFBa0Q7QUFDaEQsWUFBSVcsSUFBSUMsVUFBSixDQUFlTCxTQUFmLENBQUosRUFBK0I7QUFDN0IsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRCxhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVEOzs7Ozs7QUFNQU0sMEJBQXdCTixTQUF4QixFQUFtQ0MsY0FBbkMsRUFBbUQ7QUFDakQsUUFBSU0sYUFBYVAsWUFBWSxHQUFaLElBQW1CQyxrQkFBa0IsQ0FBckMs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SixPQUFMLENBQWEwRCxLQUFiLENBQW9CLEdBQUV0RCxTQUFVLElBQUdDLGNBQWUsb0RBQWxEO0FBQ0EsbUJBQUtZLGlCQUFMLENBQXVCYixTQUF2QixFQUFrQ0MsY0FBbEM7QUFDRDtBQUNGO0FBQ0YsU0FiRCxDQWFFLE9BQU93QixHQUFQLEVBQVk7QUFDWixlQUFLN0IsT0FBTCxDQUFha0MsS0FBYixDQUFvQixHQUFFOUIsU0FBVSxtQ0FBaEMsRUFBb0V5QixHQUFwRTtBQUNEO0FBQ0YsT0FqQkQ7QUFrQkQsS0ExQkQsQ0EwQkUsT0FBT0EsR0FBUCxFQUFZO0FBQ1osV0FBSzdCLE9BQUwsQ0FBYWtDLEtBQWIsQ0FBbUIsdURBQW5CLEVBQTRFTCxHQUE1RTtBQUNEO0FBQ0Y7QUF6UHNDO2tCQUFwQnBDLG1CIiwiZmlsZSI6InN1YnNjcmlwdGlvbk1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBMb2dnZXJNYW5hZ2VyIGZyb20gJy4uLy4uL2xvZ2dlcic7XG5cbi8qKlxuICogU3Vic2NyaXB0aW9uIG1hbmFnZXIgdG8gaGFuZGxlIGFjY291bnQgc3Vic2NyaXB0aW9uIGxvZ2ljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1YnNjcmlwdGlvbk1hbmFnZXIge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBzdWJzY3JpcHRpb24gbWFuYWdlclxuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9IHdlYnNvY2tldENsaWVudCB3ZWJzb2NrZXQgY2xpZW50IHRvIHVzZSBmb3Igc2VuZGluZyByZXF1ZXN0c1xuICAgKi9cbiAgY29uc3RydWN0b3Iod2Vic29ja2V0Q2xpZW50KSB7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50ID0gd2Vic29ja2V0Q2xpZW50O1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9hd2FpdGluZ1Jlc3Vic2NyaWJlID0ge307XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGUgPSB7fTtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignU3Vic2NyaXB0aW9uTWFuYWdlcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBhY2NvdW50IGlzIGN1cnJlbnRseSBzdWJzY3JpYmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2hldGhlciBhbiBhY2NvdW50IGlzIGN1cnJlbnRseSBzdWJzY3JpYmluZ1xuICAgKi9cbiAgaXNBY2NvdW50U3Vic2NyaWJpbmcoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGlmKGluc3RhbmNlTnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKS5pbmNsdWRlcyhhY2NvdW50SWQgKyAnOicgKyBpbnN0YW5jZU51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoYWNjb3VudElkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBpbnN0YW5jZSBpcyBpbiBkaXNjb25uZWN0ZWQgcmV0cnkgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2hldGhlciBhbiBhY2NvdW50IGlzIGN1cnJlbnRseSBzdWJzY3JpYmluZ1xuICAgKi9cbiAgaXNEaXNjb25uZWN0ZWRSZXRyeU1vZGUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGxldCBpbnN0YW5jZUlkID0gYWNjb3VudElkICsgJzonICsgKGluc3RhbmNlTnVtYmVyIHx8IDApO1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdID8gdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS5pc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBhY2NvdW50IHN1YnNjcmlwdGlvbiBpcyBhY3RpdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpbnN0YW5jZSBhY3R1YWwgc3Vic2NyaWJlIHN0YXRlXG4gICAqL1xuICBpc1N1YnNjcmlwdGlvbkFjdGl2ZShhY2NvdW50SWQpIHtcbiAgICByZXR1cm4gISF0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZVthY2NvdW50SWRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgdG8gdGhlIE1ldGF0cmFkZXIgdGVybWluYWwgZXZlbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byBzdWJzY3JpYmUgdG9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiBzdGFydGVkXG4gICAqL1xuICBzdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlW2FjY291bnRJZF0gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQucnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAnc3Vic2NyaWJlJywgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgdG8gc2VuZCBzdWJzY3JpYmUgcmVxdWVzdHMgdG8gYW4gYWNjb3VudCB1bnRpbCBjYW5jZWxsZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZSB3aGV0aGVyIHRvIHN0YXJ0IHN1YnNjcmlwdGlvbiBpbiBkaXNjb25uZWN0ZWQgcmV0cnlcbiAgICogbW9kZS4gU3Vic2NyaXB0aW9uIHRhc2sgaW4gZGlzY29ubmVjdGVkIG1vZGUgd2lsbCBiZSBpbW1lZGlhdGVseSByZXBsYWNlZCB3aGVuIHRoZSBzdGF0dXMgcGFja2V0IGlzIHJlY2VpdmVkXG4gICAqL1xuICBhc3luYyBzY2hlZHVsZVN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBpc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5fd2Vic29ja2V0Q2xpZW50O1xuICAgIGxldCBpbnN0YW5jZUlkID0gYWNjb3VudElkICsgJzonICsgKGluc3RhbmNlTnVtYmVyIHx8IDApO1xuICAgIGlmKCF0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdID0ge1xuICAgICAgICBzaG91bGRSZXRyeTogdHJ1ZSxcbiAgICAgICAgdGFzazogbnVsbCxcbiAgICAgICAgd2FpdFRhc2s6IG51bGwsXG4gICAgICAgIGZ1dHVyZTogbnVsbCxcbiAgICAgICAgaXNEaXNjb25uZWN0ZWRSZXRyeU1vZGVcbiAgICAgIH07XG4gICAgICBsZXQgc3Vic2NyaWJlUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDM7XG4gICAgICB3aGlsZSh0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdLnNob3VsZFJldHJ5KSB7XG4gICAgICAgIGxldCByZXNvbHZlU3Vic2NyaWJlO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdLnRhc2sgPSB7cHJvbWlzZTogbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgICAgIHJlc29sdmVTdWJzY3JpYmUgPSByZXM7XG4gICAgICAgIH0pfTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS50YXNrLnJlc29sdmUgPSByZXNvbHZlU3Vic2NyaWJlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5uZXItZGVjbGFyYXRpb25zXG4gICAgICAgIGxldCBzdWJzY3JpYmVUYXNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmKGVyci5uYW1lID09PSAnVG9vTWFueVJlcXVlc3RzRXJyb3InKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNvY2tldEluc3RhbmNlSW5kZXggPSBjbGllbnQuc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXTtcbiAgICAgICAgICAgICAgaWYgKGVyci5tZXRhZGF0YS50eXBlID09PSAnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHtpbnN0YW5jZUlkfTogRmFpbGVkIHRvIHN1YnNjcmliZWAsIGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKFsnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSJywgJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfU0VSVkVSJywgXG4gICAgICAgICAgICAgICAgJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfVVNFUl9QRVJfU0VSVkVSJ10uaW5jbHVkZXMoZXJyLm1ldGFkYXRhLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNsaWVudC5zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdO1xuICAgICAgICAgICAgICAgIGNsaWVudC5sb2NrU29ja2V0SW5zdGFuY2UoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIFxuICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKSwgZXJyLm1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeVRpbWUgPSBuZXcgRGF0ZShlcnIubWV0YWRhdGEucmVjb21tZW5kZWRSZXRyeVRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSArIHN1YnNjcmliZVJldHJ5SW50ZXJ2YWxJblNlY29uZHMgKiAxMDAwIDwgcmV0cnlUaW1lKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIHJldHJ5VGltZSAtIERhdGUubm93KCkgLVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVSZXRyeUludGVydmFsSW5TZWNvbmRzICogMTAwMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlU3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHN1YnNjcmliZVRhc2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS50YXNrLnByb21pc2U7XG4gICAgICAgIGlmKCF0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdLnNob3VsZFJldHJ5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IHN1YnNjcmliZVJldHJ5SW50ZXJ2YWxJblNlY29uZHM7XG4gICAgICAgIHN1YnNjcmliZVJldHJ5SW50ZXJ2YWxJblNlY29uZHMgPSBNYXRoLm1pbihzdWJzY3JpYmVSZXRyeUludGVydmFsSW5TZWNvbmRzICogMiwgMzAwKTtcbiAgICAgICAgbGV0IHJlc29sdmU7XG4gICAgICAgIGxldCBzdWJzY3JpYmVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdLndhaXRUYXNrID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSwgcmV0cnlJbnRlcnZhbCAqIDEwMDApO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdLmZ1dHVyZSA9IHtyZXNvbHZlLCBwcm9taXNlOiBzdWJzY3JpYmVQcm9taXNlfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS5mdXR1cmUucHJvbWlzZTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS5mdXR1cmUgPSBudWxsO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byB1bnN1YnNjcmliZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc29ja2V0IHVuc3Vic2NyaWJlZFxuICAgKi9cbiAgYXN5bmMgdW5zdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIHRoaXMuY2FuY2VsQWNjb3VudChhY2NvdW50SWQpO1xuICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZVthY2NvdW50SWRdO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQucnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAndW5zdWJzY3JpYmUnLCBpbnN0YW5jZUluZGV4OiBpbnN0YW5jZU51bWJlcn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYWN0aXZlIHN1YnNjcmlwdGlvbiB0YXNrcyBmb3IgYW4gaW5zdGFuY2UgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSWQgaW5zdGFuY2UgaWQgdG8gY2FuY2VsIHN1YnNjcmlwdGlvbiB0YXNrIGZvclxuICAgKi9cbiAgY2FuY2VsU3Vic2NyaWJlKGluc3RhbmNlSWQpIHtcbiAgICBpZih0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdKSB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdO1xuICAgICAgaWYoc3Vic2NyaXB0aW9uLmZ1dHVyZSkge1xuICAgICAgICBzdWJzY3JpcHRpb24uZnV0dXJlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBjbGVhclRpbWVvdXQoc3Vic2NyaXB0aW9uLndhaXRUYXNrKTtcbiAgICAgIH1cbiAgICAgIGlmKHN1YnNjcmlwdGlvbi50YXNrKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi50YXNrLnJlc29sdmUoZmFsc2UpO1xuICAgICAgfVxuICAgICAgc3Vic2NyaXB0aW9uLnNob3VsZFJldHJ5ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYWN0aXZlIHN1YnNjcmlwdGlvbiB0YXNrcyBmb3IgYW4gYWNjb3VudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWQgdG8gY2FuY2VsIHN1YnNjcmlwdGlvbiB0YXNrcyBmb3JcbiAgICovXG4gIGNhbmNlbEFjY291bnQoYWNjb3VudElkKSB7XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBvZiBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKS5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKGFjY291bnRJZCkpKSB7XG4gICAgICB0aGlzLmNhbmNlbFN1YnNjcmliZShpbnN0YW5jZUlkKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXModGhpcy5fYXdhaXRpbmdSZXN1YnNjcmliZSkuZm9yRWFjaChpbnN0YW5jZU51bWJlciA9PiBcbiAgICAgIGRlbGV0ZSB0aGlzLl9hd2FpdGluZ1Jlc3Vic2NyaWJlW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIGFjY291bnQgdGltZW91dC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICovXG4gIG9uVGltZW91dChhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSB7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKTtcbiAgICBpZih0aGlzLl93ZWJzb2NrZXRDbGllbnQuc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmNvbm5lY3RlZChpbnN0YW5jZU51bWJlciwgXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdLCByZWdpb24pKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7YWNjb3VudElkfToke2luc3RhbmNlTnVtYmVyfTogc2NoZWR1bGluZyBzdWJzY3JpYmUgYmVjYXVzZSBvZiBhY2NvdW50IHRpbWVvdXRgKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVTdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgdGVybWluYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKi9cbiAgYXN5bmMgb25EaXNjb25uZWN0ZWQoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgTWF0aC5tYXgoTWF0aC5yYW5kb20oKSAqIDUsIDEpICogMTAwMCkpO1xuICAgIGlmKHRoaXMuX3dlYnNvY2tldENsaWVudC5zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHthY2NvdW50SWR9OiR7aW5zdGFuY2VOdW1iZXJ9OiBzY2hlZHVsaW5nIHN1YnNjcmliZSBiZWNhdXNlIGFjY291bnQgZGlzY29ubmVjdGVkYCk7XG4gICAgICB0aGlzLnNjaGVkdWxlU3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhQXBpIHdlYnNvY2tldCBBUEkgcmVzdG9yZWQgYWZ0ZXIgYSBkaXNjb25uZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzb2NrZXRJbnN0YW5jZUluZGV4IHNvY2tldCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSByZWNvbm5lY3RBY2NvdW50SWRzIGFjY291bnQgaWRzIHRvIHJlY29ubmVjdFxuICAgKi9cbiAgb25SZWNvbm5lY3RlZChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVjb25uZWN0QWNjb3VudElkcykge1xuICAgIGlmKCF0aGlzLl9hd2FpdGluZ1Jlc3Vic2NyaWJlW2luc3RhbmNlTnVtYmVyXSkge1xuICAgICAgdGhpcy5fYXdhaXRpbmdSZXN1YnNjcmliZVtpbnN0YW5jZU51bWJlcl0gPSB7fTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNvY2tldEluc3RhbmNlc0J5QWNjb3VudHMgPSB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl07XG4gICAgICBmb3IobGV0IGluc3RhbmNlSWQgb2YgT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9ucykpe1xuICAgICAgICBjb25zdCBhY2NvdW50SWQgPSBpbnN0YW5jZUlkLnNwbGl0KCc6JylbMF07XG4gICAgICAgIGlmIChzb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF0gPT09IHNvY2tldEluc3RhbmNlSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLmNhbmNlbFN1YnNjcmliZShpbnN0YW5jZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb25uZWN0QWNjb3VudElkcy5mb3JFYWNoKGFzeW5jIGFjY291bnRJZCA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYoIXRoaXMuX2F3YWl0aW5nUmVzdWJzY3JpYmVbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0pIHtcbiAgICAgICAgICAgIHRoaXMuX2F3YWl0aW5nUmVzdWJzY3JpYmVbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUodGhpcy5pc0FjY291bnRTdWJzY3JpYmluZyhhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSkge1xuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgTWF0aC5yYW5kb20oKSAqIDUwMDApKTtcbiAgICAgICAgICAgIGlmKHRoaXMuX2F3YWl0aW5nUmVzdWJzY3JpYmVbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0pIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2F3YWl0aW5nUmVzdWJzY3JpYmVbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF07XG4gICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHthY2NvdW50SWR9OiR7aW5zdGFuY2VOdW1iZXJ9OiBzY2hlZHVsaW5nIHN1YnNjcmliZSBiZWNhdXNlIGFjY291bnQgcmVjb25uZWN0ZWRgKTtcbiAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHthY2NvdW50SWR9OiBBY2NvdW50IHJlc3Vic2NyaWJlIHRhc2sgZmFpbGVkYCwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIHN1YnNjcmliZSBtYW5hZ2VyIHJlY29ubmVjdGVkIGV2ZW50JywgZXJyKTtcbiAgICB9XG4gIH1cbn0iXX0=