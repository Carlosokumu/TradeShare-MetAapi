'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _metaApi = require('../metaApi.client');

var _metaApi2 = _interopRequireDefault(_metaApi);

var _logger = require('../../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * metaapi.cloud client API client (see https://metaapi.cloud/docs/client/)
 */
class ClientApiClient extends _metaApi2.default {

  /**
   * Constructs client API client instance
   * @param {HttpClient} httpClient HTTP client
   * @param {DomainClient} domainClient domain client
   */
  constructor(httpClient, domainClient) {
    super(httpClient, domainClient);
    this._host = 'https://mt-client-api-v1';
    this._retryIntervalInSeconds = 1;
    this._ignoredFieldListsCache = {
      lastUpdated: 0,
      data: null,
      requestPromise: null
    };
    this._logger = _logger2.default.getLogger('ClientApiClient');
  }

  /**
   * Type hashing ignored field lists
   * @typedef {Object} TypeHashingIgnoredFieldLists
   * @property {String[]} specification specification ignored fields
   * @property {String[]} position position ignored fields
   * @property {String[]} order order ignored fields
   */

  /**
   * Hashing ignored field lists
   * @typedef {Object} HashingIgnoredFieldLists
   * @property {TypeHashingIgnoredFieldLists} g1 g1 hashing ignored field lists
   * @property {TypeHashingIgnoredFieldLists} g2 g2 hashing ignored field lists
   */

  /**
   * Retrieves hashing ignored field lists
   * @param {String} region account region
   * @returns {Promise<HashingIgnoredFieldLists>} promise resolving with hashing ignored field lists
   */
  async getHashingIgnoredFieldLists(region) {
    if (!this._ignoredFieldListsCache.data || Date.now() - this._ignoredFieldListsCache.lastUpdated > 60 * 60 * 1000) {
      if (this._ignoredFieldListsCache.requestPromise) {
        await this._ignoredFieldListsCache.requestPromise;
      } else {
        let resolve, reject;
        this._ignoredFieldListsCache.requestPromise = new _promise2.default((res, rej) => {
          resolve = res, reject = rej;
        });
        let isCacheUpdated = false;
        while (!isCacheUpdated) {
          try {
            const host = await this._domainClient.getUrl(this._host, region);
            const opts = {
              url: `${host}/hashing-ignored-field-lists`,
              method: 'GET',
              json: true,
              headers: {
                'auth-token': this._token
              }
            };
            const response = await this._httpClient.request(opts, 'getHashingIgnoredFieldLists');
            this._ignoredFieldListsCache = { lastUpdated: Date.now(), data: response, requestPromise: null };
            resolve(response);
            isCacheUpdated = true;
            this._retryIntervalInSeconds = 1;
          } catch (err) {
            this._logger.error('Failed to update hashing ignored field list', err);
            this._retryIntervalInSeconds = Math.min(this._retryIntervalInSeconds * 2, 300);
            await new _promise2.default(res => setTimeout(res, this._retryIntervalInSeconds * 1000));
          }
        }
      }
    }
    return this._ignoredFieldListsCache.data;
  }
}
exports.default = ClientApiClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvY2xpZW50QXBpLmNsaWVudC5lczYiXSwibmFtZXMiOlsiQ2xpZW50QXBpQ2xpZW50IiwiTWV0YUFwaUNsaWVudCIsImNvbnN0cnVjdG9yIiwiaHR0cENsaWVudCIsImRvbWFpbkNsaWVudCIsIl9ob3N0IiwiX3JldHJ5SW50ZXJ2YWxJblNlY29uZHMiLCJfaWdub3JlZEZpZWxkTGlzdHNDYWNoZSIsImxhc3RVcGRhdGVkIiwiZGF0YSIsInJlcXVlc3RQcm9taXNlIiwiX2xvZ2dlciIsIkxvZ2dlck1hbmFnZXIiLCJnZXRMb2dnZXIiLCJnZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHMiLCJyZWdpb24iLCJEYXRlIiwibm93IiwicmVzb2x2ZSIsInJlamVjdCIsInJlcyIsInJlaiIsImlzQ2FjaGVVcGRhdGVkIiwiaG9zdCIsIl9kb21haW5DbGllbnQiLCJnZXRVcmwiLCJvcHRzIiwidXJsIiwibWV0aG9kIiwianNvbiIsImhlYWRlcnMiLCJfdG9rZW4iLCJyZXNwb25zZSIsIl9odHRwQ2xpZW50IiwicmVxdWVzdCIsImVyciIsImVycm9yIiwiTWF0aCIsIm1pbiIsInNldFRpbWVvdXQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7Ozs7O0FBRUE7OztBQUdlLE1BQU1BLGVBQU4sU0FBOEJDLGlCQUE5QixDQUE0Qzs7QUFFekQ7Ozs7O0FBS0FDLGNBQVlDLFVBQVosRUFBd0JDLFlBQXhCLEVBQXNDO0FBQ3BDLFVBQU1ELFVBQU4sRUFBa0JDLFlBQWxCO0FBQ0EsU0FBS0MsS0FBTCxHQUFhLDBCQUFiO0FBQ0EsU0FBS0MsdUJBQUwsR0FBK0IsQ0FBL0I7QUFDQSxTQUFLQyx1QkFBTCxHQUErQjtBQUM3QkMsbUJBQWEsQ0FEZ0I7QUFFN0JDLFlBQU0sSUFGdUI7QUFHN0JDLHNCQUFnQjtBQUhhLEtBQS9CO0FBS0EsU0FBS0MsT0FBTCxHQUFlQyxpQkFBY0MsU0FBZCxDQUF3QixpQkFBeEIsQ0FBZjtBQUNEOztBQUVEOzs7Ozs7OztBQVFBOzs7Ozs7O0FBT0E7Ozs7O0FBS0EsUUFBTUMsMkJBQU4sQ0FBa0NDLE1BQWxDLEVBQTBDO0FBQ3hDLFFBQUcsQ0FBQyxLQUFLUix1QkFBTCxDQUE2QkUsSUFBOUIsSUFBc0NPLEtBQUtDLEdBQUwsS0FBYSxLQUFLVix1QkFBTCxDQUE2QkMsV0FBMUMsR0FBd0QsS0FBSyxFQUFMLEdBQVUsSUFBM0csRUFBaUg7QUFDL0csVUFBRyxLQUFLRCx1QkFBTCxDQUE2QkcsY0FBaEMsRUFBZ0Q7QUFDOUMsY0FBTSxLQUFLSCx1QkFBTCxDQUE2QkcsY0FBbkM7QUFDRCxPQUZELE1BRU07QUFDSixZQUFJUSxPQUFKLEVBQWFDLE1BQWI7QUFDQSxhQUFLWix1QkFBTCxDQUE2QkcsY0FBN0IsR0FBOEMsc0JBQVksQ0FBQ1UsR0FBRCxFQUFNQyxHQUFOLEtBQWM7QUFDdEVILG9CQUFVRSxHQUFWLEVBQWVELFNBQVNFLEdBQXhCO0FBQ0QsU0FGNkMsQ0FBOUM7QUFHQSxZQUFJQyxpQkFBaUIsS0FBckI7QUFDQSxlQUFNLENBQUNBLGNBQVAsRUFBdUI7QUFDckIsY0FBSTtBQUNGLGtCQUFNQyxPQUFPLE1BQU0sS0FBS0MsYUFBTCxDQUFtQkMsTUFBbkIsQ0FBMEIsS0FBS3BCLEtBQS9CLEVBQXNDVSxNQUF0QyxDQUFuQjtBQUNBLGtCQUFNVyxPQUFPO0FBQ1hDLG1CQUFNLEdBQUVKLElBQUssOEJBREY7QUFFWEssc0JBQVEsS0FGRztBQUdYQyxvQkFBTSxJQUhLO0FBSVhDLHVCQUFTO0FBQ1AsOEJBQWMsS0FBS0M7QUFEWjtBQUpFLGFBQWI7QUFRQSxrQkFBTUMsV0FBVyxNQUFNLEtBQUtDLFdBQUwsQ0FBaUJDLE9BQWpCLENBQXlCUixJQUF6QixFQUErQiw2QkFBL0IsQ0FBdkI7QUFDQSxpQkFBS25CLHVCQUFMLEdBQStCLEVBQUVDLGFBQWFRLEtBQUtDLEdBQUwsRUFBZixFQUEyQlIsTUFBTXVCLFFBQWpDLEVBQTJDdEIsZ0JBQWdCLElBQTNELEVBQS9CO0FBQ0FRLG9CQUFRYyxRQUFSO0FBQ0FWLDZCQUFpQixJQUFqQjtBQUNBLGlCQUFLaEIsdUJBQUwsR0FBK0IsQ0FBL0I7QUFDRCxXQWZELENBZUUsT0FBTzZCLEdBQVAsRUFBWTtBQUNaLGlCQUFLeEIsT0FBTCxDQUFheUIsS0FBYixDQUFtQiw2Q0FBbkIsRUFBa0VELEdBQWxFO0FBQ0EsaUJBQUs3Qix1QkFBTCxHQUErQitCLEtBQUtDLEdBQUwsQ0FBUyxLQUFLaEMsdUJBQUwsR0FBK0IsQ0FBeEMsRUFBMkMsR0FBM0MsQ0FBL0I7QUFDQSxrQkFBTSxzQkFBWWMsT0FBT21CLFdBQVduQixHQUFYLEVBQWdCLEtBQUtkLHVCQUFMLEdBQStCLElBQS9DLENBQW5CLENBQU47QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNELFdBQU8sS0FBS0MsdUJBQUwsQ0FBNkJFLElBQXBDO0FBQ0Q7QUExRXdEO2tCQUF0Q1QsZSIsImZpbGUiOiJjbGllbnRBcGkuY2xpZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgTWV0YUFwaUNsaWVudCBmcm9tICcuLi9tZXRhQXBpLmNsaWVudCc7XG5pbXBvcnQgTG9nZ2VyTWFuYWdlciBmcm9tICcuLi8uLi9sb2dnZXInO1xuXG4vKipcbiAqIG1ldGFhcGkuY2xvdWQgY2xpZW50IEFQSSBjbGllbnQgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvKVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDbGllbnRBcGlDbGllbnQgZXh0ZW5kcyBNZXRhQXBpQ2xpZW50IHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBjbGllbnQgQVBJIGNsaWVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0h0dHBDbGllbnR9IGh0dHBDbGllbnQgSFRUUCBjbGllbnRcbiAgICogQHBhcmFtIHtEb21haW5DbGllbnR9IGRvbWFpbkNsaWVudCBkb21haW4gY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50LCBkb21haW5DbGllbnQpIHtcbiAgICBzdXBlcihodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRoaXMuX2hvc3QgPSAnaHR0cHM6Ly9tdC1jbGllbnQtYXBpLXYxJztcbiAgICB0aGlzLl9yZXRyeUludGVydmFsSW5TZWNvbmRzID0gMTtcbiAgICB0aGlzLl9pZ25vcmVkRmllbGRMaXN0c0NhY2hlID0ge1xuICAgICAgbGFzdFVwZGF0ZWQ6IDAsXG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgcmVxdWVzdFByb21pc2U6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlck1hbmFnZXIuZ2V0TG9nZ2VyKCdDbGllbnRBcGlDbGllbnQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUeXBlIGhhc2hpbmcgaWdub3JlZCBmaWVsZCBsaXN0c1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUeXBlSGFzaGluZ0lnbm9yZWRGaWVsZExpc3RzXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IHNwZWNpZmljYXRpb24gc3BlY2lmaWNhdGlvbiBpZ25vcmVkIGZpZWxkc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSBwb3NpdGlvbiBwb3NpdGlvbiBpZ25vcmVkIGZpZWxkc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSBvcmRlciBvcmRlciBpZ25vcmVkIGZpZWxkc1xuICAgKi9cblxuICAvKipcbiAgICogSGFzaGluZyBpZ25vcmVkIGZpZWxkIGxpc3RzXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEhhc2hpbmdJZ25vcmVkRmllbGRMaXN0c1xuICAgKiBAcHJvcGVydHkge1R5cGVIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHN9IGcxIGcxIGhhc2hpbmcgaWdub3JlZCBmaWVsZCBsaXN0c1xuICAgKiBAcHJvcGVydHkge1R5cGVIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHN9IGcyIGcyIGhhc2hpbmcgaWdub3JlZCBmaWVsZCBsaXN0c1xuICAgKi9cblxuICAvKipcbiAgICogUmV0cmlldmVzIGhhc2hpbmcgaWdub3JlZCBmaWVsZCBsaXN0c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVnaW9uIGFjY291bnQgcmVnaW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEhhc2hpbmdJZ25vcmVkRmllbGRMaXN0cz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggaGFzaGluZyBpZ25vcmVkIGZpZWxkIGxpc3RzXG4gICAqL1xuICBhc3luYyBnZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHMocmVnaW9uKSB7XG4gICAgaWYoIXRoaXMuX2lnbm9yZWRGaWVsZExpc3RzQ2FjaGUuZGF0YSB8fCBEYXRlLm5vdygpIC0gdGhpcy5faWdub3JlZEZpZWxkTGlzdHNDYWNoZS5sYXN0VXBkYXRlZCA+IDYwICogNjAgKiAxMDAwKSB7XG4gICAgICBpZih0aGlzLl9pZ25vcmVkRmllbGRMaXN0c0NhY2hlLnJlcXVlc3RQcm9taXNlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2lnbm9yZWRGaWVsZExpc3RzQ2FjaGUucmVxdWVzdFByb21pc2U7XG4gICAgICB9IGVsc2V7XG4gICAgICAgIGxldCByZXNvbHZlLCByZWplY3Q7XG4gICAgICAgIHRoaXMuX2lnbm9yZWRGaWVsZExpc3RzQ2FjaGUucmVxdWVzdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICByZXNvbHZlID0gcmVzLCByZWplY3QgPSByZWo7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaXNDYWNoZVVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUoIWlzQ2FjaGVVcGRhdGVkKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhvc3QgPSBhd2FpdCB0aGlzLl9kb21haW5DbGllbnQuZ2V0VXJsKHRoaXMuX2hvc3QsIHJlZ2lvbik7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgICB1cmw6IGAke2hvc3R9L2hhc2hpbmctaWdub3JlZC1maWVsZC1saXN0c2AsXG4gICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnYXV0aC10b2tlbic6IHRoaXMuX3Rva2VuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2h0dHBDbGllbnQucmVxdWVzdChvcHRzLCAnZ2V0SGFzaGluZ0lnbm9yZWRGaWVsZExpc3RzJyk7XG4gICAgICAgICAgICB0aGlzLl9pZ25vcmVkRmllbGRMaXN0c0NhY2hlID0geyBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKSwgZGF0YTogcmVzcG9uc2UsIHJlcXVlc3RQcm9taXNlOiBudWxsIH07XG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGlzQ2FjaGVVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JldHJ5SW50ZXJ2YWxJblNlY29uZHMgPSAxO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGhhc2hpbmcgaWdub3JlZCBmaWVsZCBsaXN0JywgZXJyKTtcbiAgICAgICAgICAgIHRoaXMuX3JldHJ5SW50ZXJ2YWxJblNlY29uZHMgPSBNYXRoLm1pbih0aGlzLl9yZXRyeUludGVydmFsSW5TZWNvbmRzICogMiwgMzAwKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgdGhpcy5fcmV0cnlJbnRlcnZhbEluU2Vjb25kcyAqIDEwMDApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2lnbm9yZWRGaWVsZExpc3RzQ2FjaGUuZGF0YTtcbiAgfVxufVxuIl19