'use strict';

var _httpClient = require('../httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _provisioningProfile = require('./provisioningProfile.client');

var _provisioningProfile2 = _interopRequireDefault(_provisioningProfile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const provisioningApiUrl = 'https://mt-provisioning-api-v1.agiliumtrade.agiliumtrade.ai';

/**
 * @test {ProvisioningProfileClient}
 */
describe('ProvisioningProfileClient', () => {

  let provisioningClient;
  const token = 'header.payload.sign';
  let httpClient = new _httpClient2.default();
  let domainClient;
  let sandbox;
  let requestStub;

  before(() => {
    sandbox = _sinon2.default.createSandbox();
  });

  beforeEach(() => {
    domainClient = {
      token,
      domain: 'agiliumtrade.agiliumtrade.ai',
      getUrl: () => {}
    };
    provisioningClient = new _provisioningProfile2.default(httpClient, domainClient);
    requestStub = sandbox.stub(httpClient, 'request');
  });

  afterEach(() => {
    sandbox.restore();
  });

  /**
   * @test {ProvisioningProfileClient#getProvisioningProfiles}
   */
  it('should retrieve provisioning profiles from API', async () => {
    let expected = [{
      _id: 'id',
      name: 'name',
      version: 4,
      status: 'active'
    }];
    requestStub.resolves(expected);
    let profiles = await provisioningClient.getProvisioningProfiles(5, 'active');
    profiles.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles`,
      method: 'GET',
      qs: {
        version: 5,
        status: 'active'
      },
      headers: {
        'auth-token': token
      },
      json: true
    }, 'getProvisioningProfiles');
  });

  /**
   * @test {MetatraderAccountClient#getProvisioningProfiles}
   */
  it('should not retrieve provisioning profiles from API with account token', async () => {
    domainClient.token = 'token';
    provisioningClient = new _provisioningProfile2.default(httpClient, domainClient);
    try {
      await provisioningClient.getProvisioningProfiles(5, 'active');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke getProvisioningProfiles method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ProvisioningProfileClient#getProvisioningProfile}
   */
  it('should retrieve provisioning profile from API', async () => {
    let expected = {
      _id: 'id',
      name: 'name',
      version: 4,
      status: 'active'
    };
    requestStub.resolves(expected);
    let profile = await provisioningClient.getProvisioningProfile('id');
    profile.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles/id`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'getProvisioningProfile');
  });

  /**
   * @test {MetatraderAccountClient#getProvisioningProfile}
   */
  it('should not retrieve provisioning profile from API with account token', async () => {
    domainClient.token = 'token';
    provisioningClient = new _provisioningProfile2.default(httpClient, domainClient);
    try {
      await provisioningClient.getProvisioningProfile('id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke getProvisioningProfile method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ProvisioningProfileClient#createProvisioningProfile}
   */
  it('should create provisioning profile via API', async () => {
    let expected = {
      id: 'id'
    };
    let profile = {
      name: 'name',
      version: 4
    };
    requestStub.resolves(expected);
    let id = await provisioningClient.createProvisioningProfile(profile);
    id.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles`,
      method: 'POST',
      body: profile,
      headers: {
        'auth-token': token
      },
      json: true
    }, 'createProvisioningProfile');
  });

  /**
   * @test {MetatraderAccountClient#createProvisioningProfile}
   */
  it('should not create provisioning profile via API with account token', async () => {
    domainClient.token = 'token';
    provisioningClient = new _provisioningProfile2.default(httpClient, domainClient);
    try {
      await provisioningClient.createProvisioningProfile({});
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke createProvisioningProfile method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ProvisioningProfileClient#uploadProvisioningProfileFile}
   */
  it('should upload file to a provisioning profile via API', async () => {
    let file = Buffer.from('test', 'utf8');
    await provisioningClient.uploadProvisioningProfileFile('id', 'servers.dat', file);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles/id/servers.dat`,
      method: 'PUT',
      headers: {
        'auth-token': token
      },
      formData: {
        file: {
          options: {
            filename: 'serverFile'
          },
          value: file
        }
      },
      json: true
    }, 'uploadProvisioningProfileFile');
  });

  /**
   * @test {MetatraderAccountClient#uploadProvisioningProfileFile}
   */
  it('should not upload provisioning profile file via API with account token', async () => {
    domainClient.token = 'token';
    provisioningClient = new _provisioningProfile2.default(httpClient, domainClient);
    try {
      await provisioningClient.uploadProvisioningProfileFile('id', 'servers.dat', {});
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke uploadProvisioningProfileFile method, because you have connected with account access' + ' token. Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ProvisioningProfileClient#deleteProvisioningProfile}
   */
  it('should delete provisioning profile via API', async () => {
    await provisioningClient.deleteProvisioningProfile('id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles/id`,
      method: 'DELETE',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'deleteProvisioningProfile');
  });

  /**
   * @test {MetatraderAccountClient#deleteProvisioningProfile}
   */
  it('should not delete provisioning profile via API with account token', async () => {
    domainClient.token = 'token';
    provisioningClient = new _provisioningProfile2.default(httpClient, domainClient);
    try {
      await provisioningClient.deleteProvisioningProfile('id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke deleteProvisioningProfile method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ProvisioningProfileClient#updateProvisioningProfile}
   */
  it('should update provisioning profile via API', async () => {
    await provisioningClient.updateProvisioningProfile('id', { name: 'new name' });
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles/id`,
      method: 'PUT',
      headers: {
        'auth-token': token
      },
      json: true,
      body: {
        name: 'new name'
      }
    }, 'updateProvisioningProfile');
  });

  /**
   * @test {MetatraderAccountClient#updateProvisioningProfile}
   */
  it('should not update provisioning profile via API with account token', async () => {
    domainClient.token = 'token';
    provisioningClient = new _provisioningProfile2.default(httpClient, domainClient);
    try {
      await provisioningClient.updateProvisioningProfile('id', { name: 'new name' });
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke updateProvisioningProfile method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvcHJvdmlzaW9uaW5nUHJvZmlsZS5jbGllbnQuc3BlYy5lczYiXSwibmFtZXMiOlsicHJvdmlzaW9uaW5nQXBpVXJsIiwiZGVzY3JpYmUiLCJwcm92aXNpb25pbmdDbGllbnQiLCJ0b2tlbiIsImh0dHBDbGllbnQiLCJIdHRwQ2xpZW50IiwiZG9tYWluQ2xpZW50Iiwic2FuZGJveCIsInJlcXVlc3RTdHViIiwiYmVmb3JlIiwic2lub24iLCJjcmVhdGVTYW5kYm94IiwiYmVmb3JlRWFjaCIsImRvbWFpbiIsImdldFVybCIsIlByb3Zpc2lvbmluZ1Byb2ZpbGVDbGllbnQiLCJzdHViIiwiYWZ0ZXJFYWNoIiwicmVzdG9yZSIsIml0IiwiZXhwZWN0ZWQiLCJfaWQiLCJuYW1lIiwidmVyc2lvbiIsInN0YXR1cyIsInJlc29sdmVzIiwicHJvZmlsZXMiLCJnZXRQcm92aXNpb25pbmdQcm9maWxlcyIsInNob3VsZCIsImVxdWFsIiwiYXNzZXJ0IiwiY2FsbGVkT25jZVdpdGhFeGFjdGx5IiwicmVxdWVzdCIsInVybCIsIm1ldGhvZCIsInFzIiwiaGVhZGVycyIsImpzb24iLCJmYWlsIiwiZXJyb3IiLCJtZXNzYWdlIiwicHJvZmlsZSIsImdldFByb3Zpc2lvbmluZ1Byb2ZpbGUiLCJpZCIsImNyZWF0ZVByb3Zpc2lvbmluZ1Byb2ZpbGUiLCJib2R5IiwiZmlsZSIsIkJ1ZmZlciIsImZyb20iLCJ1cGxvYWRQcm92aXNpb25pbmdQcm9maWxlRmlsZSIsImZvcm1EYXRhIiwib3B0aW9ucyIsImZpbGVuYW1lIiwidmFsdWUiLCJkZWxldGVQcm92aXNpb25pbmdQcm9maWxlIiwidXBkYXRlUHJvdmlzaW9uaW5nUHJvZmlsZSJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxxQkFBcUIsNkRBQTNCOztBQUVBOzs7QUFHQUMsU0FBUywyQkFBVCxFQUFzQyxNQUFNOztB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QURGO0FBUCtDLEtBQXZELEVBVUcsMkJBVkg7QUFXRCxHQWJEOztBQWVBOzs7QUFHQUgsS0FBRyxtRUFBSCxFQUF3RSxZQUFZO0FBQ2xGYixpQkFBYUgsS0FBYixHQUFxQixPQUFyQjtBQUNBRCx5QkFBcUIsSUFBSWEsNkJBQUosQ0FBOEJYLFVBQTlCLEVBQTBDRSxZQUExQyxDQUFyQjtBQUNBLFFBQUk7QUFDRixZQUFNSixtQkFBbUJxRCx5QkFBbkIsQ0FBNkMsSUFBN0MsRUFBbUQsRUFBQ2pDLE1BQU0sVUFBUCxFQUFuRCxDQUFOO0FBQ0FaLHNCQUFNb0IsTUFBTixDQUFhUSxJQUFiO0FBQ0QsS0FIRCxDQUdFLE9BQU9DLEtBQVAsRUFBYztBQUNkQSxZQUFNQyxPQUFOLENBQWNaLE1BQWQsQ0FBcUJDLEtBQXJCLENBQ0UsZ0hBQ0EsOEZBRkY7QUFJRDtBQUNGLEdBWkQ7QUFjRCxDQXJRRCIsImZpbGUiOiJwcm92aXNpb25pbmdQcm9maWxlLmNsaWVudC5zcGVjLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgSHR0cENsaWVudCBmcm9tICcuLi9odHRwQ2xpZW50JztcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XG5pbXBvcnQgUHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudCBmcm9tICcuL3Byb3Zpc2lvbmluZ1Byb2ZpbGUuY2xpZW50JztcblxuY29uc3QgcHJvdmlzaW9uaW5nQXBpVXJsID0gJ2h0dHBzOi8vbXQtcHJvdmlzaW9uaW5nLWFwaS12MS5hZ2lsaXVtdHJhZGUuYWdpbGl1bXRyYWRlLmFpJztcblxuLyoqXG4gKiBAdGVzdCB7UHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudH1cbiAqL1xuZGVzY3JpYmUoJ1Byb3Zpc2lvbmluZ1Byb2ZpbGVDbGllbnQnLCAoKSA9PiB7XG5cbiAgbGV0IHByb3Zpc2lvbmluZ0NsaWVudDtcbiAgY29uc3QgdG9rZW4gPSAnaGVhZGVyLnBheWxvYWQuc2lnbic7XG4gIGxldCBodHRwQ2xpZW50ID0gbmV3IEh0dHBDbGllbnQoKTtcbiAgbGV0IGRvbWFpbkNsaWVudDtcbiAgbGV0IHNhbmRib3g7XG4gIGxldCByZXF1ZXN0U3R1YjtcblxuICBiZWZvcmUoKCkgPT4ge1xuICAgIHNhbmRib3ggPSBzaW5vbi5jcmVhdGVTYW5kYm94KCk7XG4gIH0pO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudCA9IHtcbiAgICAgIHRva2VuLFxuICAgICAgZG9tYWluOiAnYWdpbGl1bXRyYWRlLmFnaWxpdW10cmFkZS5haScsXG4gICAgICBnZXRVcmw6ICgpID0+IHt9XG4gICAgfTtcbiAgICBwcm92aXNpb25pbmdDbGllbnQgPSBuZXcgUHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHJlcXVlc3RTdHViID0gc2FuZGJveC5zdHViKGh0dHBDbGllbnQsICdyZXF1ZXN0Jyk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgc2FuZGJveC5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7UHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudCNnZXRQcm92aXNpb25pbmdQcm9maWxlc31cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgcHJvdmlzaW9uaW5nIHByb2ZpbGVzIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IFt7XG4gICAgICBfaWQ6ICdpZCcsXG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICB2ZXJzaW9uOiA0LFxuICAgICAgc3RhdHVzOiAnYWN0aXZlJ1xuICAgIH1dO1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQuZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZXMoNSwgJ2FjdGl2ZScpO1xuICAgIHByb2ZpbGVzLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7cHJvdmlzaW9uaW5nQXBpVXJsfS91c2Vycy9jdXJyZW50L3Byb3Zpc2lvbmluZy1wcm9maWxlc2AsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcXM6IHtcbiAgICAgICAgdmVyc2lvbjogNSxcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJ1xuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSwgJ2dldFByb3Zpc2lvbmluZ1Byb2ZpbGVzJyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZXN9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCByZXRyaWV2ZSBwcm92aXNpb25pbmcgcHJvZmlsZXMgZnJvbSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudC50b2tlbiA9ICd0b2tlbic7XG4gICAgcHJvdmlzaW9uaW5nQ2xpZW50ID0gbmV3IFByb3Zpc2lvbmluZ1Byb2ZpbGVDbGllbnQoaHR0cENsaWVudCwgZG9tYWluQ2xpZW50KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJvdmlzaW9uaW5nQ2xpZW50LmdldFByb3Zpc2lvbmluZ1Byb2ZpbGVzKDUsICdhY3RpdmUnKTtcbiAgICAgIHNpbm9uLmFzc2VydC5mYWlsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGdldFByb3Zpc2lvbmluZ1Byb2ZpbGVzIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge1Byb3Zpc2lvbmluZ1Byb2ZpbGVDbGllbnQjZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZX1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgcHJvdmlzaW9uaW5nIHByb2ZpbGUgZnJvbSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGV4cGVjdGVkID0ge1xuICAgICAgX2lkOiAnaWQnLFxuICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgdmVyc2lvbjogNCxcbiAgICAgIHN0YXR1czogJ2FjdGl2ZSdcbiAgICB9O1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgcHJvZmlsZSA9IGF3YWl0IHByb3Zpc2lvbmluZ0NsaWVudC5nZXRQcm92aXNpb25pbmdQcm9maWxlKCdpZCcpO1xuICAgIHByb2ZpbGUuc2hvdWxkLmVxdWFsKGV4cGVjdGVkKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZVdpdGhFeGFjdGx5KGh0dHBDbGllbnQucmVxdWVzdCwge1xuICAgICAgdXJsOiBgJHtwcm92aXNpb25pbmdBcGlVcmx9L3VzZXJzL2N1cnJlbnQvcHJvdmlzaW9uaW5nLXByb2ZpbGVzL2lkYCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0sICdnZXRQcm92aXNpb25pbmdQcm9maWxlJyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZX1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHJldHJpZXZlIHByb3Zpc2lvbmluZyBwcm9maWxlIGZyb20gQVBJIHdpdGggYWNjb3VudCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBkb21haW5DbGllbnQudG9rZW4gPSAndG9rZW4nO1xuICAgIHByb3Zpc2lvbmluZ0NsaWVudCA9IG5ldyBQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50KGh0dHBDbGllbnQsIGRvbWFpbkNsaWVudCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHByb3Zpc2lvbmluZ0NsaWVudC5nZXRQcm92aXNpb25pbmdQcm9maWxlKCdpZCcpO1xuICAgICAgc2lub24uYXNzZXJ0LmZhaWwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZSBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50I2NyZWF0ZVByb3Zpc2lvbmluZ1Byb2ZpbGV9XG4gICAqL1xuICBpdCgnc2hvdWxkIGNyZWF0ZSBwcm92aXNpb25pbmcgcHJvZmlsZSB2aWEgQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IHtcbiAgICAgIGlkOiAnaWQnXG4gICAgfTtcbiAgICBsZXQgcHJvZmlsZSA9IHtcbiAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgIHZlcnNpb246IDRcbiAgICB9O1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgaWQgPSBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQuY3JlYXRlUHJvdmlzaW9uaW5nUHJvZmlsZShwcm9maWxlKTtcbiAgICBpZC5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9wcm92aXNpb25pbmctcHJvZmlsZXNgLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBwcm9maWxlLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9LCAnY3JlYXRlUHJvdmlzaW9uaW5nUHJvZmlsZScpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I2NyZWF0ZVByb3Zpc2lvbmluZ1Byb2ZpbGV9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCBjcmVhdGUgcHJvdmlzaW9uaW5nIHByb2ZpbGUgdmlhIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgZG9tYWluQ2xpZW50LnRva2VuID0gJ3Rva2VuJztcbiAgICBwcm92aXNpb25pbmdDbGllbnQgPSBuZXcgUHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQuY3JlYXRlUHJvdmlzaW9uaW5nUHJvZmlsZSh7fSk7XG4gICAgICBzaW5vbi5hc3NlcnQuZmFpbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBjcmVhdGVQcm92aXNpb25pbmdQcm9maWxlIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge1Byb3Zpc2lvbmluZ1Byb2ZpbGVDbGllbnQjdXBsb2FkUHJvdmlzaW9uaW5nUHJvZmlsZUZpbGV9XG4gICAqL1xuICBpdCgnc2hvdWxkIHVwbG9hZCBmaWxlIHRvIGEgcHJvdmlzaW9uaW5nIHByb2ZpbGUgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZmlsZSA9IEJ1ZmZlci5mcm9tKCd0ZXN0JywgJ3V0ZjgnKTtcbiAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQudXBsb2FkUHJvdmlzaW9uaW5nUHJvZmlsZUZpbGUoJ2lkJywgJ3NlcnZlcnMuZGF0JywgZmlsZSk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7cHJvdmlzaW9uaW5nQXBpVXJsfS91c2Vycy9jdXJyZW50L3Byb3Zpc2lvbmluZy1wcm9maWxlcy9pZC9zZXJ2ZXJzLmRhdGAsXG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAgZm9ybURhdGE6IHsgXG4gICAgICAgIGZpbGU6IHsgXG4gICAgICAgICAgb3B0aW9uczogeyBcbiAgICAgICAgICAgIGZpbGVuYW1lOiAnc2VydmVyRmlsZScgXG4gICAgICAgICAgfSwgXG4gICAgICAgICAgdmFsdWU6IGZpbGUgXG4gICAgICAgIH0gXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9LCAndXBsb2FkUHJvdmlzaW9uaW5nUHJvZmlsZUZpbGUnKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCN1cGxvYWRQcm92aXNpb25pbmdQcm9maWxlRmlsZX1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHVwbG9hZCBwcm92aXNpb25pbmcgcHJvZmlsZSBmaWxlIHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudC50b2tlbiA9ICd0b2tlbic7XG4gICAgcHJvdmlzaW9uaW5nQ2xpZW50ID0gbmV3IFByb3Zpc2lvbmluZ1Byb2ZpbGVDbGllbnQoaHR0cENsaWVudCwgZG9tYWluQ2xpZW50KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJvdmlzaW9uaW5nQ2xpZW50LnVwbG9hZFByb3Zpc2lvbmluZ1Byb2ZpbGVGaWxlKCdpZCcsICdzZXJ2ZXJzLmRhdCcsIHt9KTtcbiAgICAgIHNpbm9uLmFzc2VydC5mYWlsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIHVwbG9hZFByb3Zpc2lvbmluZ1Byb2ZpbGVGaWxlIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcycgK1xuICAgICAgICAnIHRva2VuLiBQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge1Byb3Zpc2lvbmluZ1Byb2ZpbGVDbGllbnQjZGVsZXRlUHJvdmlzaW9uaW5nUHJvZmlsZX1cbiAgICovXG4gIGl0KCdzaG91bGQgZGVsZXRlIHByb3Zpc2lvbmluZyBwcm9maWxlIHZpYSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgcHJvdmlzaW9uaW5nQ2xpZW50LmRlbGV0ZVByb3Zpc2lvbmluZ1Byb2ZpbGUoJ2lkJyk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7cHJvdmlzaW9uaW5nQXBpVXJsfS91c2Vycy9jdXJyZW50L3Byb3Zpc2lvbmluZy1wcm9maWxlcy9pZGAsXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9LCAnZGVsZXRlUHJvdmlzaW9uaW5nUHJvZmlsZScpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I2RlbGV0ZVByb3Zpc2lvbmluZ1Byb2ZpbGV9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCBkZWxldGUgcHJvdmlzaW9uaW5nIHByb2ZpbGUgdmlhIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgZG9tYWluQ2xpZW50LnRva2VuID0gJ3Rva2VuJztcbiAgICBwcm92aXNpb25pbmdDbGllbnQgPSBuZXcgUHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQuZGVsZXRlUHJvdmlzaW9uaW5nUHJvZmlsZSgnaWQnKTtcbiAgICAgIHNpbm9uLmFzc2VydC5mYWlsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGRlbGV0ZVByb3Zpc2lvbmluZ1Byb2ZpbGUgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7UHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudCN1cGRhdGVQcm92aXNpb25pbmdQcm9maWxlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCB1cGRhdGUgcHJvdmlzaW9uaW5nIHByb2ZpbGUgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQudXBkYXRlUHJvdmlzaW9uaW5nUHJvZmlsZSgnaWQnLCB7bmFtZTogJ25ldyBuYW1lJ30pO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9wcm92aXNpb25pbmctcHJvZmlsZXMvaWRgLFxuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIG5hbWU6ICduZXcgbmFtZSdcbiAgICAgIH1cbiAgICB9LCAndXBkYXRlUHJvdmlzaW9uaW5nUHJvZmlsZScpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I3VwZGF0ZVByb3Zpc2lvbmluZ1Byb2ZpbGV9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCB1cGRhdGUgcHJvdmlzaW9uaW5nIHByb2ZpbGUgdmlhIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgZG9tYWluQ2xpZW50LnRva2VuID0gJ3Rva2VuJztcbiAgICBwcm92aXNpb25pbmdDbGllbnQgPSBuZXcgUHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQudXBkYXRlUHJvdmlzaW9uaW5nUHJvZmlsZSgnaWQnLCB7bmFtZTogJ25ldyBuYW1lJ30pO1xuICAgICAgc2lub24uYXNzZXJ0LmZhaWwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgdXBkYXRlUHJvdmlzaW9uaW5nUHJvZmlsZSBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbn0pO1xuIl19