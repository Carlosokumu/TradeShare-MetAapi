'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _httpClient = require('../httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _clientApi = require('./clientApi.client');

var _clientApi2 = _interopRequireDefault(_clientApi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const clientApiUrl = 'https://mt-client-api-v1.agiliumtrade.agiliumtrade.ai';

/**
 * @test {ClientApiClient}
 */
describe('ClientApiClient', () => {

  let clientApiClient;
  const token = 'header.payload.sign';
  let httpClient = new _httpClient2.default();
  let domainClient;
  let sandbox;
  let requestStub;
  let clock;

  before(() => {
    sandbox = _sinon2.default.createSandbox();
  });

  beforeEach(() => {
    domainClient = {
      token,
      domain: 'agiliumtrade.agiliumtrade.ai',
      getUrl: () => {}
    };
    requestStub = sandbox.stub(httpClient, 'request');
    sandbox.stub(domainClient, 'getUrl').resolves(clientApiUrl);
    clientApiClient = new _clientApi2.default(httpClient, domainClient);
    clock = sandbox.useFakeTimers({
      shouldAdvanceTime: true,
      now: new Date('2020-10-05T07:00:00.000Z')
    });
  });

  afterEach(() => {
    sandbox.restore();
    clock.restore();
  });

  describe('getHashingIgnoredFieldLists', () => {

    let expected;
    beforeEach(() => {
      expected = {
        g1: {
          specification: ['description'],
          position: ['time'],
          order: ['expirationTime']
        },
        g2: {
          specification: ['pipSize'],
          position: ['comment'],
          order: ['brokerComment']
        }
      };
    });

    /**
     * @test {ClientApiClient#getHashingIgnoredFieldLists}
     */
    it('should retrieve hashing ignored field lists', async () => {
      requestStub.resolves(expected);
      let ignoredFields = await clientApiClient.getHashingIgnoredFieldLists();
      ignoredFields.should.equal(expected);
      _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
        url: `${clientApiUrl}/hashing-ignored-field-lists`,
        method: 'GET',
        json: true,
        headers: {
          'auth-token': token
        }
      }, 'getHashingIgnoredFieldLists');
    });

    /**
     * @test {ClientApiClient#getHashingIgnoredFieldLists}
     */
    it('should return cached data if requested recently', async () => {
      requestStub.resolves(expected);
      let ignoredFields = await clientApiClient.getHashingIgnoredFieldLists();
      ignoredFields.should.equal(expected);
      let ignoredFields2 = await clientApiClient.getHashingIgnoredFieldLists();
      ignoredFields2.should.equal(expected);
      _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
        url: `${clientApiUrl}/hashing-ignored-field-lists`,
        method: 'GET',
        json: true,
        headers: {
          'auth-token': token
        }
      }, 'getHashingIgnoredFieldLists');
    });

    /**
     * @test {ClientApiClient#getHashingIgnoredFieldLists}
     */
    it('should update data when caching time expired', async () => {
      requestStub.resolves(expected);
      let ignoredFields = await clientApiClient.getHashingIgnoredFieldLists();
      ignoredFields.should.equal(expected);
      await clock.tickAsync(61 * 60 * 1000);
      let ignoredFields2 = await clientApiClient.getHashingIgnoredFieldLists();
      ignoredFields2.should.equal(expected);
      _sinon2.default.assert.calledTwice(httpClient.request);
    });

    /**
     * @test {ClientApiClient#getHashingIgnoredFieldLists}
     */
    it('should send one request if two concurrent synchronizations', async () => {
      requestStub.callsFake(async arg => {
        await new _promise2.default(res => setTimeout(res, 50));
        return expected;
      });

      let ignoredFields = await _promise2.default.all([clientApiClient.getHashingIgnoredFieldLists(), clientApiClient.getHashingIgnoredFieldLists()]);
      ignoredFields[0].should.equal(expected);
      ignoredFields[1].should.equal(expected);
      _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
        url: `${clientApiUrl}/hashing-ignored-field-lists`,
        method: 'GET',
        json: true,
        headers: {
          'auth-token': token
        }
      }, 'getHashingIgnoredFieldLists');
    });

    /**
     * @test {ClientApiClient#getHashingIgnoredFieldLists}
     */
    it('should retry request if received error', async () => {
      let callNumber = 0;
      requestStub.callsFake(async arg => {
        await new _promise2.default(res => setTimeout(res, 50));
        callNumber++;
        if (callNumber < 3) {
          throw new Error('test');
        } else {
          return expected;
        }
      });

      let ignoredFields = [clientApiClient.getHashingIgnoredFieldLists(), clientApiClient.getHashingIgnoredFieldLists()];
      await clock.tickAsync(6000);
      ignoredFields = [await ignoredFields[0], await ignoredFields[1]];
      ignoredFields[0].should.equal(expected);
      ignoredFields[1].should.equal(expected);
      _sinon2.default.assert.callCount(httpClient.request, 3);
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvY2xpZW50QXBpLmNsaWVudC5zcGVjLmVzNiJdLCJuYW1lcyI6WyJjbGllbnRBcGlVcmwiLCJkZXNjcmliZSIsImNsaWVudEFwaUNsaWVudCIsInRva2VuIiwiaHR0cENsaWVudCIsIkh0dHBDbGllbnQiLCJkb21haW5DbGllbnQiLCJzYW5kYm94IiwicmVxdWVzdFN0dWIiLCJjbG9jayIsImJlZm9yZSIsInNpbm9uIiwiY3JlYXRlU2FuZGJveCIsImJlZm9yZUVhY2giLCJkb21haW4iLCJnZXRVcmwiLCJzdHViIiwicmVzb2x2ZXMiLCJDbGllbnRBcGlDbGllbnQiLCJ1c2VGYWtlVGltZXJzIiwic2hvdWxkQWR2YW5jZVRpbWUiLCJub3ciLCJEYXRlIiwiYWZ0ZXJFYWNoIiwicmVzdG9yZSIsImV4cGVjdGVkIiwiZzEiLCJzcGVjaWZpY2F0aW9uIiwicG9zaXRpb24iLCJvcmRlciIsImcyIiwiaXQiLCJpZ25vcmVkRmllbGRzIiwiZ2V0SGFzaGluZ0lnbm9yZWRGaWVsZExpc3RzIiwic2hvdWxkIiwiZXF1YWwiLCJhc3NlcnQiLCJjYWxsZWRPbmNlV2l0aEV4YWN0bHkiLCJyZXF1ZXN0IiwidXJsIiwibWV0aG9kIiwianNvbiIsImhlYWRlcnMiLCJpZ25vcmVkRmllbGRzMiIsInRpY2tBc3luYyIsImNhbGxlZFR3aWNlIiwiY2FsbHNGYWtlIiwiYXJnIiwicmVzIiwic2V0VGltZW91dCIsImFsbCIsImNhbGxOdW1iZXIiLCJFcnJvciIsImNhbGxDb3VudCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsZUFBZSx1REFBckI7O0FBRUE7OztBQUdBQyxTQUFTLGlCQUFULEVBQTRCLE1BQU07O0FBRWhDLE1BQUlDLGVBQUo7QUFDQSxRQUFNQyxRQUFRLHFCQUFkO0FBQ0EsTUFBSUMsYUFBYSxJQUFJQyxvQkFBSixFQUFqQjtBQUNBLE1BQUlDLFlB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T0MsV0FBV0QsR0FBWCxFQUFnQixFQUFoQixDQUFuQixDQUFOO0FBQ0FHO0FBQ0EsWUFBR0EsYUFBYSxDQUFoQixFQUFtQjtBQUNqQixnQkFBTSxJQUFJQyxLQUFKLENBQVUsTUFBVixDQUFOO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQU8zQixRQUFQO0FBQ0Q7QUFDRixPQVJEOztBQVVBLFVBQUlPLGdCQUFnQixDQUFDOUIsZ0JBQWdCK0IsMkJBQWhCLEVBQUQsRUFDbEIvQixnQkFBZ0IrQiwyQkFBaEIsRUFEa0IsQ0FBcEI7QUFFQSxZQUFNeEIsTUFBTW1DLFNBQU4sQ0FBZ0IsSUFBaEIsQ0FBTjtBQUNBWixzQkFBZ0IsQ0FBQyxNQUFNQSxjQUFjLENBQWQsQ0FBUCxFQUF5QixNQUFNQSxjQUFjLENBQWQsQ0FBL0IsQ0FBaEI7QUFDQUEsb0JBQWMsQ0FBZCxFQUFpQkUsTUFBakIsQ0FBd0JDLEtBQXhCLENBQThCVixRQUE5QjtBQUNBTyxvQkFBYyxDQUFkLEVBQWlCRSxNQUFqQixDQUF3QkMsS0FBeEIsQ0FBOEJWLFFBQTlCO0FBQ0FkLHNCQUFNeUIsTUFBTixDQUFhaUIsU0FBYixDQUF1QmpELFdBQVdrQyxPQUFsQyxFQUEyQyxDQUEzQztBQUNELEtBbkJEO0FBcUJELEdBbEhEO0FBb0hELENBdEpEIiwiZmlsZSI6ImNsaWVudEFwaS5jbGllbnQuc3BlYy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEh0dHBDbGllbnQgZnJvbSAnLi4vaHR0cENsaWVudCc7XG5pbXBvcnQgc2lub24gZnJvbSAnc2lub24nO1xuaW1wb3J0IENsaWVudEFwaUNsaWVudCBmcm9tICcuL2NsaWVudEFwaS5jbGllbnQnO1xuXG5jb25zdCBjbGllbnRBcGlVcmwgPSAnaHR0cHM6Ly9tdC1jbGllbnQtYXBpLXYxLmFnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWknO1xuXG4vKipcbiAqIEB0ZXN0IHtDbGllbnRBcGlDbGllbnR9XG4gKi9cbmRlc2NyaWJlKCdDbGllbnRBcGlDbGllbnQnLCAoKSA9PiB7XG5cbiAgbGV0IGNsaWVudEFwaUNsaWVudDtcbiAgY29uc3QgdG9rZW4gPSAnaGVhZGVyLnBheWxvYWQuc2lnbic7XG4gIGxldCBodHRwQ2xpZW50ID0gbmV3IEh0dHBDbGllbnQoKTtcbiAgbGV0IGRvbWFpbkNsaWVudDtcbiAgbGV0IHNhbmRib3g7XG4gIGxldCByZXF1ZXN0U3R1YjtcbiAgbGV0IGNsb2NrO1xuXG4gIGJlZm9yZSgoKSA9PiB7XG4gICAgc2FuZGJveCA9IHNpbm9uLmNyZWF0ZVNhbmRib3goKTtcbiAgfSk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgZG9tYWluQ2xpZW50ID0ge1xuICAgICAgdG9rZW4sXG4gICAgICBkb21haW46ICdhZ2lsaXVtdHJhZGUuYWdpbGl1bXRyYWRlLmFpJyxcbiAgICAgIGdldFVybDogKCkgPT4ge31cbiAgICB9O1xuICAgIHJlcXVlc3RTdHViID0gc2FuZGJveC5zdHViKGh0dHBDbGllbnQsICdyZXF1ZXN0Jyk7XG4gICAgc2FuZGJveC5zdHViKGRvbWFpbkNsaWVudCwgJ2dldFVybCcpLnJlc29sdmVzKGNsaWVudEFwaVVybCk7XG4gICAgY2xpZW50QXBpQ2xpZW50ID0gbmV3IENsaWVudEFwaUNsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIGNsb2NrID0gc2FuZGJveC51c2VGYWtlVGltZXJzKHtcbiAgICAgIHNob3VsZEFkdmFuY2VUaW1lOiB0cnVlLFxuICAgICAgbm93OiBuZXcgRGF0ZSgnMjAyMC0xMC0wNVQwNzowMDowMC4wMDBaJylcbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBzYW5kYm94LnJlc3RvcmUoKTtcbiAgICBjbG9jay5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHMnLCAoKSA9PiB7XG5cbiAgICBsZXQgZXhwZWN0ZWQ7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBleHBlY3RlZCA9IHtcbiAgICAgICAgZzE6IHtcbiAgICAgICAgICBzcGVjaWZpY2F0aW9uOiBbJ2Rlc2NyaXB0aW9uJ10sXG4gICAgICAgICAgcG9zaXRpb246IFsndGltZSddLFxuICAgICAgICAgIG9yZGVyOiBbJ2V4cGlyYXRpb25UaW1lJ11cbiAgICAgICAgfSxcbiAgICAgICAgZzI6IHtcbiAgICAgICAgICBzcGVjaWZpY2F0aW9uOiBbJ3BpcFNpemUnXSxcbiAgICAgICAgICBwb3NpdGlvbjogWydjb21tZW50J10sXG4gICAgICAgICAgb3JkZXI6IFsnYnJva2VyQ29tbWVudCddXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge0NsaWVudEFwaUNsaWVudCNnZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHN9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBoYXNoaW5nIGlnbm9yZWQgZmllbGQgbGlzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXF1ZXN0U3R1Yi5yZXNvbHZlcyhleHBlY3RlZCk7XG4gICAgICBsZXQgaWdub3JlZEZpZWxkcyA9IGF3YWl0IGNsaWVudEFwaUNsaWVudC5nZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHMoKTtcbiAgICAgIGlnbm9yZWRGaWVsZHMuc2hvdWxkLmVxdWFsKGV4cGVjdGVkKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICAgIHVybDogYCR7Y2xpZW50QXBpVXJsfS9oYXNoaW5nLWlnbm9yZWQtZmllbGQtbGlzdHNgLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgICB9XG4gICAgICB9LCAnZ2V0SGFzaGluZ0lnbm9yZWRGaWVsZExpc3RzJyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7Q2xpZW50QXBpQ2xpZW50I2dldEhhc2hpbmdJZ25vcmVkRmllbGRMaXN0c31cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHJldHVybiBjYWNoZWQgZGF0YSBpZiByZXF1ZXN0ZWQgcmVjZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXF1ZXN0U3R1Yi5yZXNvbHZlcyhleHBlY3RlZCk7XG4gICAgICBsZXQgaWdub3JlZEZpZWxkcyA9IGF3YWl0IGNsaWVudEFwaUNsaWVudC5nZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHMoKTtcbiAgICAgIGlnbm9yZWRGaWVsZHMuc2hvdWxkLmVxdWFsKGV4cGVjdGVkKTtcbiAgICAgIGxldCBpZ25vcmVkRmllbGRzMiA9IGF3YWl0IGNsaWVudEFwaUNsaWVudC5nZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHMoKTtcbiAgICAgIGlnbm9yZWRGaWVsZHMyLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZVdpdGhFeGFjdGx5KGh0dHBDbGllbnQucmVxdWVzdCwge1xuICAgICAgICB1cmw6IGAke2NsaWVudEFwaVVybH0vaGFzaGluZy1pZ25vcmVkLWZpZWxkLWxpc3RzYCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgICAgfVxuICAgICAgfSwgJ2dldEhhc2hpbmdJZ25vcmVkRmllbGRMaXN0cycpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge0NsaWVudEFwaUNsaWVudCNnZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHN9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgZGF0YSB3aGVuIGNhY2hpbmcgdGltZSBleHBpcmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgICAgbGV0IGlnbm9yZWRGaWVsZHMgPSBhd2FpdCBjbGllbnRBcGlDbGllbnQuZ2V0SGFzaGluZ0lnbm9yZWRGaWVsZExpc3RzKCk7XG4gICAgICBpZ25vcmVkRmllbGRzLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoNjEgKiA2MCAqIDEwMDApO1xuICAgICAgbGV0IGlnbm9yZWRGaWVsZHMyID0gYXdhaXQgY2xpZW50QXBpQ2xpZW50LmdldEhhc2hpbmdJZ25vcmVkRmllbGRMaXN0cygpO1xuICAgICAgaWdub3JlZEZpZWxkczIuc2hvdWxkLmVxdWFsKGV4cGVjdGVkKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRUd2ljZShodHRwQ2xpZW50LnJlcXVlc3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge0NsaWVudEFwaUNsaWVudCNnZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHN9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBzZW5kIG9uZSByZXF1ZXN0IGlmIHR3byBjb25jdXJyZW50IHN5bmNocm9uaXphdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXF1ZXN0U3R1Yi5jYWxsc0Zha2UoYXN5bmMgKGFyZykgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBsZXQgaWdub3JlZEZpZWxkcyA9IGF3YWl0IFByb21pc2UuYWxsKFtjbGllbnRBcGlDbGllbnQuZ2V0SGFzaGluZ0lnbm9yZWRGaWVsZExpc3RzKCksXG4gICAgICAgIGNsaWVudEFwaUNsaWVudC5nZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHMoKV0pO1xuICAgICAgaWdub3JlZEZpZWxkc1swXS5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgICAgaWdub3JlZEZpZWxkc1sxXS5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgICAgdXJsOiBgJHtjbGllbnRBcGlVcmx9L2hhc2hpbmctaWdub3JlZC1maWVsZC1saXN0c2AsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGpzb246IHRydWUsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICAgIH1cbiAgICAgIH0sICdnZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHMnKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtDbGllbnRBcGlDbGllbnQjZ2V0SGFzaGluZ0lnbm9yZWRGaWVsZExpc3RzfVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcmV0cnkgcmVxdWVzdCBpZiByZWNlaXZlZCBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBjYWxsTnVtYmVyID0gMDtcbiAgICAgIHJlcXVlc3RTdHViLmNhbGxzRmFrZShhc3luYyAoYXJnKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgICAgY2FsbE51bWJlcisrO1xuICAgICAgICBpZihjYWxsTnVtYmVyIDwgMykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGVzdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGxldCBpZ25vcmVkRmllbGRzID0gW2NsaWVudEFwaUNsaWVudC5nZXRIYXNoaW5nSWdub3JlZEZpZWxkTGlzdHMoKSxcbiAgICAgICAgY2xpZW50QXBpQ2xpZW50LmdldEhhc2hpbmdJZ25vcmVkRmllbGRMaXN0cygpXTtcbiAgICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYyg2MDAwKTtcbiAgICAgIGlnbm9yZWRGaWVsZHMgPSBbYXdhaXQgaWdub3JlZEZpZWxkc1swXSwgYXdhaXQgaWdub3JlZEZpZWxkc1sxXV07XG4gICAgICBpZ25vcmVkRmllbGRzWzBdLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgICBpZ25vcmVkRmllbGRzWzFdLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbENvdW50KGh0dHBDbGllbnQucmVxdWVzdCwgMyk7XG4gICAgfSk7XG5cbiAgfSk7XG5cbn0pO1xuIl19