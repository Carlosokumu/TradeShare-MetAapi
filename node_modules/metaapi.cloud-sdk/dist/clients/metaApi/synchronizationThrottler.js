'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _timeoutError = require('../timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _optionsValidator = require('../optionsValidator');

var _optionsValidator2 = _interopRequireDefault(_optionsValidator);

var _logger = require('../../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Options for synchronization throttler
 * @typedef {Object} SynchronizationThrottlerOpts
 * @property {Number} [maxConcurrentSynchronizations] amount of maximum allowed concurrent synchronizations
 * @property {Number} [queueTimeoutInSeconds] allowed time for a synchronization in queue
 * @property {Number} [synchronizationTimeoutInSeconds] time after which a synchronization slot
 * is freed to be used by another synchronization
 */

/**
 * Synchronization throttler used to limit the amount of concurrent synchronizations to prevent application
 * from being overloaded due to excessive number of synchronisation responses being sent.
 */
class SynchronizationThrottler {

  /**
   * Constructs the synchronization throttler
   * @param {MetaApiWebsocketClient} client MetaApi websocket client
   * @param {Number} socketInstanceIndex index of socket instance that uses the throttler
   * @param {Number} instanceNumber instance index number
   * @param {String} region server region
   * @param {SynchronizationThrottlerOpts} opts synchronization throttler options
   */
  constructor(client, socketInstanceIndex, instanceNumber, region, opts) {
    const validator = new _optionsValidator2.default();
    opts = opts || {};
    this._maxConcurrentSynchronizations = validator.validateNonZero(opts.maxConcurrentSynchronizations, 15, 'synchronizationThrottler.maxConcurrentSynchronizations');
    this._queueTimeoutInSeconds = validator.validateNonZero(opts.queueTimeoutInSeconds, 300, 'synchronizationThrottler.queueTimeoutInSeconds');
    this._synchronizationTimeoutInSeconds = validator.validateNonZero(opts.synchronizationTimeoutInSeconds, 10, 'synchronizationThrottler.synchronizationTimeoutInSeconds');
    this._client = client;
    this._region = region;
    this._socketInstanceIndex = socketInstanceIndex;
    this._synchronizationIds = {};
    this._accountsBySynchronizationIds = {};
    this._synchronizationQueue = [];
    this._removeOldSyncIdsInterval = null;
    this._processQueueInterval = null;
    this._instanceNumber = instanceNumber;
    this._logger = _logger2.default.getLogger('SynchronizationThrottler');
  }

  /**
   * Initializes the synchronization throttler
   */
  start() {
    if (!this._removeOldSyncIdsInterval) {
      this._removeOldSyncIdsInterval = setInterval(() => this._removeOldSyncIdsJob(), 1000);
      this._processQueueInterval = setInterval(() => this._processQueueJob(), 1000);
    }
  }

  /**
   * Deinitializes the throttler
   */
  stop() {
    clearInterval(this._removeOldSyncIdsInterval);
    this._removeOldSyncIdsInterval = null;
    clearInterval(this._processQueueInterval);
    this._processQueueInterval = null;
  }

  async _removeOldSyncIdsJob() {
    const now = Date.now();
    for (let key of (0, _keys2.default)(this._synchronizationIds)) {
      if (now - this._synchronizationIds[key] > this._synchronizationTimeoutInSeconds * 1000) {
        delete this._synchronizationIds[key];
      }
    }
    while (this._synchronizationQueue.length && Date.now() - this._synchronizationQueue[0].queueTime > this._queueTimeoutInSeconds * 1000) {
      this._removeFromQueue(this._synchronizationQueue[0].synchronizationId, 'timeout');
    }
    this._advanceQueue();
  }

  /**
   * Fills a synchronization slot with synchronization id
   * @param {String} synchronizationId synchronization id
   */
  updateSynchronizationId(synchronizationId) {
    if (this._accountsBySynchronizationIds[synchronizationId]) {
      this._synchronizationIds[synchronizationId] = Date.now();
    }
  }

  /**
   * Returns the list of currently synchronizing account ids
   */
  get synchronizingAccounts() {
    const synchronizingAccounts = [];
    (0, _keys2.default)(this._synchronizationIds).forEach(key => {
      const accountData = this._accountsBySynchronizationIds[key];
      if (accountData && !synchronizingAccounts.includes(accountData.accountId)) {
        synchronizingAccounts.push(accountData.accountId);
      }
    });
    return synchronizingAccounts;
  }

  /**
   * Returns the list of currenly active synchronization ids
   * @return {String[]} synchronization ids
   */
  get activeSynchronizationIds() {
    return (0, _keys2.default)(this._accountsBySynchronizationIds);
  }

  /**
   * Returns the amount of maximum allowed concurrent synchronizations
   * @return {number} maximum allowed concurrent synchronizations
   */
  get maxConcurrentSynchronizations() {
    const calculatedMax = Math.max(Math.ceil(this._client.subscribedAccountIds(this._instanceNumber, this._socketInstanceIndex, this._region).length / 10), 1);
    return Math.min(calculatedMax, this._maxConcurrentSynchronizations);
  }

  /**
   * Returns flag whether there are free slots for synchronization requests
   * @return {Boolean} flag whether there are free slots for synchronization requests
   */
  get isSynchronizationAvailable() {
    if (this._client.socketInstances[this._region][this._instanceNumber].reduce((acc, socketInstance) => acc + socketInstance.synchronizationThrottler.synchronizingAccounts.length, 0) >= this._maxConcurrentSynchronizations) {
      return false;
    }
    return this.synchronizingAccounts.length < this.maxConcurrentSynchronizations;
  }

  /**
   * Removes synchronizations from queue and from the list by parameters
   * @param {String} accountId account id
   * @param {Number} instanceIndex account instance index
   * @param {String} host account host name
   */
  removeIdByParameters(accountId, instanceIndex, host) {
    for (let key of (0, _keys2.default)(this._accountsBySynchronizationIds)) {
      if (this._accountsBySynchronizationIds[key].accountId === accountId && this._accountsBySynchronizationIds[key].instanceIndex === instanceIndex && this._accountsBySynchronizationIds[key].host === host) {
        this.removeSynchronizationId(key);
      }
    }
  }

  /**
   * Removes synchronization id from slots and removes ids for the same account from the queue
   * @param {String} synchronizationId synchronization id
   */
  removeSynchronizationId(synchronizationId) {
    if (this._accountsBySynchronizationIds[synchronizationId]) {
      const accountId = this._accountsBySynchronizationIds[synchronizationId].accountId;
      const instanceIndex = this._accountsBySynchronizationIds[synchronizationId].instanceIndex;
      const host = this._accountsBySynchronizationIds[synchronizationId].host;
      for (let key of (0, _keys2.default)(this._accountsBySynchronizationIds)) {
        if (this._accountsBySynchronizationIds[key].accountId === accountId && this._accountsBySynchronizationIds[key].instanceIndex === instanceIndex && this._accountsBySynchronizationIds[key].host === host) {
          this._removeFromQueue(key, 'cancel');
          delete this._accountsBySynchronizationIds[key];
        }
      }
    }
    if (this._synchronizationIds[synchronizationId]) {
      delete this._synchronizationIds[synchronizationId];
    }
    this._advanceQueue();
  }

  /**
   * Clears synchronization ids on disconnect
   */
  onDisconnect() {
    this._synchronizationQueue.forEach(synchronization => {
      synchronization.resolve('cancel');
    });
    this._synchronizationIds = {};
    this._accountsBySynchronizationIds = {};
    this._synchronizationQueue = [];
    this.stop();
    this.start();
  }

  _advanceQueue() {
    let index = 0;
    while (this.isSynchronizationAvailable && this._synchronizationQueue.length && index < this._synchronizationQueue.length) {
      const queueItem = this._synchronizationQueue[index];
      queueItem.resolve('synchronize');
      this.updateSynchronizationId(queueItem.synchronizationId);
      index++;
    }
  }

  _removeFromQueue(synchronizationId, result) {
    this._synchronizationQueue.forEach((syncItem, i) => {
      if (syncItem.synchronizationId === synchronizationId) {
        syncItem.resolve(result);
      }
    });
    this._synchronizationQueue = this._synchronizationQueue.filter(item => item.synchronizationId !== synchronizationId);
  }

  async _processQueueJob() {
    try {
      while (this._synchronizationQueue.length) {
        const queueItem = this._synchronizationQueue[0];
        await this._synchronizationQueue[0].promise;
        if (this._synchronizationQueue.length && this._synchronizationQueue[0].synchronizationId === queueItem.synchronizationId) {
          this._synchronizationQueue.shift();
        }
      }
    } catch (err) {
      this._logger.error('Error processing queue job', err);
    }
  }

  /**
   * Schedules to send a synchronization request for account
   * @param {String} accountId account id
   * @param {Object} request request to send
   * @param {Function} getHashes function to get terminal state hashes
   */
  async scheduleSynchronize(accountId, request, getHashes) {
    const synchronizationId = request.requestId;
    for (let key of (0, _keys2.default)(this._accountsBySynchronizationIds)) {
      if (this._accountsBySynchronizationIds[key].accountId === accountId && this._accountsBySynchronizationIds[key].instanceIndex === request.instanceIndex && this._accountsBySynchronizationIds[key].host === request.host) {
        this.removeSynchronizationId(key);
      }
    }
    this._accountsBySynchronizationIds[synchronizationId] = { accountId, instanceIndex: request.instanceIndex,
      host: request.host };
    if (!this.isSynchronizationAvailable) {
      let resolve;
      let requestResolve = new _promise2.default(res => {
        resolve = res;
      });
      this._synchronizationQueue.push({
        synchronizationId: synchronizationId,
        promise: requestResolve,
        resolve,
        queueTime: Date.now()
      });
      const result = await requestResolve;
      if (result === 'cancel') {
        return false;
      } else if (result === 'timeout') {
        throw new _timeoutError2.default(`Account ${accountId} synchronization ${synchronizationId}` + ' timed out in synchronization queue');
      }
    }
    this.updateSynchronizationId(synchronizationId);
    const hashes = await getHashes();
    request.specificationsMd5 = hashes.specificationsMd5;
    request.positionsMd5 = hashes.positionsMd5;
    request.ordersMd5 = hashes.ordersMd5;
    await this._client.rpcRequest(accountId, request);
    return true;
  }

}
exports.default = SynchronizationThrottler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLmVzNiJdLCJuYW1lcyI6WyJTeW5jaHJvbml6YXRpb25UaHJvdHRsZXIiLCJjb25zdHJ1Y3RvciIsImNsaWVudCIsInNvY2tldEluc3RhbmNlSW5kZXgiLCJpbnN0YW5jZU51bWJlciIsInJlZ2lvbiIsIm9wdHMiLCJ2YWxpZGF0b3IiLCJPcHRpb25zVmFsaWRhdG9yIiwiX21heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zIiwidmFsaWRhdGVOb25aZXJvIiwibWF4Q29uY3VycmVudFN5bmNocm9uaXphdGlvbnMiLCJfcXVldWVUaW1lb3V0SW5TZWNvbmRzIiwicXVldWVUaW1lb3V0SW5TZWNvbmRzIiwiX3N5bmNocm9uaXphdGlvblRpbWVvdXRJblNlY29uZHMiLCJzeW5jaHJvbml6YXRpb25UaW1lb3V0SW5TZWNvbmRzIiwiX2NsaWVudCIsIl9yZWdpb24iLCJfc29ja2V0SW5zdGFuY2VJbmRleCIsIl9zeW5jaHJvbml6YXRpb25JZHMiLCJfYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkcyIsIl9zeW5jaHJvbml6YXRpb25RdWV1ZSIsIl9yZW1vdmVPbGRTeW5jSWRzSW50ZXJ2YWwiLCJfcHJvY2Vzc1F1ZXVlSW50ZXJ2YWwiLCJfaW5zdGFuY2VOdW1iZXIiLCJfbG9nZ2VyIiwiTG9nZ2VyTWFuYWdlciIsImdldExvZ2dlciIsInN0YXJ0Iiwic2V0SW50ZXJ2YWwiLCJfcmVtb3ZlT2xkU3luY0lkc0pvYiIsIl9wcm9jZXNzUXVldWVKb2IiLCJzdG9wIiwiY2xlYXJJbnRlcnZhbCIsIm5vdyIsIkRhdGUiLCJrZXkiLCJsZW5ndGgiLCJxdWV1ZVRpbWUiLCJfcmVtb3ZlRnJvbVF1ZXVlIiwic3luY2hyb25pemF0aW9uSWQiLCJfYWR2YW5jZVF1ZXVlIiwidXBkYXRlU3luY2hyb25pemF0aW9uSWQiLCJzeW5jaHJvbml6aW5nQWNjb3VudHMiLCJmb3JFYWNoIiwiYWNjb3VudERhdGEiLCJpbmNsdWRlcyIsImFjY291bnRJZCIsInB1c2giLCJhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMiLCJjYWxjdWxhdGVkTWF4IiwiTWF0aCIsIm1heCIsImNlaWwiLCJzdWJzY3JpYmVkQWNjb3VudElkcyIsIm1pbiIsImlzU3luY2hyb25pemF0aW9uQXZhaWxhYmxlIiwic29ja2V0SW5zdGFuY2VzIiwicmVkdWNlIiwiYWNjIiwic29ja2V0SW5zdGFuY2UiLCJzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIiLCJyZW1vdmVJZEJ5UGFyYW1ldGVycyIsImluc3RhbmNlSW5kZXgiLCJob3N0IiwicmVtb3ZlU3luY2hyb25pemF0aW9uSWQiLCJvbkRpc2Nvbm5lY3QiLCJzeW5jaHJvbml6YXRpb24iLCJyZXNvbHZlIiwiaW5kZXgiLCJxdWV1ZUl0ZW0iLCJyZXN1bHQiLCJzeW5jSXRlbSIsImkiLCJmaWx0ZXIiLCJpdGVtIiwicHJvbWlzZSIsInNoaWZ0IiwiZXJyIiwiZXJyb3IiLCJzY2hlZHVsZVN5bmNocm9uaXplIiwicmVxdWVzdCIsImdldEhhc2hlcyIsInJlcXVlc3RJZCIsInJlcXVlc3RSZXNvbHZlIiwicmVzIiwiVGltZW91dEVycm9yIiwiaGFzaGVzIiwic3BlY2lmaWNhdGlvbnNNZDUiLCJwb3NpdGlvbnNNZDUiLCJvcmRlcnNNZDUiLCJycGNSZXF1ZXN0Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7Ozs7QUFTQTs7OztBQUllLE1BQU1BLHdCQUFOLENBQStCOztBQUU1Qzs7Ozs7Ozs7QUFRQUMsY0FBWUMsTUFBWixFQUFvQkMsbUJBQXBCLEVBQXlDQyxjQUF6QyxFQUF5REMsTUFBekQsRUFBaUVDLElBQWpFLEVBQXVFO0FBQ3JFLFVBQU1DLFlBQVksSUFBSUMsMEJBQUosRUFBbEI7QUFDQUYsV0FBT0EsUUFBUSxFQUFmO0FBQ0EsU0FBS0csOEJBQUwsR0FBc0NGLFVBQVVHLGVBQVYsQ0FB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LFVBQUlnQixpQkFBaUIsc0JBQWFDLEdBQUQsSUFBUztBQUN4Q2pCLGtCQUFVaUIsR0FBVjtBQUNELE9BRm9CLENBQXJCO0FBR0EsV0FBS2hFLHFCQUFMLENBQTJCMkIsSUFBM0IsQ0FBZ0M7QUFDOUJSLDJCQUFtQkEsaUJBRFc7QUFFOUJvQyxpQkFBU1EsY0FGcUI7QUFHOUJoQixlQUg4QjtBQUk5QjlCLG1CQUFXSCxLQUFLRCxHQUFMO0FBSm1CLE9BQWhDO0FBTUEsWUFBTXFDLFNBQVMsTUFBTWEsY0FBckI7QUFDQSxVQUFHYixXQUFXLFFBQWQsRUFBd0I7QUFDdEIsZUFBTyxLQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUdBLFdBQVcsU0FBZCxFQUF5QjtBQUM5QixjQUFNLElBQUllLHNCQUFKLENBQWtCLFdBQVV2QyxTQUFVLG9CQUFtQlAsaUJBQWtCLEVBQTFELEdBQ3ZCLHFDQURNLENBQU47QUFFRDtBQUNGO0FBQ0QsU0FBS0UsdUJBQUwsQ0FBNkJGLGlCQUE3QjtBQUNBLFVBQU0rQyxTQUFTLE1BQU1MLFdBQXJCO0FBQ0FELFlBQVFPLGlCQUFSLEdBQTRCRCxPQUFPQyxpQkFBbkM7QUFDQVAsWUFBUVEsWUFBUixHQUF1QkYsT0FBT0UsWUFBOUI7QUFDQVIsWUFBUVMsU0FBUixHQUFvQkgsT0FBT0csU0FBM0I7QUFDQSxVQUFNLEtBQUsxRSxPQUFMLENBQWEyRSxVQUFiLENBQXdCNUMsU0FBeEIsRUFBbUNrQyxPQUFuQyxDQUFOO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7O0FBN1AyQztrQkFBekJqRix3QiIsImZpbGUiOiJzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vdGltZW91dEVycm9yJztcbmltcG9ydCBPcHRpb25zVmFsaWRhdG9yIGZyb20gJy4uL29wdGlvbnNWYWxpZGF0b3InO1xuaW1wb3J0IExvZ2dlck1hbmFnZXIgZnJvbSAnLi4vLi4vbG9nZ2VyJztcblxuLyoqXG4gKiBPcHRpb25zIGZvciBzeW5jaHJvbml6YXRpb24gdGhyb3R0bGVyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTeW5jaHJvbml6YXRpb25UaHJvdHRsZXJPcHRzXG4gKiBAcHJvcGVydHkge051bWJlcn0gW21heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zXSBhbW91bnQgb2YgbWF4aW11bSBhbGxvd2VkIGNvbmN1cnJlbnQgc3luY2hyb25pemF0aW9uc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtxdWV1ZVRpbWVvdXRJblNlY29uZHNdIGFsbG93ZWQgdGltZSBmb3IgYSBzeW5jaHJvbml6YXRpb24gaW4gcXVldWVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3luY2hyb25pemF0aW9uVGltZW91dEluU2Vjb25kc10gdGltZSBhZnRlciB3aGljaCBhIHN5bmNocm9uaXphdGlvbiBzbG90XG4gKiBpcyBmcmVlZCB0byBiZSB1c2VkIGJ5IGFub3RoZXIgc3luY2hyb25pemF0aW9uXG4gKi9cblxuLyoqXG4gKiBTeW5jaHJvbml6YXRpb24gdGhyb3R0bGVyIHVzZWQgdG8gbGltaXQgdGhlIGFtb3VudCBvZiBjb25jdXJyZW50IHN5bmNocm9uaXphdGlvbnMgdG8gcHJldmVudCBhcHBsaWNhdGlvblxuICogZnJvbSBiZWluZyBvdmVybG9hZGVkIGR1ZSB0byBleGNlc3NpdmUgbnVtYmVyIG9mIHN5bmNocm9uaXNhdGlvbiByZXNwb25zZXMgYmVpbmcgc2VudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3luY2hyb25pemF0aW9uVGhyb3R0bGVyIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgc3luY2hyb25pemF0aW9uIHRocm90dGxlclxuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9IGNsaWVudCBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNvY2tldEluc3RhbmNlSW5kZXggaW5kZXggb2Ygc29ja2V0IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgdGhyb3R0bGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBzZXJ2ZXIgcmVnaW9uXG4gICAqIEBwYXJhbSB7U3luY2hyb25pemF0aW9uVGhyb3R0bGVyT3B0c30gb3B0cyBzeW5jaHJvbml6YXRpb24gdGhyb3R0bGVyIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgc29ja2V0SW5zdGFuY2VJbmRleCwgaW5zdGFuY2VOdW1iZXIsIHJlZ2lvbiwgb3B0cykge1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBPcHRpb25zVmFsaWRhdG9yKCk7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdGhpcy5fbWF4Q29uY3VycmVudFN5bmNocm9uaXphdGlvbnMgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMubWF4Q29uY3VycmVudFN5bmNocm9uaXphdGlvbnMsIDE1LFxuICAgICAgJ3N5bmNocm9uaXphdGlvblRocm90dGxlci5tYXhDb25jdXJyZW50U3luY2hyb25pemF0aW9ucycpO1xuICAgIHRoaXMuX3F1ZXVlVGltZW91dEluU2Vjb25kcyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy5xdWV1ZVRpbWVvdXRJblNlY29uZHMsIDMwMCxcbiAgICAgICdzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIucXVldWVUaW1lb3V0SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uVGltZW91dEluU2Vjb25kcyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy5zeW5jaHJvbml6YXRpb25UaW1lb3V0SW5TZWNvbmRzLCAxMCxcbiAgICAgICdzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuc3luY2hyb25pemF0aW9uVGltZW91dEluU2Vjb25kcycpO1xuICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLl9yZWdpb24gPSByZWdpb247XG4gICAgdGhpcy5fc29ja2V0SW5zdGFuY2VJbmRleCA9IHNvY2tldEluc3RhbmNlSW5kZXg7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uSWRzID0ge307XG4gICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkcyA9IHt9O1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlID0gW107XG4gICAgdGhpcy5fcmVtb3ZlT2xkU3luY0lkc0ludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLl9wcm9jZXNzUXVldWVJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy5faW5zdGFuY2VOdW1iZXIgPSBpbnN0YW5jZU51bWJlcjtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignU3luY2hyb25pemF0aW9uVGhyb3R0bGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHN5bmNocm9uaXphdGlvbiB0aHJvdHRsZXJcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmKCF0aGlzLl9yZW1vdmVPbGRTeW5jSWRzSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuX3JlbW92ZU9sZFN5bmNJZHNJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX3JlbW92ZU9sZFN5bmNJZHNKb2IoKSwgMTAwMCk7XG4gICAgICB0aGlzLl9wcm9jZXNzUXVldWVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX3Byb2Nlc3NRdWV1ZUpvYigpLCAxMDAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVpbml0aWFsaXplcyB0aGUgdGhyb3R0bGVyXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcmVtb3ZlT2xkU3luY0lkc0ludGVydmFsKTtcbiAgICB0aGlzLl9yZW1vdmVPbGRTeW5jSWRzSW50ZXJ2YWwgPSBudWxsO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcHJvY2Vzc1F1ZXVlSW50ZXJ2YWwpO1xuICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZUludGVydmFsID0gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIF9yZW1vdmVPbGRTeW5jSWRzSm9iKCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX3N5bmNocm9uaXphdGlvbklkcykpIHtcbiAgICAgIGlmICgobm93IC0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRzW2tleV0pID4gdGhpcy5fc3luY2hyb25pemF0aW9uVGltZW91dEluU2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbklkc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAodGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUubGVuZ3RoICYmIChEYXRlLm5vdygpIC0gdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWVbMF0ucXVldWVUaW1lKSA+IFxuICAgICAgICB0aGlzLl9xdWV1ZVRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tUXVldWUodGhpcy5fc3luY2hyb25pemF0aW9uUXVldWVbMF0uc3luY2hyb25pemF0aW9uSWQsICd0aW1lb3V0Jyk7XG4gICAgfVxuICAgIHRoaXMuX2FkdmFuY2VRdWV1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbGxzIGEgc3luY2hyb25pemF0aW9uIHNsb3Qgd2l0aCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiBpZFxuICAgKi9cbiAgdXBkYXRlU3luY2hyb25pemF0aW9uSWQoc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICBpZih0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXSkge1xuICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXSA9IERhdGUubm93KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgY3VycmVudGx5IHN5bmNocm9uaXppbmcgYWNjb3VudCBpZHNcbiAgICovXG4gIGdldCBzeW5jaHJvbml6aW5nQWNjb3VudHMoKSB7XG4gICAgY29uc3Qgc3luY2hyb25pemluZ0FjY291bnRzID0gW107XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3luY2hyb25pemF0aW9uSWRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBhY2NvdW50RGF0YSA9IHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNba2V5XTtcbiAgICAgIGlmKGFjY291bnREYXRhICYmICFzeW5jaHJvbml6aW5nQWNjb3VudHMuaW5jbHVkZXMoYWNjb3VudERhdGEuYWNjb3VudElkKSkge1xuICAgICAgICBzeW5jaHJvbml6aW5nQWNjb3VudHMucHVzaChhY2NvdW50RGF0YS5hY2NvdW50SWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzeW5jaHJvbml6aW5nQWNjb3VudHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBjdXJyZW5seSBhY3RpdmUgc3luY2hyb25pemF0aW9uIGlkc1xuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gc3luY2hyb25pemF0aW9uIGlkc1xuICAgKi9cbiAgZ2V0IGFjdGl2ZVN5bmNocm9uaXphdGlvbklkcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIG1heGltdW0gYWxsb3dlZCBjb25jdXJyZW50IHN5bmNocm9uaXphdGlvbnNcbiAgICogQHJldHVybiB7bnVtYmVyfSBtYXhpbXVtIGFsbG93ZWQgY29uY3VycmVudCBzeW5jaHJvbml6YXRpb25zXG4gICAqL1xuICBnZXQgbWF4Q29uY3VycmVudFN5bmNocm9uaXphdGlvbnMoKSB7XG4gICAgY29uc3QgY2FsY3VsYXRlZE1heCA9IE1hdGgubWF4KE1hdGguY2VpbChcbiAgICAgIHRoaXMuX2NsaWVudC5zdWJzY3JpYmVkQWNjb3VudElkcyh0aGlzLl9pbnN0YW5jZU51bWJlciwgdGhpcy5fc29ja2V0SW5zdGFuY2VJbmRleCwgdGhpcy5fcmVnaW9uKS5sZW5ndGggLyAxMCksIDEpO1xuICAgIHJldHVybiBNYXRoLm1pbihjYWxjdWxhdGVkTWF4LCB0aGlzLl9tYXhDb25jdXJyZW50U3luY2hyb25pemF0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIHdoZXRoZXIgdGhlcmUgYXJlIGZyZWUgc2xvdHMgZm9yIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0c1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmbGFnIHdoZXRoZXIgdGhlcmUgYXJlIGZyZWUgc2xvdHMgZm9yIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0c1xuICAgKi9cbiAgZ2V0IGlzU3luY2hyb25pemF0aW9uQXZhaWxhYmxlKCkge1xuICAgIGlmICh0aGlzLl9jbGllbnQuc29ja2V0SW5zdGFuY2VzW3RoaXMuX3JlZ2lvbl1bdGhpcy5faW5zdGFuY2VOdW1iZXJdLnJlZHVjZSgoYWNjLCBzb2NrZXRJbnN0YW5jZSkgPT4gXG4gICAgICBhY2MgKyBzb2NrZXRJbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuc3luY2hyb25pemluZ0FjY291bnRzLmxlbmd0aCwgMCkgPj1cbiAgICAgIHRoaXMuX21heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN5bmNocm9uaXppbmdBY2NvdW50cy5sZW5ndGggPCB0aGlzLm1heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3luY2hyb25pemF0aW9ucyBmcm9tIHF1ZXVlIGFuZCBmcm9tIHRoZSBsaXN0IGJ5IHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZUluZGV4IGFjY291bnQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGhvc3QgYWNjb3VudCBob3N0IG5hbWVcbiAgICovXG4gIHJlbW92ZUlkQnlQYXJhbWV0ZXJzKGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCwgaG9zdCkge1xuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzKSkge1xuICAgICAgaWYodGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1trZXldLmFjY291bnRJZCA9PT0gYWNjb3VudElkICYmXG4gICAgICAgICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1trZXldLmluc3RhbmNlSW5kZXggPT09IGluc3RhbmNlSW5kZXggJiZcbiAgICAgICAgICB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV0uaG9zdCA9PT0gaG9zdCkge1xuICAgICAgICB0aGlzLnJlbW92ZVN5bmNocm9uaXphdGlvbklkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3luY2hyb25pemF0aW9uIGlkIGZyb20gc2xvdHMgYW5kIHJlbW92ZXMgaWRzIGZvciB0aGUgc2FtZSBhY2NvdW50IGZyb20gdGhlIHF1ZXVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICovXG4gIHJlbW92ZVN5bmNocm9uaXphdGlvbklkKHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgaWYgKHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNbc3luY2hyb25pemF0aW9uSWRdKSB7XG4gICAgICBjb25zdCBhY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXS5hY2NvdW50SWQ7XG4gICAgICBjb25zdCBpbnN0YW5jZUluZGV4ID0gdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF0uaW5zdGFuY2VJbmRleDtcbiAgICAgIGNvbnN0IGhvc3QgPSB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXS5ob3N0O1xuICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHMpKSB7XG4gICAgICAgIGlmKHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNba2V5XS5hY2NvdW50SWQgPT09IGFjY291bnRJZCAmJiBcbiAgICAgICAgICB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV0uaW5zdGFuY2VJbmRleCA9PT0gaW5zdGFuY2VJbmRleCAmJlxuICAgICAgICAgIHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNba2V5XS5ob3N0ID09PSBob3N0KSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbVF1ZXVlKGtleSwgJ2NhbmNlbCcpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYodGhpcy5fc3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXSkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF07XG4gICAgfVxuICAgIHRoaXMuX2FkdmFuY2VRdWV1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBzeW5jaHJvbml6YXRpb24gaWRzIG9uIGRpc2Nvbm5lY3RcbiAgICovXG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZS5mb3JFYWNoKHN5bmNocm9uaXphdGlvbiA9PiB7XG4gICAgICBzeW5jaHJvbml6YXRpb24ucmVzb2x2ZSgnY2FuY2VsJyk7XG4gICAgfSk7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uSWRzID0ge307XG4gICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkcyA9IHt9O1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlID0gW107XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9XG5cbiAgX2FkdmFuY2VRdWV1ZSgpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlKHRoaXMuaXNTeW5jaHJvbml6YXRpb25BdmFpbGFibGUgJiYgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUubGVuZ3RoICYmIFxuICAgICAgICBpbmRleCA8IHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcXVldWVJdGVtID0gdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWVbaW5kZXhdO1xuICAgICAgcXVldWVJdGVtLnJlc29sdmUoJ3N5bmNocm9uaXplJyk7XG4gICAgICB0aGlzLnVwZGF0ZVN5bmNocm9uaXphdGlvbklkKHF1ZXVlSXRlbS5zeW5jaHJvbml6YXRpb25JZCk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIF9yZW1vdmVGcm9tUXVldWUoc3luY2hyb25pemF0aW9uSWQsIHJlc3VsdCkge1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlLmZvckVhY2goKHN5bmNJdGVtLCBpKSA9PiB7XG4gICAgICBpZihzeW5jSXRlbS5zeW5jaHJvbml6YXRpb25JZCA9PT0gc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICAgICAgc3luY0l0ZW0ucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlID0gdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUuZmlsdGVyKGl0ZW0gPT4gXG4gICAgICBpdGVtLnN5bmNocm9uaXphdGlvbklkICE9PSBzeW5jaHJvbml6YXRpb25JZCk7XG4gIH1cblxuICBhc3luYyBfcHJvY2Vzc1F1ZXVlSm9iKCkge1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlSXRlbSA9IHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlWzBdO1xuICAgICAgICBhd2FpdCB0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZVswXS5wcm9taXNlO1xuICAgICAgICBpZih0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZS5sZW5ndGggJiYgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWVbMF0uc3luY2hyb25pemF0aW9uSWQgPT09IFxuICAgICAgICAgICAgcXVldWVJdGVtLnN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIHF1ZXVlIGpvYicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyB0byBzZW5kIGEgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgZm9yIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IHJlcXVlc3QgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRIYXNoZXMgZnVuY3Rpb24gdG8gZ2V0IHRlcm1pbmFsIHN0YXRlIGhhc2hlc1xuICAgKi9cbiAgYXN5bmMgc2NoZWR1bGVTeW5jaHJvbml6ZShhY2NvdW50SWQsIHJlcXVlc3QsIGdldEhhc2hlcykge1xuICAgIGNvbnN0IHN5bmNocm9uaXphdGlvbklkID0gcmVxdWVzdC5yZXF1ZXN0SWQ7XG4gICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHMpKSB7XG4gICAgICBpZih0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV0uYWNjb3VudElkID09PSBhY2NvdW50SWQgJiZcbiAgICAgICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1trZXldLmluc3RhbmNlSW5kZXggPT09IHJlcXVlc3QuaW5zdGFuY2VJbmRleCAmJlxuICAgICAgICB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV0uaG9zdCA9PT0gcmVxdWVzdC5ob3N0KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU3luY2hyb25pemF0aW9uSWQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF0gPSB7YWNjb3VudElkLCBpbnN0YW5jZUluZGV4OiByZXF1ZXN0Lmluc3RhbmNlSW5kZXgsXG4gICAgICBob3N0OiByZXF1ZXN0Lmhvc3R9O1xuICAgIGlmKCF0aGlzLmlzU3luY2hyb25pemF0aW9uQXZhaWxhYmxlKSB7XG4gICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgIGxldCByZXF1ZXN0UmVzb2x2ZSA9IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUucHVzaCh7XG4gICAgICAgIHN5bmNocm9uaXphdGlvbklkOiBzeW5jaHJvbml6YXRpb25JZCxcbiAgICAgICAgcHJvbWlzZTogcmVxdWVzdFJlc29sdmUsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHF1ZXVlVGltZTogRGF0ZS5ub3coKVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0UmVzb2x2ZTtcbiAgICAgIGlmKHJlc3VsdCA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmKHJlc3VsdCA9PT0gJ3RpbWVvdXQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoYEFjY291bnQgJHthY2NvdW50SWR9IHN5bmNocm9uaXphdGlvbiAke3N5bmNocm9uaXphdGlvbklkfWAgK1xuICAgICAgICAnIHRpbWVkIG91dCBpbiBzeW5jaHJvbml6YXRpb24gcXVldWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51cGRhdGVTeW5jaHJvbml6YXRpb25JZChzeW5jaHJvbml6YXRpb25JZCk7XG4gICAgY29uc3QgaGFzaGVzID0gYXdhaXQgZ2V0SGFzaGVzKCk7XG4gICAgcmVxdWVzdC5zcGVjaWZpY2F0aW9uc01kNSA9IGhhc2hlcy5zcGVjaWZpY2F0aW9uc01kNTtcbiAgICByZXF1ZXN0LnBvc2l0aW9uc01kNSA9IGhhc2hlcy5wb3NpdGlvbnNNZDU7XG4gICAgcmVxdWVzdC5vcmRlcnNNZDUgPSBoYXNoZXMub3JkZXJzTWQ1O1xuICAgIGF3YWl0IHRoaXMuX2NsaWVudC5ycGNSZXF1ZXN0KGFjY291bnRJZCwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufSJdfQ==