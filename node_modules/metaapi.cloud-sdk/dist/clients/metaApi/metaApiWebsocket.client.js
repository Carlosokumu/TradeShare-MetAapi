'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _randomstring = require('randomstring');

var _randomstring2 = _interopRequireDefault(_randomstring);

var _socket = require('socket.io-client');

var _socket2 = _interopRequireDefault(_socket);

var _timeoutError = require('../timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _errorHandler = require('../errorHandler');

var _optionsValidator = require('../optionsValidator');

var _optionsValidator2 = _interopRequireDefault(_optionsValidator);

var _notSynchronizedError = require('./notSynchronizedError');

var _notSynchronizedError2 = _interopRequireDefault(_notSynchronizedError);

var _notConnectedError = require('./notConnectedError');

var _notConnectedError2 = _interopRequireDefault(_notConnectedError);

var _tradeError = require('./tradeError');

var _tradeError2 = _interopRequireDefault(_tradeError);

var _packetOrderer = require('./packetOrderer');

var _packetOrderer2 = _interopRequireDefault(_packetOrderer);

var _synchronizationThrottler = require('./synchronizationThrottler');

var _synchronizationThrottler2 = _interopRequireDefault(_synchronizationThrottler);

var _subscriptionManager = require('./subscriptionManager');

var _subscriptionManager2 = _interopRequireDefault(_subscriptionManager);

var _logger = require('../../logger');

var _logger2 = _interopRequireDefault(_logger);

var _promise3 = require('promise.any');

var _promise4 = _interopRequireDefault(_promise3);

var _latencyService = require('./latencyService');

var _latencyService2 = _interopRequireDefault(_latencyService);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let PacketLogger;
if (typeof window === 'undefined') {
  // don't import PacketLogger for browser version
  PacketLogger = require('./packetLogger').default;
}

/**
 * MetaApi websocket API client (see https://metaapi.cloud/docs/client/websocket/overview/)
 */
class MetaApiWebsocketClient {

  /**
   * Constructs MetaApi websocket API client instance
   * @param {DomainClient} domainClient domain client
   * @param {String} token authorization token
   * @param {Object} opts websocket client options
   */
  // eslint-disable-next-line complexity,max-statements
  constructor(domainClient, token, opts) {
    const validator = new _optionsValidator2.default();
    opts = opts || {};
    opts.packetOrderingTimeout = validator.validateNonZero(opts.packetOrderingTimeout, 60, 'packetOrderingTimeout');
    opts.synchronizationThrottler = opts.synchronizationThrottler || {};
    this._domainClient = domainClient;
    this._application = opts.application || 'MetaApi';
    this._domain = opts.domain || 'agiliumtrade.agiliumtrade.ai';
    this._region = opts.region;
    this._hostname = 'mt-client-api-v1';
    this._url = null;
    this._requestTimeout = validator.validateNonZero(opts.requestTimeout, 60, 'requestTimeout') * 1000;
    this._connectTimeout = validator.validateNonZero(opts.connectTimeout, 60, 'connectTimeout') * 1000;
    const retryOpts = opts.retryOpts || {};
    this._retries = validator.validateNumber(retryOpts.retries, 5, 'retryOpts.retries');
    this._minRetryDelayInSeconds = validator.validateNonZero(retryOpts.minDelayInSeconds, 1, 'retryOpts.minDelayInSeconds');
    this._maxRetryDelayInSeconds = validator.validateNonZero(retryOpts.maxDelayInSeconds, 30, 'retryOpts.maxDelayInSeconds');
    this._maxAccountsPerInstance = 100;
    this._subscribeCooldownInSeconds = validator.validateNonZero(retryOpts.subscribeCooldownInSeconds, 600, 'retryOpts.subscribeCooldownInSeconds');
    this._sequentialEventProcessing = true;
    this._useSharedClientApi = validator.validateBoolean(opts.useSharedClientApi, false, 'useSharedClientApi');
    this._unsubscribeThrottlingInterval = validator.validateNonZero(opts.unsubscribeThrottlingIntervalInSeconds, 10, 'unsubscribeThrottlingIntervalInSeconds') * 1000;
    this._socketMinimumReconnectTimeout = 500;
    this._latencyService = new _latencyService2.default(this, token, this._connectTimeout);
    this._token = token;
    this._synchronizationListeners = {};
    this._latencyListeners = [];
    this._reconnectListeners = [];
    this._connectedHosts = {};
    this._socketInstances = {};
    this._socketInstancesByAccounts = {};
    this._regionsByAccounts = {};
    this._accountsByReplicaId = {};
    this._accountReplicas = {};
    this._synchronizationThrottlerOpts = opts.synchronizationThrottler;
    this._subscriptionManager = new _subscriptionManager2.default(this);
    this._statusTimers = {};
    this._eventQueues = {};
    this._synchronizationFlags = {};
    this._synchronizationIdByInstance = {};
    this._subscribeLock = null;
    this._firstConnect = true;
    this._lastRequestsTime = {};
    this._packetOrderer = new _packetOrderer2.default(this, opts.packetOrderingTimeout);
    this._packetOrderer.start();
    if (opts.packetLogger && opts.packetLogger.enabled) {
      this._packetLogger = new PacketLogger(opts.packetLogger);
      this._packetLogger.start();
    }
    this._logger = _logger2.default.getLogger('MetaApiWebsocketClient');
    this._clearAccountCacheJob = this._clearAccountCacheJob.bind(this);
    setInterval(this._clearAccountCacheJob, 30 * 60 * 1000);
  }

  /**
   * Restarts the account synchronization process on an out of order packet
   * @param {String} accountId account id
   * @param {Number} instanceIndex instance index
   * @param {Number} expectedSequenceNumber expected s/n
   * @param {Number} actualSequenceNumber actual s/n
   * @param {Object} packet packet data
   * @param {Date} receivedAt time the packet was received at
   */
  onOutOfOrderPacket(accountId, instanceIndex, expectedSequenceNumber, actualSequenceNumber, packet, receivedAt) {
    if (this._subscriptionManager.isSubscriptionActive(accountId)) {
      this._logger.error('MetaApi websocket client received an out of order ' + `packet type ${packet.type} for account id ${accountId}:${instanceIndex}. Expected s/n ` + `${expectedSequenceNumber} does not match the actual of ${actualSequenceNumber}`);
      this.ensureSubscribe(accountId, instanceIndex);
    }
  }

  /**
   * Patch server URL for use in unit tests
   * @param {String} url patched server URL
   */
  set url(url) {
    this._url = url;
  }

  /**
   * Websocket client predefined region
   * @returns {String} predefined region
   */
  get region() {
    return this._region;
  }

  /**
   * Returns the list of socket instance dictionaries
   * @return {Object[]} list of socket instance dictionaries
   */
  get socketInstances() {
    return this._socketInstances;
  }

  /**
   * Returns the dictionary of socket instances by account ids
   * @return {Object} dictionary of socket instances by account ids
   */
  get socketInstancesByAccounts() {
    return this._socketInstancesByAccounts;
  }

  /**
   * Returns the dictionary of account replicas by region
   * @return {Object} dictionary of account replicas by region
   */
  get accountReplicas() {
    return this._accountReplicas;
  }

  /**
   * Returns the dictionary of primary account ids by replica ids
   * @return {Object} dictionary of primary account ids by replica ids
   */
  get accountsByReplicaId() {
    return this._accountsByReplicaId;
  }

  /**
   * Returns the list of subscribed account ids
   * @param {Number} instanceNumber instance index number
   * @param {String} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @return {string[]} list of subscribed account ids
   */
  subscribedAccountIds(instanceNumber, socketInstanceIndex, region) {
    const connectedIds = [];
    if (this._socketInstancesByAccounts[instanceNumber]) {
      (0, _keys2.default)(this._connectedHosts).forEach(instanceId => {
        const accountId = instanceId.split(':')[0];
        const accountRegion = this.getAccountRegion(accountId);
        if (!connectedIds.includes(accountId) && this._socketInstancesByAccounts[instanceNumber][accountId] !== undefined && (this._socketInstancesByAccounts[instanceNumber][accountId] === socketInstanceIndex || socketInstanceIndex === undefined) && accountRegion === region) {
          connectedIds.push(accountId);
        }
      });
    }
    return connectedIds;
  }

  /**
   * Returns websocket client connection status
   * @param {Number} instanceNumber instance index number
   * @param {Number} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @returns {Boolean} websocket client connection status
   */
  connected(instanceNumber, socketInstanceIndex, region) {
    const instance = this._socketInstances[region] && this._socketInstances[region][instanceNumber].length > socketInstanceIndex ? this._socketInstances[region][instanceNumber][socketInstanceIndex] : null;
    return instance && instance.socket && instance.socket.connected || false;
  }

  /**
   * Returns list of accounts assigned to instance
   * @param {Number} instanceNumber instance index number
   * @param {String} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @returns 
   */
  getAssignedAccounts(instanceNumber, socketInstanceIndex, region) {
    const accountIds = [];
    (0, _keys2.default)(this._socketInstancesByAccounts[instanceNumber]).forEach(key => {
      const accountRegion = this.getAccountRegion(key);
      if (accountRegion === region && this._socketInstancesByAccounts[instanceNumber][key] === socketInstanceIndex) {
        accountIds.push(key);
      }
    });
    return accountIds;
  }

  /**
   * Returns account region by id
   * @param {String} accountId account id
   * @returns {String} account region
   */
  getAccountRegion(accountId) {
    return this._regionsByAccounts[accountId] && this._regionsByAccounts[accountId].region;
  }

  /**
   * Adds account cache info
   * @param {String} accountId account id
   * @param {Object} replicas account replicas
   */
  addAccountCache(accountId, replicas) {
    this._accountReplicas[accountId] = replicas;
    (0, _keys2.default)(replicas).forEach(region => {
      const replicaId = replicas[region];
      if (!this._regionsByAccounts[replicaId]) {
        this._regionsByAccounts[replicaId] = {
          region,
          connections: 1,
          lastUsed: Date.now()
        };
      } else {
        this._regionsByAccounts[replicaId].connections++;
      }
      this._accountsByReplicaId[replicaId] = accountId;
    });
  }

  /**
   * Removes account region info
   * @param {String} accountId account id
   */
  removeAccountCache(accountId) {
    if (this._regionsByAccounts[accountId]) {
      if (this._regionsByAccounts[accountId].connections > 0) {
        this._regionsByAccounts[accountId].connections--;
      }
    }
  }

  /**
   * Locks subscription for a socket instance based on TooManyRequestsError metadata
   * @param {Number} instanceNumber instance index number
   * @param {String} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @param {Object} metadata TooManyRequestsError metadata
   */
  async lockSocketInstance(instanceNumber, socketInstanceIndex, region, metadata) {
    if (metadata.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER') {
      this._subscribeLock = {
        recommendedRetryTime: metadata.recommendedRetryTime,
        lockedAtAccounts: this.subscribedAccountIds(instanceNumber, undefined, region).length,
        lockedAtTime: Date.now()
      };
    } else {
      const subscribedAccounts = this.subscribedAccountIds(instanceNumber, socketInstanceIndex, region);
      if (subscribedAccounts.length === 0) {
        const socketInstance = this.socketInstances[region][instanceNumber][socketInstanceIndex];
        socketInstance.socket.close();
        await this._reconnect(instanceNumber, socketInstanceIndex, region);
      } else {
        const instance = this.socketInstances[region][instanceNumber][socketInstanceIndex];
        instance.subscribeLock = {
          recommendedRetryTime: metadata.recommendedRetryTime,
          type: metadata.type,
          lockedAtAccounts: subscribedAccounts.length
        };
      }
    }
  }

  /**
   * Connects to MetaApi server via socket.io protocol
   * @param {Number} instanceNumber instance index number
   * @param {String} region server region
   * @returns {Promise} promise which resolves when connection is established
   */
  async connect(instanceNumber, region) {
    let clientId = Math.random();
    let resolve;
    let result = new _promise2.default((res, rej) => {
      resolve = res;
    });
    const socketInstanceIndex = this._socketInstances[region][instanceNumber].length;
    const instance = {
      id: socketInstanceIndex,
      reconnectWaitTime: this._socketMinimumReconnectTimeout,
      connected: false,
      requestResolves: {},
      resolved: false,
      connectResult: result,
      sessionId: _randomstring2.default.generate(32),
      isReconnecting: false,
      socket: null,
      synchronizationThrottler: new _synchronizationThrottler2.default(this, socketInstanceIndex, instanceNumber, region, this._synchronizationThrottlerOpts),
      subscribeLock: null,
      instanceNumber
    };
    instance.connected = true;
    this._socketInstances[region][instanceNumber].push(instance);
    instance.synchronizationThrottler.start();
    const serverUrl = await this._getServerUrl(instanceNumber, socketInstanceIndex, region);
    const socketInstance = (0, _socket2.default)(serverUrl, {
      path: '/ws',
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: Infinity,
      timeout: this._connectTimeout,
      extraHeaders: {
        'Client-Id': clientId
      },
      query: {
        'auth-token': this._token,
        clientId: clientId,
        protocol: 3
      }
    });
    instance.socket = socketInstance;
    socketInstance.on('connect', async () => {
      // eslint-disable-next-line no-console
      this._logger.info(`${region}:${instanceNumber}: MetaApi websocket client connected to the MetaApi server`);
      instance.reconnectWaitTime = this._socketMinimumReconnectTimeout;
      instance.isReconnecting = false;
      if (!instance.resolved) {
        instance.resolved = true;
        resolve();
      } else {
        await this._fireReconnected(instanceNumber, instance.id, region);
      }
      if (!instance.connected) {
        instance.socket.close();
      }
    });
    socketInstance.on('reconnect', async () => {
      instance.isReconnecting = false;
      this._logger.info(`${region}:${instanceNumber}: MetaApi websocket client reconnected`);
      await this._fireReconnected(instanceNumber, instance.id, region);
    });
    socketInstance.on('connect_error', async err => {
      // eslint-disable-next-line no-console
      this._logger.error(`${region}:${instanceNumber}: MetaApi websocket client connection error`, err);
      instance.isReconnecting = false;
      if (!instance.resolved) {
        await this._reconnect(instanceNumber, instance.id, region);
      }
    });
    socketInstance.on('connect_timeout', async timeout => {
      // eslint-disable-next-line no-console
      this._logger.error(`${region}:${instanceNumber}: MetaApi websocket client connection timeout`);
      instance.isReconnecting = false;
      if (!instance.resolved) {
        await this._reconnect(instanceNumber, instance.id, region);
      }
    });
    socketInstance.on('disconnect', async reason => {
      instance.synchronizationThrottler.onDisconnect();
      // eslint-disable-next-line no-console
      this._logger.info(`${region}:${instanceNumber}: MetaApi websocket client disconnected from the ` + `MetaApi server because of ${reason}`);
      instance.isReconnecting = false;
      await this._reconnect(instanceNumber, instance.id, region);
    });
    socketInstance.on('error', async error => {
      // eslint-disable-next-line no-console
      this._logger.error(`${region}:${instanceNumber}: MetaApi websocket client error`, error);
      instance.isReconnecting = false;
      await this._reconnect(instanceNumber, instance.id, region);
    });
    socketInstance.on('response', data => {
      if (typeof data === 'string') {
        data = JSON.parse(data);
      }
      this._logger.debug(() => `${data.accountId}: Response received: ${(0, _stringify2.default)({
        requestId: data.requestId, timestamps: data.timestamps })}`);
      let requestResolve = instance.requestResolves[data.requestId] || { resolve: () => {}, reject: () => {} };
      delete instance.requestResolves[data.requestId];
      this._convertIsoTimeToDate(data);
      requestResolve.resolve(data);
      if (data.timestamps && requestResolve.type) {
        data.timestamps.clientProcessingFinished = new Date();
        for (let listener of this._latencyListeners) {
          _promise2.default.resolve().then(() => requestResolve.type === 'trade' ? listener.onTrade(data.accountId, data.timestamps) : listener.onResponse(data.accountId, requestResolve.type, data.timestamps)).catch(error => this._logger.error('Failed to process onResponse event for account ' + data.accountId + ', request type ' + requestResolve.type, error));
        }
      }
    });
    socketInstance.on('processingError', data => {
      let requestResolve = instance.requestResolves[data.requestId] || { resolve: () => {}, reject: () => {} };
      delete instance.requestResolves[data.requestId];
      requestResolve.reject(this._convertError(data));
    });
    // eslint-disable-next-line complexity
    socketInstance.on('synchronization', async data => {
      if (typeof data === 'string') {
        data = JSON.parse(data);
      }
      if (data.instanceIndex && data.instanceIndex !== instanceNumber) {
        this._logger.trace(() => `${data.accountId}:${data.instanceNumber}: received packet with wrong instance ` + `index via a socket with instance number of ${instanceNumber}, data=${(0, _stringify2.default)({
          type: data.type, sequenceNumber: data.sequenceNumber, sequenceTimestamp: data.sequenceTimestamp,
          synchronizationId: data.synchronizationId, application: data.application, host: data.host,
          specificationsUpdated: data.specificationsUpdated, positionsUpdated: data.positionsUpdated,
          ordersUpdated: data.ordersUpdated,
          specifications: data.specifications ? (data.specifications || []).length : undefined })}`);
        return;
      }
      if (!this._regionsByAccounts[data.accountId]) {
        this._regionsByAccounts[data.accountId] = { region, connections: 0, lastUsed: Date.now() };
      }
      this._logger.trace(() => `${data.accountId}:${data.instanceIndex}: Sync packet received: ${(0, _stringify2.default)({
        type: data.type, sequenceNumber: data.sequenceNumber, sequenceTimestamp: data.sequenceTimestamp,
        synchronizationId: data.synchronizationId, application: data.application, host: data.host,
        specificationsUpdated: data.specificationsUpdated, positionsUpdated: data.positionsUpdated,
        ordersUpdated: data.ordersUpdated,
        specifications: data.specifications ? (data.specifications || []).length : undefined })}, ` + `active listeners: ${(this._synchronizationListeners[data.accountId] || []).length}`);
      let activeSynchronizationIds = instance.synchronizationThrottler.activeSynchronizationIds;
      if (!data.synchronizationId || activeSynchronizationIds.includes(data.synchronizationId)) {
        if (this._packetLogger) {
          await this._packetLogger.logPacket(data);
        }
        const ignoredPacketTypes = ['disconnected', 'status', 'keepalive'];
        if (!this._subscriptionManager.isSubscriptionActive(data.accountId) && !ignoredPacketTypes.includes(data.type)) {
          this._logger.debug(`${data.accountId}: Packet arrived to inactive connection, attempting` + ` unsubscribe, packet: ${data.type}`);
          if (this._throttleRequest('unsubscribe', data.accountId, data.instanceIndex, this._unsubscribeThrottlingInterval)) {
            this.unsubscribe(data.accountId).catch(err => {
              this._logger.warn(`${data.accountId}:${data.instanceIndex || 0}: failed to unsubscribe`, err);
            });
          }
          return;
        }
        this._convertIsoTimeToDate(data);
      } else {
        data.type = 'noop';
      }
      this.queuePacket(data);
    });
    return result;
  }

  /**
   * Closes connection to MetaApi server
   */
  close() {
    (0, _keys2.default)(this._socketInstances).forEach(region => {
      (0, _keys2.default)(this._socketInstances[region]).forEach(instanceNumber => {
        this._socketInstances[region][instanceNumber].forEach(async instance => {
          if (instance.connected) {
            instance.connected = false;
            await instance.socket.close();
            for (let requestResolve of (0, _values2.default)(instance.requestResolves)) {
              requestResolve.reject(new Error('MetaApi connection closed'));
            }
            instance.requestResolves = {};
          }
        });
        this._socketInstancesByAccounts[instanceNumber] = {};
        this._socketInstances[region][instanceNumber] = [];
      });
    });
    this._synchronizationListeners = {};
    this._latencyListeners = [];
    this._packetOrderer.stop();
  }

  /**
   * MetaTrader account information (see https://metaapi.cloud/docs/client/models/metatraderAccountInformation/)
   * @typedef {Object} MetatraderAccountInformation
   * @property {String} platform platform id (mt4 or mt5)
   * @property {String} broker broker name
   * @property {String} currency account base currency ISO code
   * @property {String} server broker server name
   * @property {Number} balance account balance
   * @property {Number} equity account liquidation value
   * @property {Number} margin used margin
   * @property {Number} freeMargin free margin
   * @property {Number} leverage account leverage coefficient
   * @property {Number} marginLevel margin level calculated as % of equity/margin
   * @property {Boolean} tradeAllowed flag indicating that trading is allowed
   * @property {Boolean} [investorMode] flag indicating that investor password was used (supported for g2 only)
   * @property {String} marginMode margin calculation mode, one of ACCOUNT_MARGIN_MODE_EXCHANGE,
   * ACCOUNT_MARGIN_MODE_RETAIL_NETTING, ACCOUNT_MARGIN_MODE_RETAIL_HEDGING
   * @property {String} name Account owner name
   * @property {Number} login Account login
   * @property {Number} credit Account credit in the deposit currency
   * @property {number} accountCurrencyExchangeRate current exchange rate of account currency into account base currency
   * (USD if you did not override it)
   */

  /**
   * Returns account information for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readAccountInformation/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @returns {Promise<MetatraderAccountInformation>} promise resolving with account information
   */
  async getAccountInformation(accountId) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getAccountInformation' });
    return response.accountInformation;
  }

  /**
   * Stop loss threshold
   * @typedef {Object} StopLossThreshold
   * @property {Number} threshold price threshold relative to position open price, interpreted according to units
   * field value
   * @property {Number} stopLoss stop loss value, interpreted according to units and basePrice field values
   */

  /**
   * Threshold trailing stop loss configuration
   * @typedef {Object} ThresholdTrailingStopLoss
   * @property {StopLossThreshold[]} thresholds stop loss thresholds
   * @property {String} [units] threshold stop loss units. ABSOLUTE_PRICE means the that the value of stop loss
   * threshold fields contain a final threshold & stop loss value. RELATIVE* means that the threshold fields value
   * contains relative threshold & stop loss values, expressed either in price, points, pips, account currency or
   * balance percentage. Default is ABSOLUTE_PRICE. One of ABSOLUTE_PRICE, RELATIVE_PRICE, RELATIVE_POINTS,
   * RELATIVE_PIPS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   * @property {String} [stopPriceBase] defined the base price to calculate SL relative to for POSITION_MODIFY and
   * pending order requests. Default is OPEN_PRICE. One of CURRENT_PRICE, OPEN_PRICE
   */

  /**
   * Distance trailing stop loss configuration
   * @typedef {Object} DistanceTrailingStopLoss
   * @property {Number} [distance] SL distance relative to current price, interpreted according to units field value
   * @property {String} [units] distance trailing stop loss units. RELATIVE_* means that the distance field value 
   * contains relative stop loss expressed either in price, points, pips, account currency or balance percentage. 
   * Default is RELATIVE_PRICE. One of RELATIVE_PRICE, RELATIVE_POINTS, RELATIVE_PIPS, RELATIVE_CURRENCY,
   * RELATIVE_BALANCE_PERCENTAGE
   */

  /**
   * Distance trailing stop loss configuration
   * @typedef {Object} TrailingStopLoss
   * @property {DistanceTrailingStopLoss} [distance] distance trailing stop loss configuration. If both distance and
   * threshold TSL are set, then the resulting SL will be the one which is closest to the current price
   * @property {ThresholdTrailingStopLoss} [threshold] distance trailing stop loss configuration. If both distance and
   * threshold TSL are set, then the resulting SL will be the one which is closest to the current price
   */

  /**
   * MetaTrader position
   * @typedef {Object} MetatraderPosition
   * @property {Number} id position id (ticket number)
   * @property {String} type position type (one of POSITION_TYPE_BUY, POSITION_TYPE_SELL)
   * @property {String} symbol position symbol
   * @property {Number} magic position magic number, identifies the EA which opened the position
   * @property {Date} time time position was opened at
   * @property {String} brokerTime time position was opened at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Date} updateTime last position modification time
   * @property {Number} openPrice position open price
   * @property {Number} currentPrice current price
   * @property {Number} currentTickValue current tick value
   * @property {Number} [stopLoss] optional position stop loss price
   * @property {Number} [takeProfit] optional position take profit price
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {Number} volume position volume
   * @property {Number} profit position cumulative profit, including unrealized profit resulting from currently open
   * position part (except swap and commissions) and realized profit resulting from partially closed position part
   * and including swap and commissions
   * @property {Number} realizedProfit profit of the already closed part, including commissions and swap (realized and
   * unrealized)
   * @property {Number} unrealizedProfit profit of the part of the position which is not yet closed, excluding swap and
   * commissions
   * @property {Number} swap position cumulative swap, including both swap from currently open position part (unrealized
   * swap) and swap from partially closed position part (realized swap)
   * @property {Number} realizedSwap swap from partially closed position part
   * @property {Number} unrealizedSwap swap resulting from currently open position part
   * @property {Number} commission total position commissions, resulting both from currently open and closed position
   * parts
   * @property {Number} realizedCommission position realized commission, resulting from partially closed position part
   * @property {Number} unrealizedCommission position unrealized commission, resulting from currently open position part
   * @property {String} [comment] optional position comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [clientId] optional client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} reason position opening reason. One of POSITION_REASON_CLIENT, POSITION_REASON_EXPERT,
   * POSITION_REASON_MOBILE, POSITION_REASON_WEB, POSITION_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties#enum_position_reason',
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {String} [brokerComment] current comment value on broker side (possibly overriden by the broker)
   */

  /**
   * Returns positions for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPositions/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @returns {Promise<Array<MetatraderPosition>} promise resolving with array of open positions
   */
  async getPositions(accountId) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getPositions' });
    return response.positions;
  }

  /**
   * Returns specific position for a MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPosition/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @return {Promise<MetatraderPosition>} promise resolving with MetaTrader position found
   */
  async getPosition(accountId, positionId) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getPosition', positionId });
    return response.position;
  }

  /**
   * MetaTrader order
   * @typedef {Object} MetatraderOrder
   * @property {Number} id order id (ticket number)
   * @property {String} type order type (one of ORDER_TYPE_SELL, ORDER_TYPE_BUY, ORDER_TYPE_BUY_LIMIT,
   * ORDER_TYPE_SELL_LIMIT, ORDER_TYPE_BUY_STOP, ORDER_TYPE_SELL_STOP). See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type
   * @property {String} state order state one of (ORDER_STATE_STARTED, ORDER_STATE_PLACED, ORDER_STATE_CANCELED,
   * ORDER_STATE_PARTIAL, ORDER_STATE_FILLED, ORDER_STATE_REJECTED, ORDER_STATE_EXPIRED, ORDER_STATE_REQUEST_ADD,
   * ORDER_STATE_REQUEST_MODIFY, ORDER_STATE_REQUEST_CANCEL). See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_state
   * @property {Number} magic order magic number, identifies the EA which created the order
   * @property {Date} time time order was created at
   * @property {String} brokerTime time time order was created at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Date} [doneTime] time order was executed or canceled at. Will be specified for
   * completed orders only
   * @property {String} [doneBrokerTime] time order was executed or canceled at, in broker timezone,
   * YYYY-MM-DD HH:mm:ss.SSS format. Will be specified for completed orders only
   * @property {String} symbol order symbol
   * @property {Number} openPrice order open price (market price for market orders, limit price for limit orders or stop
   * price for stop orders)
   * @property {Number} [currentPrice] current price, filled for pending orders only. Not filled for history orders.
   * @property {Number} [stopLoss] order stop loss price
   * @property {Number} [takeProfit] order take profit price
   * @property {TrailingStopLoss} [trailingStopLoss] distance trailing stop loss configuration
   * @property {Number} volume order requested quantity
   * @property {Number} currentVolume order remaining quantity, i.e. requested quantity - filled quantity
   * @property {String} positionId order position id. Present only if the order has a position attached to it
   * @property {String} [comment] order comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [brokerComment] current comment value on broker side (possibly overriden by the broker)
   * @property {String} [clientId] client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} platform platform id (mt4 or mt5)
   * @property {String} reason order opening reason. One of ORDER_REASON_CLIENT, ORDER_REASON_MOBILE, ORDER_REASON_WEB,
   * ORDER_REASON_EXPERT, ORDER_REASON_SL, ORDER_REASON_TP, ORDER_REASON_SO, ORDER_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_reason.
   * @property {String} fillingMode order filling mode. One of ORDER_FILLING_FOK, ORDER_FILLING_IOC,
   * ORDER_FILLING_RETURN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_filling.
   * @property {String} expirationType order expiration type. One of ORDER_TIME_GTC, ORDER_TIME_DAY,
   * ORDER_TIME_SPECIFIED, ORDER_TIME_SPECIFIED_DAY. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_time
   * @property {Date} expirationTime optional order expiration time
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {String} [closeByPositionId] identifier of an opposite position used for closing by order
   * ORDER_TYPE_CLOSE_BY
   * @property {Number} [stopLimitPrice] the Limit order price for the StopLimit order
   */

  /**
   * Returns open orders for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrders/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @return {Promise<Array<MetatraderOrder>>} promise resolving with open MetaTrader orders
   */
  async getOrders(accountId) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getOrders' });
    return response.orders;
  }

  /**
   * Returns specific open order for a MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrder/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} orderId order id (ticket number)
   * @return {Promise<MetatraderOrder>} promise resolving with metatrader order found
   */
  async getOrder(accountId, orderId) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getOrder', orderId });
    return response.order;
  }

  /**
   * MetaTrader history orders search query response
   * @typedef {Object} MetatraderHistoryOrders
   * @property {Array<MetatraderOrder>} historyOrders array of history orders returned
   * @property {Boolean} synchronizing flag indicating that history order initial synchronization is still in progress
   * and thus search results may be incomplete
   */

  /**
   * Returns the history of completed orders for a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTicket/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} ticket ticket number (order id)
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  async getHistoryOrdersByTicket(accountId, ticket) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getHistoryOrdersByTicket', ticket });
    return {
      historyOrders: response.historyOrders,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns the history of completed orders for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByPosition/)
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  async getHistoryOrdersByPosition(accountId, positionId) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getHistoryOrdersByPosition',
      positionId });
    return {
      historyOrders: response.historyOrders,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns the history of completed orders for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTimeRange/)
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  async getHistoryOrdersByTimeRange(accountId, startTime, endTime, offset = 0, limit = 1000) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getHistoryOrdersByTimeRange',
      startTime, endTime, offset, limit });
    return {
      historyOrders: response.historyOrders,
      synchronizing: response.synchronizing
    };
  }

  /**
   * MetaTrader history deals search query response
   * @typedef {Object} MetatraderDeals
   * @property {Array<MetatraderDeal>} deals array of history deals returned
   * @property {Boolean} synchronizing flag indicating that deal initial synchronization is still in progress
   * and thus search results may be incomplete
   */

  /**
   * MetaTrader deal
   * @typedef {Object} MetatraderDeal
   * @property {String} id deal id (ticket number)
   * @property {String} type deal type (one of DEAL_TYPE_BUY, DEAL_TYPE_SELL, DEAL_TYPE_BALANCE, DEAL_TYPE_CREDIT,
   * DEAL_TYPE_CHARGE, DEAL_TYPE_CORRECTION, DEAL_TYPE_BONUS, DEAL_TYPE_COMMISSION, DEAL_TYPE_COMMISSION_DAILY,
   * DEAL_TYPE_COMMISSION_MONTHLY, DEAL_TYPE_COMMISSION_AGENT_DAILY, DEAL_TYPE_COMMISSION_AGENT_MONTHLY,
   * DEAL_TYPE_INTEREST, DEAL_TYPE_BUY_CANCELED, DEAL_TYPE_SELL_CANCELED, DEAL_DIVIDEND, DEAL_DIVIDEND_FRANKED,
   * DEAL_TAX). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_type
   * @property {String} entryType deal entry type (one of DEAL_ENTRY_IN, DEAL_ENTRY_OUT, DEAL_ENTRY_INOUT,
   * DEAL_ENTRY_OUT_BY). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_entry
   * @property {String} [symbol] symbol deal relates to
   * @property {Number} [magic] deal magic number, identifies the EA which initiated the deal
   * @property {Date} time time the deal was conducted at
   * @property {String} brokerTime time time the deal was conducted at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Number} [volume] deal volume
   * @property {Number} [price] the price the deal was conducted at
   * @property {Number} [commission] deal commission
   * @property {Number} [swap] deal swap
   * @property {Number} profit deal profit
   * @property {String} [positionId] id of position the deal relates to
   * @property {String} [orderId] id of order the deal relates to
   * @property {String} [comment] deal comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [brokerComment] current comment value on broker side (possibly overriden by the broker)
   * @property {String} [clientId] client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} platform platform id (mt4 or mt5)
   * @property {String} [reason] optional deal execution reason. One of DEAL_REASON_CLIENT, DEAL_REASON_MOBILE,
   * DEAL_REASON_WEB, DEAL_REASON_EXPERT, DEAL_REASON_SL, DEAL_REASON_TP, DEAL_REASON_SO, DEAL_REASON_ROLLOVER,
   * DEAL_REASON_VMARGIN, DEAL_REASON_SPLIT, DEAL_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_reason.
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {number} [stopLoss] deal stop loss. For MT5 opening deal this is the SL of the order opening the 
   * position. For MT4 deals or MT5 closing deal this is the last known position SL.
   * @property {number} [takeProfit] deal take profit. For MT5 opening deal this is the TP of the order opening the 
   * position. For MT4 deals or MT5 closing deal this is the last known position TP.
   */

  /**
   * Returns history deals with a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTicket/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} ticket ticket number (deal id for MT5 or order id for MT4)
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  async getDealsByTicket(accountId, ticket) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getDealsByTicket', ticket });
    return {
      deals: response.deals,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns history deals for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByPosition/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  async getDealsByPosition(accountId, positionId) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getDealsByPosition', positionId });
    return {
      deals: response.deals,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns history deals with for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTimeRange/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  async getDealsByTimeRange(accountId, startTime, endTime, offset = 0, limit = 1000) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getDealsByTimeRange', startTime,
      endTime, offset, limit });
    return {
      deals: response.deals,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Clears the order and transaction history of a specified application and removes the application (see
   * https://metaapi.cloud/docs/client/websocket/api/removeApplication/).
   * @param {String} accountId id of the MetaTrader account to remove history and application for
   * @return {Promise} promise resolving when the history is cleared
   */
  removeApplication(accountId) {
    return this.rpcRequest(accountId, { type: 'removeApplication' });
  }

  /**
   * MetaTrader trade response
   * @typedef {Object} MetatraderTradeResponse
   * @property {Number} numericCode numeric response code, see
   * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
   * https://book.mql4.com/appendix/errors. Response codes which indicate success are 0, 10008-10010, 10025. The rest
   * codes are errors
   * @property {String} stringCode string response code, see
   * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
   * https://book.mql4.com/appendix/errors. Response codes which indicate success are ERR_NO_ERROR,
   * TRADE_RETCODE_PLACED, TRADE_RETCODE_DONE, TRADE_RETCODE_DONE_PARTIAL, TRADE_RETCODE_NO_CHANGES. The rest codes are
   * errors.
   * @property {String} message human-readable response message
   * @property {String} orderId order id which was created/modified during the trade
   * @property {String} positionId position id which was modified during the trade
   */

  /**
   * Execute a trade on a connected MetaTrader account (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {String} accountId id of the MetaTrader account to execute trade for
   * @param {MetatraderTrade} trade trade to execute (see docs for possible trade types)
   * @param {String} [application] application to use
   * @param {String} [reliability] account reliability
   * @returns {Promise<MetatraderTradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  // eslint-disable-next-line complexity
  async trade(accountId, trade, application, reliability) {
    let response;
    if (application === 'RPC') {
      response = await this.rpcRequest(accountId, { type: 'trade', trade, application });
    } else {
      response = await this.rpcRequestAllInstances(accountId, { type: 'trade', trade,
        application: application || this._application, requestId: _randomstring2.default.generate(32) }, reliability);
    }
    response.response = response.response || {};
    response.response.stringCode = response.response.stringCode || response.response.description;
    response.response.numericCode = response.response.numericCode !== undefined ? response.response.numericCode : response.response.error;
    if (['ERR_NO_ERROR', 'TRADE_RETCODE_PLACED', 'TRADE_RETCODE_DONE', 'TRADE_RETCODE_DONE_PARTIAL', 'TRADE_RETCODE_NO_CHANGES'].includes(response.response.stringCode || response.response.description)) {
      return response.response;
    } else {
      throw new _tradeError2.default(response.response.message, response.response.numericCode, response.response.stringCode);
    }
  }

  /**
   * Creates a task that ensures the account gets subscribed to the server
   * @param {String} accountId account id to subscribe
   * @param {Number} instanceNumber instance index number
   */
  ensureSubscribe(accountId, instanceNumber) {
    this._subscriptionManager.scheduleSubscribe(accountId, instanceNumber);
  }

  /**
   * Subscribes to the Metatrader terminal events (see https://metaapi.cloud/docs/client/websocket/api/subscribe/).
   * @param {String} accountId id of the MetaTrader account to subscribe to
   * @param {Number} instanceNumber instance index number
   * @returns {Promise} promise which resolves when subscription started
   */
  subscribe(accountId, instanceNumber) {
    return this._subscriptionManager.subscribe(accountId, instanceNumber);
  }

  /**
   * Requests the terminal to start synchronization process
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/).
   * @param {String} accountId id of the MetaTrader account to synchronize
   * @param {Number} instanceIndex instance index
   * @param {String} host name of host to synchronize with
   * @param {String} synchronizationId synchronization request id
   * @param {Date} startingHistoryOrderTime from what date to start synchronizing history orders from. If not specified,
   * the entire order history will be downloaded.
   * @param {Date} startingDealTime from what date to start deal synchronization from. If not specified, then all
   * history deals will be downloaded.
   * @param {Function} getHashes function to get terminal state hashes
   * @returns {Promise} promise which resolves when synchronization started
   */
  async synchronize(accountId, instanceIndex, host, synchronizationId, startingHistoryOrderTime, startingDealTime, getHashes) {
    if (this._getSocketInstanceByAccount(accountId, instanceIndex) === undefined) {
      this._logger.debug(`${accountId}:${instanceIndex}: creating socket instance on synchronize`);
      await this._createSocketInstanceByAccount(accountId, instanceIndex);
    }
    const syncThrottler = this._getSocketInstanceByAccount(accountId, instanceIndex).synchronizationThrottler;
    return syncThrottler.scheduleSynchronize(accountId, { requestId: synchronizationId,
      type: 'synchronize', startingHistoryOrderTime, startingDealTime, instanceIndex, host }, getHashes);
  }

  /**
   * Waits for server-side terminal state synchronization to complete.
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/waitSynchronized/).
   * @param {String} accountId id of the MetaTrader account to synchronize
   * @param {Number} [instanceNumber] instance index number
   * @param {String} applicationPattern MetaApi application regular expression pattern, default is .*
   * @param {Number} timeoutInSeconds timeout in seconds, default is 300 seconds
   * @param {String} [application] application to synchronize with
   * @returns {Promise} promise which resolves when synchronization started
   */
  waitSynchronized(accountId, instanceNumber, applicationPattern, timeoutInSeconds, application) {
    return this.rpcRequest(accountId, { type: 'waitSynchronized', applicationPattern, timeoutInSeconds,
      instanceIndex: instanceNumber, application: application || this._application }, timeoutInSeconds + 1);
  }

  /**
   * Market data subscription
   * @typedef {Object} MarketDataSubscription
   * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
   * @property {string} [timeframe] when subscription type is candles, defines the timeframe according to which the
   * candles must be generated. Allowed values for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h,
   * 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @property {number} [intervalInMilliseconds] defines how frequently the terminal will stream data to client. If not
   * set, then the value configured in account will be used
   */

  /**
   * Subscribes on market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
   * @param {String} accountId id of the MetaTrader account
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update
   * @param {String} [reliability] account reliability
   * @returns {Promise} promise which resolves when subscription request was processed
   */
  subscribeToMarketData(accountId, symbol, subscriptions, reliability) {
    return this.rpcRequestAllInstances(accountId, { type: 'subscribeToMarketData', symbol, subscriptions }, reliability);
  }

  /**
   * Refreshes market data subscriptions on the server to prevent them from expiring
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   * @param {Array} subscriptions array of subscriptions to refresh
   */
  refreshMarketDataSubscriptions(accountId, instanceNumber, subscriptions) {
    return this.rpcRequest(accountId, { type: 'refreshMarketDataSubscriptions', subscriptions,
      instanceIndex: instanceNumber });
  }

  /**
   * Market data unsubscription
   * @typedef {Object} MarketDataUnsubscription
   * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
   */

  /**
   * Unsubscribes from market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
   * @param {String} accountId id of the MetaTrader account
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
   * @param {String} [reliability] account reliability
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */
  unsubscribeFromMarketData(accountId, symbol, subscriptions, reliability) {
    return this.rpcRequestAllInstances(accountId, { type: 'unsubscribeFromMarketData', symbol, subscriptions }, reliability);
  }

  /**
   * Retrieves symbols available on an account (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbols/).
   * @param {String} accountId id of the MetaTrader account to retrieve symbols for
   * @returns {Promise<Array<string>>} promise which resolves when symbols are retrieved
   */
  async getSymbols(accountId) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getSymbols' });
    return response.symbols;
  }

  /**
   * Retrieves specification for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolSpecification/).
   * @param {String} accountId id of the MetaTrader account to retrieve symbol specification for
   * @param {String} symbol symbol to retrieve specification for
   * @returns {Promise<MetatraderSymbolSpecification>} promise which resolves when specification is retrieved
   */
  async getSymbolSpecification(accountId, symbol) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getSymbolSpecification', symbol });
    return response.specification;
  }

  /**
   * Retrieves price for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolPrice/).
   * @param {String} accountId id of the MetaTrader account to retrieve symbol price for
   * @param {String} symbol symbol to retrieve price for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderSymbolPrice>} promise which resolves when price is retrieved
   */
  async getSymbolPrice(accountId, symbol, keepSubscription = false) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getSymbolPrice', symbol,
      keepSubscription });
    return response.price;
  }

  /**
   * Retrieves price for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readCandle/).
   * @param {string} accountId id of the MetaTrader account to retrieve candle for
   * @param {string} symbol symbol to retrieve candle for
   * @param {string} timeframe defines the timeframe according to which the candle must be generated. Allowed values for
   * MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values
   * for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderCandle>} promise which resolves when candle is retrieved
   */
  async getCandle(accountId, symbol, timeframe, keepSubscription = false) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getCandle', symbol, timeframe,
      keepSubscription });
    return response.candle;
  }

  /**
   * Retrieves latest tick for a symbol. MT4 G1 accounts do not support this API (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readTick/).
   * @param {string} accountId id of the MetaTrader account to retrieve symbol tick for
   * @param {string} symbol symbol to retrieve tick for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderTick>} promise which resolves when tick is retrieved
   */
  async getTick(accountId, symbol, keepSubscription = false) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getTick', symbol, keepSubscription });
    return response.tick;
  }

  /**
   * Retrieves latest order book for a symbol. MT4 accounts do not support this API (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readBook/).
   * @param {string} accountId id of the MetaTrader account to retrieve symbol order book for
   * @param {string} symbol symbol to retrieve order book for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderBook>} promise which resolves when order book is retrieved
   */
  async getBook(accountId, symbol, keepSubscription = false) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getBook', symbol, keepSubscription });
    return response.book;
  }

  /**
   * Sends client uptime stats to the server.
   * @param {String} accountId id of the MetaTrader account to save uptime
   * @param {Object} uptime uptime statistics to send to the server
   * @returns {Promise} promise which resolves when uptime statistics is submitted
   */
  saveUptime(accountId, uptime) {
    return this.rpcRequest(accountId, { type: 'saveUptime', uptime });
  }

  /**
   * Unsubscribe from account (see
   * https://metaapi.cloud/docs/client/websocket/api/synchronizing/unsubscribe).
   * @param {String} accountId id of the MetaTrader account to unsubscribe
   * @returns {Promise} promise which resolves when socket unsubscribed
   */
  async unsubscribe(accountId) {
    try {
      const region = this.getAccountRegion(accountId);
      this._latencyService.onUnsubscribe(accountId);
      await _promise2.default.all((0, _keys2.default)(this._socketInstances[region]).map(async instanceNumber => {
        await this._subscriptionManager.unsubscribe(accountId, Number(instanceNumber));
        delete this._socketInstancesByAccounts[instanceNumber][accountId];
      }));
    } catch (err) {
      if (!['TimeoutError', 'NotFoundError'].includes(err.name)) {
        throw err;
      }
    }
  }

  /**
   * Current server time (see https://metaapi.cloud/docs/client/models/serverTime/)
   * @typedef {Object} ServerTime
   * @property {Date} time current server time
   * @property {String} brokerTime current broker time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Date} [lastQuoteTime] last quote time
   * @property {String} [lastQuoteBrokerTime] last quote time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */

  /**
   * Returns server time for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readServerTime/).
   * @param {string} accountId id of the MetaTrader account to return server time for
   * @returns {Promise<ServerTime>} promise resolving with server time
   */
  async getServerTime(accountId) {
    let response = await this.rpcRequest(accountId, { application: 'RPC', type: 'getServerTime' });
    return response.serverTime;
  }

  /**
   * Margin required to open a trade (see https://metaapi.cloud/docs/client/models/margin/)
   * @typedef {Object} Margin
   * @property {number} [margin] margin required to open a trade. If margin can not be calculated, then this field is
   * not defined
   */

  /**
   * Contains order to calculate margin for (see https://metaapi.cloud/docs/client/models/marginOrder/)
   * @typedef {Object} MarginOrder
   * @property {string} symbol order symbol
   * @property {string} type order type, one of ORDER_TYPE_BUY or ORDER_TYPE_SELL
   * @property {number} volume order volume, must be greater than 0
   * @property {number} openPrice order open price, must be greater than 0
   */

  /**
   * Calculates margin required to open a trade on the specified trading account (see
   * https://metaapi.cloud/docs/client/websocket/api/calculateMargin/).
   * @param {string} accountId id of the trading account to calculate margin for
   * @param {string} application application to send the request to
   * @param {string} reliability account reliability
   * @param {MarginOrder} order order to calculate margin for
   * @returns {Promise<Margin>} promise resolving with margin calculation result
   */
  async calculateMargin(accountId, application, reliability, order) {
    let response;
    if (application === 'RPC') {
      response = await this.rpcRequest(accountId, { application, type: 'calculateMargin', order });
    } else {
      response = await this.rpcRequestAllInstances(accountId, { application, type: 'calculateMargin', order }, reliability);
    }
    return response.margin;
  }

  /**
   * Calls onUnsubscribeRegion listener event 
   * @param {String} accountId account id
   * @param {String} region account region to unsubscribe
   */
  async unsubscribeAccountRegion(accountId, region) {
    const unsubscribePromises = [];
    for (let listener of this._synchronizationListeners[accountId] || []) {
      unsubscribePromises.push(_promise2.default.resolve((async () => {
        await this._processEvent(() => listener.onUnsubscribeRegion(region), `${accountId}:${region}:onUnsubscribeRegion`, true);
      })()).catch(err => this._logger.error(`${accountId}:${region}: Failed to notify listener ` + 'about onUnsubscribeRegion event', err)));
    }
    await _promise2.default.all(unsubscribePromises);
  }

  /**
   * Adds synchronization listener for specific account
   * @param {String} accountId account id
   * @param {SynchronizationListener} listener synchronization listener to add
   */
  addSynchronizationListener(accountId, listener) {
    this._logger.trace(`${accountId}: Added synchronization listener`);
    let listeners = this._synchronizationListeners[accountId];
    if (!listeners) {
      listeners = [];
      this._synchronizationListeners[accountId] = listeners;
    }
    listeners.push(listener);
  }

  /**
   * Removes synchronization listener for specific account
   * @param {String} accountId account id
   * @param {SynchronizationListener} listener synchronization listener to remove
   */
  removeSynchronizationListener(accountId, listener) {
    this._logger.trace(`${accountId}: Removed synchronization listener`);
    let listeners = this._synchronizationListeners[accountId];
    if (!listeners) {
      listeners = [];
    }
    listeners = listeners.filter(l => l !== listener);
    this._synchronizationListeners[accountId] = listeners;
  }

  /**
   * Adds latency listener
   * @param {LatencyListener} listener latency listener to add
   */
  addLatencyListener(listener) {
    this._latencyListeners.push(listener);
  }

  /**
   * Removes latency listener
   * @param {LatencyListener} listener latency listener to remove
   */
  removeLatencyListener(listener) {
    this._latencyListeners = this._latencyListeners.filter(l => l !== listener);
  }

  /**
   * Adds reconnect listener
   * @param {ReconnectListener} listener reconnect listener to add
   * @param {String} accountId account id of listener
   */
  addReconnectListener(listener, accountId) {
    this._reconnectListeners.push({ accountId, listener });
  }

  /**
   * Removes reconnect listener
   * @param {ReconnectListener} listener listener to remove
   */
  removeReconnectListener(listener) {
    this._reconnectListeners = this._reconnectListeners.filter(l => l.listener !== listener);
  }

  /**
   * Removes all listeners. Intended for use in unit tests.
   */
  removeAllListeners() {
    this._synchronizationListeners = {};
    this._reconnectListeners = [];
  }

  /**
   * Queues an account packet for processing
   * @param {Object} packet packet to process
   */
  queuePacket(packet) {
    const accountId = packet.accountId;
    const packets = this._packetOrderer.restoreOrder(packet).filter(p => p.type !== 'noop');
    if (this._sequentialEventProcessing && packet.sequenceNumber !== undefined) {
      const events = packets.map(packetItem => () => _promise2.default.resolve(this._processSynchronizationPacket(packetItem)));
      if (!this._eventQueues[accountId]) {
        this._eventQueues[accountId] = events;
        this._callAccountEvents(accountId);
      } else {
        this._eventQueues[accountId] = this._eventQueues[accountId].concat(events);
      }
    } else {
      packets.forEach(packetItem => this._processSynchronizationPacket(packetItem));
    }
  }

  /**
   * Queues account event for processing
   * @param {String} accountId account id
   * @param {String} name event label name
   * @param {Function} callable async or regular function to execute
   */
  queueEvent(accountId, name, callable) {
    let event = () => this._processEvent(callable, `${accountId}:${name}`);
    if (this._sequentialEventProcessing) {
      if (!this._eventQueues[accountId]) {
        this._eventQueues[accountId] = [event];
        this._callAccountEvents(accountId);
      } else {
        this._eventQueues[accountId].push(event);
      }
    } else {
      event();
    }
  }

  async _callAccountEvents(accountId) {
    if (this._eventQueues[accountId]) {
      while (this._eventQueues[accountId].length) {
        await this._eventQueues[accountId][0]();
        this._eventQueues[accountId].shift();
      }
      delete this._eventQueues[accountId];
    }
  }

  async _reconnect(instanceNumber, socketInstanceIndex, region) {
    const instance = this.socketInstances[region][instanceNumber][socketInstanceIndex];
    if (instance) {
      while (!instance.socket.connected && !instance.isReconnecting && instance.connected) {
        await this._tryReconnect(instanceNumber, socketInstanceIndex, region);
      }
    }
  }

  _tryReconnect(instanceNumber, socketInstanceIndex, region) {
    const instance = this.socketInstances[region][instanceNumber][socketInstanceIndex];
    instance.reconnectWaitTime = Math.min(instance.reconnectWaitTime * 2, 30000);
    return new _promise2.default(resolve => setTimeout(async () => {
      if (!instance.socket.connected && !instance.isReconnecting && instance.connected) {
        try {
          instance.sessionId = _randomstring2.default.generate(32);
          const clientId = Math.random();
          instance.socket.close();
          instance.socket.io.opts.extraHeaders['Client-Id'] = clientId;
          instance.socket.io.opts.query.clientId = clientId;
          instance.isReconnecting = true;
          instance.socket.io.uri = await this._getServerUrl(instanceNumber, socketInstanceIndex, region);
          instance.socket.connect();
        } catch (error) {
          instance.isReconnecting = false;
        }
      }
      resolve();
    }, instance.reconnectWaitTime));
  }

  /**
   * Simulataneously sends RPC requests to all synchronized instances
   * @param {String} accountId metatrader account id
   * @param {Object} request base request data
   * @param {String} [reliability] account reliability
   * @param {Number} [timeoutInSeconds] request timeout in seconds
   */
  async rpcRequestAllInstances(accountId, request, reliability, timeoutInSeconds) {
    if (reliability === 'high') {
      try {
        return await (0, _promise4.default)([0, 1].map(instanceNumber => {
          return this.rpcRequest(accountId, (0, _assign2.default)({}, request, { instanceIndex: instanceNumber }), timeoutInSeconds);
        }));
      } catch (error) {
        throw error.errors[0];
      }
    } else {
      return await this.rpcRequest(accountId, request, timeoutInSeconds);
    }
  }

  /**
   * Makes a RPC request
   * @param {String} accountId metatrader account id
   * @param {Object} request base request data
   * @param {Number} [timeoutInSeconds] request timeout in seconds
   */
  //eslint-disable-next-line complexity, max-statements
  async rpcRequest(accountId, request, timeoutInSeconds) {
    const ignoredRequestTypes = ['subscribe', 'synchronize', 'refreshMarketDataSubscriptions', 'unsubscribe'];
    const primaryAccountId = this._accountsByReplicaId[accountId];
    const connectedInstance = this._latencyService.getActiveAccountInstances(primaryAccountId)[0];
    if (!ignoredRequestTypes.includes(request.type) && connectedInstance) {
      const activeRegion = connectedInstance.split(':')[1];
      accountId = this._accountReplicas[primaryAccountId][activeRegion];
    }
    let socketInstanceIndex = null;
    let instanceNumber = 0;
    const region = this.getAccountRegion(accountId);
    this._refreshAccountRegion(accountId);
    if (request.instanceIndex !== undefined) {
      instanceNumber = request.instanceIndex;
    } else {
      if (connectedInstance) {
        instanceNumber = Number(connectedInstance.split(':')[2]);
      }
      if (request.application !== 'RPC') {
        request = (0, _assign2.default)({}, request, { instanceIndex: instanceNumber });
      }
    }
    if (!this._socketInstancesByAccounts[instanceNumber]) {
      this._socketInstancesByAccounts[instanceNumber] = {};
    }
    if (!this._socketInstances[region]) {
      this._socketInstances[region] = {};
    }
    if (!this._socketInstances[region][instanceNumber]) {
      this._socketInstances[region][instanceNumber] = [];
    }
    if (this._socketInstancesByAccounts[instanceNumber][accountId] !== undefined) {
      socketInstanceIndex = this._socketInstancesByAccounts[instanceNumber][accountId];
    } else {
      this._logger.debug(`${accountId}:${instanceNumber}: creating socket instance on RPC request`);
      await this._createSocketInstanceByAccount(accountId, instanceNumber);
      socketInstanceIndex = this._socketInstancesByAccounts[instanceNumber][accountId];
    }
    const instance = this._socketInstances[region][instanceNumber][socketInstanceIndex];
    if (!instance.connected) {
      this._logger.debug(`${accountId}:${instanceNumber}: connecting socket instance on RPC request`);
      await this.connect(instanceNumber, region);
    } else if (!this.connected(instanceNumber, socketInstanceIndex, region)) {
      await instance.connectResult;
    }
    if (request.type === 'subscribe') {
      request.sessionId = instance.sessionId;
    }
    if (['trade', 'subscribe'].includes(request.type)) {
      return this._makeRequest(accountId, instanceNumber, request, timeoutInSeconds);
    }
    let retryCounter = 0;
    while (true) {
      //eslint-disable-line no-constant-condition
      try {
        return await this._makeRequest(accountId, instanceNumber, request, timeoutInSeconds);
      } catch (err) {
        if (err.name === 'TooManyRequestsError') {
          let calcRetryCounter = retryCounter;
          let calcRequestTime = 0;
          while (calcRetryCounter < this._retries) {
            calcRetryCounter++;
            calcRequestTime += Math.min(Math.pow(2, calcRetryCounter) * this._minRetryDelayInSeconds, this._maxRetryDelayInSeconds) * 1000;
          }
          const retryTime = new Date(err.metadata.recommendedRetryTime).getTime();
          if (Date.now() + calcRequestTime > retryTime && retryCounter < this._retries) {
            if (Date.now() < retryTime) {
              await new _promise2.default(res => setTimeout(res, retryTime - Date.now()));
            }
            retryCounter++;
          } else {
            throw err;
          }
        } else if (['NotSynchronizedError', 'TimeoutError', 'NotAuthenticatedError', 'InternalError'].includes(err.name) && retryCounter < this._retries) {
          await new _promise2.default(res => setTimeout(res, Math.min(Math.pow(2, retryCounter) * this._minRetryDelayInSeconds, this._maxRetryDelayInSeconds) * 1000));
          retryCounter++;
        } else {
          throw err;
        }
        if (this._socketInstancesByAccounts[instanceNumber][accountId] === undefined) {
          throw err;
        }
      }
    }
  }

  _makeRequest(accountId, instanceNumber, request, timeoutInSeconds) {
    const socketInstance = this._getSocketInstanceByAccount(accountId, instanceNumber);
    let requestId = request.requestId || _randomstring2.default.generate(32);
    request.timestamps = { clientProcessingStarted: new Date() };
    let result = _promise2.default.race([new _promise2.default((resolve, reject) => socketInstance.requestResolves[requestId] = { resolve, reject, type: request.type }), new _promise2.default((resolve, reject) => setTimeout(() => {
      reject(new _timeoutError2.default(`MetaApi websocket client request ${request.requestId} of type ${request.type} ` + 'timed out. Please make sure your account is connected to broker before retrying your request.'));
      delete socketInstance.requestResolves[requestId];
    }, timeoutInSeconds * 1000 || this._requestTimeout))]);
    request.accountId = accountId;
    request.application = request.application || this._application;
    if (!request.requestId) {
      request.requestId = requestId;
    }
    if (request.type === 'unsubscribe' || request.application === 'RPC' || request.instanceIndex === socketInstance.instanceNumber) {
      this._logger.debug(() => `${accountId}: Sending request: ${(0, _stringify2.default)(request)}`);
      socketInstance.socket.emit('request', request);
      return result;
    } else {
      this._logger.trace(() => `${accountId}:${request.instanceIndex}: skipping request because it is being sent to ` + `the socket of the wrong instance index, request=${(0, _stringify2.default)(request)}`);
      return result;
    }
  }

  // eslint-disable-next-line complexity
  _convertError(data) {
    if (data.error === 'ValidationError') {
      return new _errorHandler.ValidationError(data.message, data.details);
    } else if (data.error === 'NotFoundError') {
      return new _errorHandler.NotFoundError(data.message);
    } else if (data.error === 'NotSynchronizedError') {
      return new _notSynchronizedError2.default(data.message);
    } else if (data.error === 'TimeoutError') {
      return new _timeoutError2.default(data.message);
    } else if (data.error === 'NotAuthenticatedError') {
      return new _notConnectedError2.default(data.message);
    } else if (data.error === 'TradeError') {
      return new _tradeError2.default(data.message, data.numericCode, data.stringCode);
    } else if (data.error === 'UnauthorizedError') {
      this.close();
      return new _errorHandler.UnauthorizedError(data.message);
    } else if (data.error === 'TooManyRequestsError') {
      return new _errorHandler.TooManyRequestsError(data.message, data.metadata);
    } else {
      return new _errorHandler.InternalError(data.message);
    }
  }

  // eslint-disable-next-line complexity
  _convertIsoTimeToDate(packet) {
    // eslint-disable-next-line guard-for-in
    for (let field in packet) {
      let value = packet[field];
      if (typeof value === 'string' && field.match(/time$|Time$/) && !field.match(/brokerTime$|BrokerTime$|timeframe$/)) {
        packet[field] = new Date(value);
      }
      if (Array.isArray(value)) {
        for (let item of value) {
          this._convertIsoTimeToDate(item);
        }
      }
      if (typeof value === 'object') {
        this._convertIsoTimeToDate(value);
      }
    }
    if (packet && packet.timestamps) {
      // eslint-disable-next-line guard-for-in
      for (let field in packet.timestamps) {
        packet.timestamps[field] = new Date(packet.timestamps[field]);
      }
    }
    if (packet && packet.type === 'prices') {
      for (let price of packet.prices || []) {
        if (price.timestamps) {
          // eslint-disable-next-line guard-for-in
          for (let field in price.timestamps) {
            price.timestamps[field] = new Date(price.timestamps[field]);
          }
        }
      }
    }
  }

  /**
   * MetaTrader symbol specification. Contains symbol specification (see
   * https://metaapi.cloud/docs/client/models/metatraderSymbolSpecification/)
   * @typedef {Object} MetatraderSymbolSpecification
   * @property {String} symbol symbol (e.g. a currency pair or an index)
   * @property {Number} tickSize tick size
   * @property {Number} minVolume minimum order volume for the symbol
   * @property {Number} maxVolume maximum order volume for the symbol
   * @property {Number} volumeStep order volume step for the symbol
   * @property {Array<String>} list of allowed order filling modes. Can contain ORDER_FILLING_FOK, ORDER_FILLING_IOC or
   * both. See https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_filling_mode for more
   * details.
   * @property {String} deal execution mode. Possible values are SYMBOL_TRADE_EXECUTION_REQUEST,
   * SYMBOL_TRADE_EXECUTION_INSTANT, SYMBOL_TRADE_EXECUTION_MARKET, SYMBOL_TRADE_EXECUTION_EXCHANGE. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_trade_execution for more
   * details.
   * @property {Number} contractSize trade contract size
   * @property {MetatraderSessions} quoteSessions quote sessions, indexed by day of week
   * @property {MetatraderSessions} tradeSessions trade sessions, indexed by day of week
   * @property {String} [tradeMode] order execution type. Possible values are SYMBOL_TRADE_MODE_DISABLED,
   * SYMBOL_TRADE_MODE_LONGONLY, SYMBOL_TRADE_MODE_SHORTONLY, SYMBOL_TRADE_MODE_CLOSEONLY, SYMBOL_TRADE_MODE_FULL. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_trade_mode for more
   * details
   * @property {Number} [bondAccruedInterest] accrued interest – accumulated coupon interest, i.e. part of the coupon
   * interest calculated in proportion to the number of days since the coupon bond issuance or the last coupon interest
   * payment
   * @property {Number} [bondFaceValue] face value – initial bond value set by the issuer
   * @property {Number} [optionStrike] the strike price of an option. The price at which an option buyer can buy (in a
   * Call option) or sell (in a Put option) the underlying asset, and the option seller is obliged to sell or buy the
   * appropriate amount of the underlying asset.
   * @property {Number} [optionPriceSensivity] option/warrant sensitivity shows by how many points the price of the
   * option's underlying asset should change so that the price of the option changes by one point
   * @property {Number} [liquidityRate] liquidity Rate is the share of the asset that can be used for the margin
   * @property {Number} initialMargin initial margin means the amount in the margin currency required for opening a
   * position with the volume of one lot. It is used for checking a client's assets when he or she enters the market
   * @property {Number} maintenanceMargin the maintenance margin. If it is set, it sets the margin amount in the margin
   * currency of the symbol, charged from one lot. It is used for checking a client's assets when his/her account state
   * changes. If the maintenance margin is equal to 0, the initial margin is used
   * @property {Number} hedgedMargin contract size or margin value per one lot of hedged positions (oppositely directed
   * positions of one symbol). Two margin calculation methods are possible for hedged positions. The calculation method
   * is defined by the broker
   * @property {Boolean} [hedgedMarginUsesLargerLeg] calculating hedging margin using the larger leg (Buy or Sell)
   * @property {String} marginCurrency margin currency
   * @property {String} priceCalculationMode contract price calculation mode. One of SYMBOL_CALC_MODE_UNKNOWN,
   * SYMBOL_CALC_MODE_FOREX, SYMBOL_CALC_MODE_FOREX_NO_LEVERAGE, SYMBOL_CALC_MODE_FUTURES, SYMBOL_CALC_MODE_CFD,
   * SYMBOL_CALC_MODE_CFDINDEX, SYMBOL_CALC_MODE_CFDLEVERAGE, SYMBOL_CALC_MODE_EXCH_STOCKS,
   * SYMBOL_CALC_MODE_EXCH_FUTURES, SYMBOL_CALC_MODE_EXCH_FUTURES_FORTS, SYMBOL_CALC_MODE_EXCH_BONDS,
   * SYMBOL_CALC_MODE_EXCH_STOCKS_MOEX, SYMBOL_CALC_MODE_EXCH_BONDS_MOEX, SYMBOL_CALC_MODE_SERV_COLLATERAL. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_calc_mode for more details
   * @property {String} baseCurrency base currency
   * @property {String} [profitCurrency] profit currency
   * @property {String} swapMode swap calculation model. Allowed values are SYMBOL_SWAP_MODE_DISABLED,
   * SYMBOL_SWAP_MODE_POINTS, SYMBOL_SWAP_MODE_CURRENCY_SYMBOL, SYMBOL_SWAP_MODE_CURRENCY_MARGIN,
   * SYMBOL_SWAP_MODE_CURRENCY_DEPOSIT, SYMBOL_SWAP_MODE_INTEREST_CURRENT, SYMBOL_SWAP_MODE_INTEREST_OPEN,
   * SYMBOL_SWAP_MODE_REOPEN_CURRENT, SYMBOL_SWAP_MODE_REOPEN_BID. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_swap_mode for more details
   * @property {Number} [swapLong] long swap value
   * @property {Number} [swapShort] short swap value
   * @property {String} [swapRollover3Days] day of week to charge 3 days swap rollover. Allowed values are SUNDAY,
   * MONDAY, TUESDAY, WEDNESDAY, THURDAY, FRIDAY, SATURDAY, NONE
   * @property {Array<String>} allowedExpirationModes allowed order expiration modes. Allowed values are
   * SYMBOL_EXPIRATION_GTC, SYMBOL_EXPIRATION_DAY, SYMBOL_EXPIRATION_SPECIFIED, SYMBOL_EXPIRATION_SPECIFIED_DAY.
   * See https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_expiration_mode for more
   * details
   * @property {Array<String>} allowedOrderTypes allowed order types. Allowed values are SYMBOL_ORDER_MARKET,
   * SYMBOL_ORDER_LIMIT, SYMBOL_ORDER_STOP, SYMBOL_ORDER_STOP_LIMIT, SYMBOL_ORDER_SL, SYMBOL_ORDER_TP,
   * SYMBOL_ORDER_CLOSEBY. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_order_mode for more details
   * @property {String} orderGTCMode if the expirationMode property is set to SYMBOL_EXPIRATION_GTC (good till
   * canceled), the expiration of pending orders, as well as of Stop Loss/Take Profit orders should be additionally set
   * using this enumeration. Allowed values are SYMBOL_ORDERS_GTC, SYMBOL_ORDERS_DAILY,
   * SYMBOL_ORDERS_DAILY_EXCLUDING_STOPS. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_order_gtc_mode for more
   * details
   * @property {Number} digits digits after a decimal point
   * @property {Number} point point size
   * @property {String} [path] path in the symbol tree
   * @property {String} description symbol description
   * @property {Date} [startTime] date of the symbol trade beginning (usually used for futures)
   * @property {Date} [expirationTime] date of the symbol trade end (usually used for futures)
   * @property {number} [pipSize] size of a pip. Pip size is defined for spot and CFD symbols only
   * @property {number} stopsLevel minimal indention in points from the current close price to place Stop orders
   * @property {number} freezeLevel distance to freeze trade operations in points
   */

  /**
   * Metatrader trade or quote session container, indexed by weekday
   * @typedef {Object} MetatraderSessions
   * @property {Array<MetatraderSession>} [SUNDAY] array of sessions for SUNDAY
   * @property {Array<MetatraderSession>} [MONDAY] array of sessions for MONDAY
   * @property {Array<MetatraderSession>} [TUESDAY] array of sessions for TUESDAY
   * @property {Array<MetatraderSession>} [WEDNESDAY] array of sessions for WEDNESDAY
   * @property {Array<MetatraderSession>} [THURSDAY] array of sessions for THURSDAY
   * @property {Array<MetatraderSession>} [FRIDAY] array of sessions for FRIDAY
   * @property {Array<MetatraderSession>} [SATURDAY] array of sessions for SATURDAY
   */

  /**
   * Metatrader trade or quote session
   * @typedef {Object} MetatraderSession
   * @property {String} from session start time, in hh.mm.ss.SSS format
   * @property {String} to session end time, in hh.mm.ss.SSS format
   */

  /**
   * MetaTrader symbol price. Contains current price for a symbol (see
   * https://metaapi.cloud/docs/client/models/metatraderSymbolPrice/)
   * @typedef {Object} MetatraderSymbolPrice
   * @property {String} symbol symbol (e.g. a currency pair or an index)
   * @property {Number} bid bid price
   * @property {Number} ask ask price
   * @property {Number} profitTickValue tick value for a profitable position
   * @property {Number} lossTickValue tick value for a losing position
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {Date} time quote time, in ISO format
   * @property {String} brokerTime time quote time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */

  /**
   * MetaTrader candle
   * @typedef {Object} MetatraderCandle
   * @property {string} symbol symbol (e.g. currency pair or an index)
   * @property {string} timeframe timeframe candle was generated for, e.g. 1h. One of 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m,
   * 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn
   * @property {Date} time candle opening time
   * @property {string} brokerTime candle opening time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {number} open open price
   * @property {number} high high price
   * @property {number} low low price
   * @property {number} close close price
   * @property {number} tickVolume tick volume, i.e. number of ticks inside the candle
   * @property {number} spread spread in points
   * @property {number} volume trade volume
   */

  /**
   * MetaTrader tick data
   * @typedef {Object} MetatraderTick
   * @property {string} symbol symbol (e.g. a currency pair or an index)
   * @property {Date} time time
   * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {number} [bid] bid price
   * @property {number} [ask] ask price
   * @property {number} [last] last deal price
   * @property {number} [volume] volume for the current last deal price
   * @property {string} side is tick a result of buy or sell deal, one of buy or sell
   */

  /**
   * MetaTrader order book
   * @typedef {Object} MetatraderBook
   * @property {string} symbol symbol (e.g. a currency pair or an index)
   * @property {Date} time time
   * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Array<MetatraderBookEntry>} book list of order book entries
   */

  /**
   * MetaTrader order book entry
   * @typedef {Object} MetatraderBookEntry
   * @property {string} type entry type, one of BOOK_TYPE_SELL, BOOK_TYPE_BUY, BOOK_TYPE_SELL_MARKET,
   * BOOK_TYPE_BUY_MARKET
   * @property {number} price price
   * @property {number} volume volume
   */

  // eslint-disable-next-line complexity,max-statements
  async _processSynchronizationPacket(data) {
    try {
      const instanceNumber = data.instanceIndex || 0;
      const socketInstance = this._getSocketInstanceByAccount(data.accountId, instanceNumber);
      if (data.synchronizationId && socketInstance) {
        socketInstance.synchronizationThrottler.updateSynchronizationId(data.synchronizationId);
      }
      const region = this.getAccountRegion(data.accountId);
      const primaryAccountId = this._accountsByReplicaId[data.accountId];
      let instanceId = this._accountsByReplicaId[data.accountId] + ':' + region + ':' + instanceNumber + ':' + (data.host || 0);
      let instanceIndex = region + ':' + instanceNumber + ':' + (data.host || 0);

      const isOnlyActiveInstance = () => {
        const activeInstanceIds = (0, _keys2.default)(this._connectedHosts).filter(instance => instance.startsWith(primaryAccountId + ':' + region + ':' + instanceNumber));
        return !activeInstanceIds.length || activeInstanceIds.length === 1 && activeInstanceIds[0] === instanceId;
      };

      const cancelDisconnectTimer = () => {
        if (this._statusTimers[instanceId]) {
          clearTimeout(this._statusTimers[instanceId]);
        }
      };

      const resetDisconnectTimer = () => {
        cancelDisconnectTimer();
        this._statusTimers[instanceId] = setTimeout(() => {
          if (isOnlyActiveInstance()) {
            this._subscriptionManager.onTimeout(data.accountId, 0);
            this._subscriptionManager.onTimeout(data.accountId, 1);
          }
          this.queueEvent(primaryAccountId, `${instanceIndex}:onDisconnected`, () => onDisconnected(true));
          clearTimeout(this._statusTimers[instanceId]);
        }, 60000);
      };

      // eslint-disable-next-line complexity
      const onDisconnected = async (isTimeout = false) => {
        if (this._connectedHosts[instanceId]) {
          this._latencyService.onDisconnected(instanceId);
          if (isOnlyActiveInstance()) {
            const onDisconnectedPromises = [];
            if (!isTimeout) {
              onDisconnectedPromises.push(this._subscriptionManager.onDisconnected(data.accountId, 0));
              onDisconnectedPromises.push(this._subscriptionManager.onDisconnected(data.accountId, 1));
            }
            for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
              onDisconnectedPromises.push(this._processEvent(() => listener.onDisconnected(instanceIndex), `${primaryAccountId}:${instanceIndex}:onDisconnected`));
            }
            await _promise2.default.all(onDisconnectedPromises);
          }
          const onStreamClosedPromises = [];
          this._packetOrderer.onStreamClosed(instanceId);
          if (socketInstance) {
            socketInstance.synchronizationThrottler.removeIdByParameters(data.accountId, instanceNumber, data.host);
          }
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onStreamClosedPromises.push(this._processEvent(() => listener.onStreamClosed(instanceIndex), `${primaryAccountId}:${instanceIndex}:onStreamClosed`));
          }
          await _promise2.default.all(onStreamClosedPromises);
          delete this._connectedHosts[instanceId];
        }
      };
      if (data.type === 'authenticated') {
        resetDisconnectTimer();
        if (!data.sessionId || socketInstance && data.sessionId === socketInstance.sessionId) {
          this._latencyService.onConnected(instanceId);
          this._connectedHosts[instanceId] = data.host;
          const onConnectedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onConnectedPromises.push(this._processEvent(() => listener.onConnected(instanceIndex, data.replicas), `${primaryAccountId}:${instanceIndex}:onConnected`));
          }
          this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
          if (data.replicas === 1) {
            this._subscriptionManager.cancelAccount(data.accountId);
          } else {
            this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
          }
          await _promise2.default.all(onConnectedPromises);
        }
      } else if (data.type === 'disconnected') {
        cancelDisconnectTimer();
        await onDisconnected();
      } else if (data.type === 'synchronizationStarted') {
        const promises = [];
        this._synchronizationFlags[data.synchronizationId] = {
          accountId: data.accountId,
          instanceNumber,
          positionsUpdated: data.positionsUpdated !== undefined ? data.positionsUpdated : true,
          ordersUpdated: data.ordersUpdated !== undefined ? data.ordersUpdated : true
        };
        this._synchronizationIdByInstance[instanceId] = data.synchronizationId;
        for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
          promises.push(this._processEvent(() => listener.onSynchronizationStarted(instanceIndex, data.specificationsUpdated !== undefined ? data.specificationsUpdated : true, data.positionsUpdated !== undefined ? data.positionsUpdated : true, data.ordersUpdated !== undefined ? data.ordersUpdated : true, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onSynchronizationStarted`));
        }
        await _promise2.default.all(promises);
      } else if (data.type === 'accountInformation') {
        if (data.synchronizationId && data.synchronizationId !== this._synchronizationIdByInstance[instanceId]) {
          return;
        }
        if (data.accountInformation) {
          const onAccountInformationUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onAccountInformationUpdatedPromises.push(_promise2.default.resolve((async () => {
              await this._processEvent(() => listener.onAccountInformationUpdated(instanceIndex, data.accountInformation), `${primaryAccountId}:${instanceIndex}:onAccountInformationUpdated`, true);
              if (this._synchronizationFlags[data.synchronizationId] && !this._synchronizationFlags[data.synchronizationId].positionsUpdated) {
                await this._processEvent(() => listener.onPositionsSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPositionsSynchronized`, true);
                if (!this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
                  await this._processEvent(() => listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPendingOrdersSynchronized`, true);
                }
              }
            })()).catch(err => this._logger.error(`${primaryAccountId}:${instanceIndex}: Failed to notify listener ` + 'about accountInformation event', err)));
          }
          await _promise2.default.all(onAccountInformationUpdatedPromises);
          if (this._synchronizationFlags[data.synchronizationId] && !this._synchronizationFlags[data.synchronizationId].positionsUpdated && !this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
            delete this._synchronizationFlags[data.synchronizationId];
          }
        }
      } else if (data.type === 'deals') {
        if (data.synchronizationId && data.synchronizationId !== this._synchronizationIdByInstance[instanceId]) {
          return;
        }
        for (let deal of data.deals || []) {
          const onDealAddedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onDealAddedPromises.push(this._processEvent(() => listener.onDealAdded(instanceIndex, deal), `${primaryAccountId}:${instanceIndex}:onDealAdded`));
          }
          await _promise2.default.all(onDealAddedPromises);
        }
      } else if (data.type === 'orders') {
        if (data.synchronizationId && data.synchronizationId !== this._synchronizationIdByInstance[instanceId]) {
          return;
        }
        const onPendingOrdersReplacedPromises = [];
        for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
          onPendingOrdersReplacedPromises.push(_promise2.default.resolve((async () => {
            await this._processEvent(() => listener.onPendingOrdersReplaced(instanceIndex, data.orders || []), `${primaryAccountId}:${instanceIndex}:onPendingOrdersReplaced`, true);
            await this._processEvent(() => listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPendingOrdersSynchronized`, true);
          })()).catch(err => this._logger.error(`${primaryAccountId}:${instanceIndex}: Failed to notify listener ` + 'about orders event', err)));
        }
        await _promise2.default.all(onPendingOrdersReplacedPromises);
        if (this._synchronizationFlags[data.synchronizationId]) {
          delete this._synchronizationFlags[data.synchronizationId];
        }
      } else if (data.type === 'historyOrders') {
        if (data.synchronizationId && data.synchronizationId !== this._synchronizationIdByInstance[instanceId]) {
          return;
        }
        for (let historyOrder of data.historyOrders || []) {
          const onHistoryOrderAddedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onHistoryOrderAddedPromises.push(this._processEvent(() => listener.onHistoryOrderAdded(instanceIndex, historyOrder), `${primaryAccountId}:${instanceIndex}:onHistoryOrderAdded`));
          }
          await _promise2.default.all(onHistoryOrderAddedPromises);
        }
      } else if (data.type === 'positions') {
        if (data.synchronizationId && data.synchronizationId !== this._synchronizationIdByInstance[instanceId]) {
          return;
        }
        const onPositionsReplacedPromises = [];
        for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
          onPositionsReplacedPromises.push(_promise2.default.resolve((async () => {
            await this._processEvent(() => listener.onPositionsReplaced(instanceIndex, data.positions || []), `${primaryAccountId}:${instanceIndex}:onPositionsReplaced`, true);
            await this._processEvent(() => listener.onPositionsSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPositionsSynchronized`, true);
            if (this._synchronizationFlags[data.synchronizationId] && !this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
              await this._processEvent(() => listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPendingOrdersSynchronized`, true);
            }
          })()).catch(err => this._logger.error(`${primaryAccountId}:${instanceIndex}: Failed to notify listener ` + 'about positions event', err)));
        }
        await _promise2.default.all(onPositionsReplacedPromises);
        if (this._synchronizationFlags[data.synchronizationId] && !this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
          delete this._synchronizationFlags[data.synchronizationId];
        }
      } else if (data.type === 'update') {
        if (data.accountInformation) {
          const onAccountInformationUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onAccountInformationUpdatedPromises.push(this._processEvent(() => listener.onAccountInformationUpdated(instanceIndex, data.accountInformation), `${primaryAccountId}:${instanceIndex}:onAccountInformationUpdated`));
          }
          await _promise2.default.all(onAccountInformationUpdatedPromises);
        }
        for (let position of data.updatedPositions || []) {
          const onPositionUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onPositionUpdatedPromises.push(this._processEvent(() => listener.onPositionUpdated(instanceIndex, position), `${primaryAccountId}:${instanceIndex}:onPositionUpdated`));
          }
          await _promise2.default.all(onPositionUpdatedPromises);
        }
        for (let positionId of data.removedPositionIds || []) {
          const onPositionRemovedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onPositionRemovedPromises.push(this._processEvent(() => listener.onPositionRemoved(instanceIndex, positionId), `${primaryAccountId}:${instanceIndex}:onPositionRemoved`));
          }
          await _promise2.default.all(onPositionRemovedPromises);
        }
        for (let order of data.updatedOrders || []) {
          const onPendingOrderUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onPendingOrderUpdatedPromises.push(this._processEvent(() => listener.onPendingOrderUpdated(instanceIndex, order), `${primaryAccountId}:${instanceIndex}:onPendingOrderUpdated`));
          }
          await _promise2.default.all(onPendingOrderUpdatedPromises);
        }
        for (let orderId of data.completedOrderIds || []) {
          const onPendingOrderCompletedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onPendingOrderCompletedPromises.push(this._processEvent(() => listener.onPendingOrderCompleted(instanceIndex, orderId), `${primaryAccountId}:${instanceIndex}:onPendingOrderCompleted`));
          }
          await _promise2.default.all(onPendingOrderCompletedPromises);
        }
        for (let historyOrder of data.historyOrders || []) {
          const onHistoryOrderAddedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onHistoryOrderAddedPromises.push(this._processEvent(() => listener.onHistoryOrderAdded(instanceIndex, historyOrder), `${primaryAccountId}:${instanceIndex}:onHistoryOrderAdded`));
          }
          await _promise2.default.all(onHistoryOrderAddedPromises);
        }
        for (let deal of data.deals || []) {
          const onDealAddedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onDealAddedPromises.push(this._processEvent(() => listener.onDealAdded(instanceIndex, deal), `${primaryAccountId}:${instanceIndex}:onDealAdded`));
          }
          await _promise2.default.all(onDealAddedPromises);
        }
        if (data.timestamps) {
          data.timestamps.clientProcessingFinished = new Date();
          const onUpdatePromises = [];
          // eslint-disable-next-line max-depth
          for (let listener of this._latencyListeners || []) {
            onUpdatePromises.push(this._processEvent(() => listener.onUpdate(data.accountId, data.timestamps), `${primaryAccountId}:${instanceIndex}:onUpdate`));
          }
          await _promise2.default.all(onUpdatePromises);
        }
      } else if (data.type === 'dealSynchronizationFinished') {
        if (data.synchronizationId && data.synchronizationId !== this._synchronizationIdByInstance[instanceId]) {
          delete this._synchronizationIdByInstance[instanceId];
          return;
        }
        this._latencyService.onDealsSynchronized(instanceId);
        const onDealsSynchronizedPromises = [];
        for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
          if (socketInstance) {
            socketInstance.synchronizationThrottler.removeSynchronizationId(data.synchronizationId);
          }
          onDealsSynchronizedPromises.push(this._processEvent(() => listener.onDealsSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onDealsSynchronized`));
        }
        await _promise2.default.all(onDealsSynchronizedPromises);
      } else if (data.type === 'orderSynchronizationFinished') {
        if (data.synchronizationId && data.synchronizationId !== this._synchronizationIdByInstance[instanceId]) {
          return;
        }
        const onHistoryOrdersSynchronizedPromises = [];
        for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
          onHistoryOrdersSynchronizedPromises.push(this._processEvent(() => listener.onHistoryOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onHistoryOrdersSynchronized`));
        }
        await _promise2.default.all(onHistoryOrdersSynchronizedPromises);
      } else if (data.type === 'status') {
        if (!this._connectedHosts[instanceId]) {
          if (this._statusTimers[instanceId] && data.authenticated && (this._subscriptionManager.isDisconnectedRetryMode(data.accountId, instanceNumber) || !this._subscriptionManager.isAccountSubscribing(data.accountId, instanceNumber))) {
            this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
            await new _promise2.default(res => setTimeout(res, 10));
            // eslint-disable-next-line no-console
            this._logger.info('it seems like we are not connected to a running API ' + 'server yet, retrying subscription for account ' + instanceId);
            this.ensureSubscribe(data.accountId, instanceNumber);
          }
        } else {
          resetDisconnectTimer();
          const onBrokerConnectionStatusChangedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onBrokerConnectionStatusChangedPromises.push(this._processEvent(() => listener.onBrokerConnectionStatusChanged(instanceIndex, !!data.connected), `${primaryAccountId}:${instanceIndex}:onBrokerConnectionStatusChanged`));
          }
          await _promise2.default.all(onBrokerConnectionStatusChangedPromises);
          if (data.healthStatus) {
            const onHealthStatusPromises = [];
            // eslint-disable-next-line max-depth
            for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
              onHealthStatusPromises.push(this._processEvent(() => listener.onHealthStatus(instanceIndex, data.healthStatus), `${primaryAccountId}:${instanceIndex}:onHealthStatus`));
            }
            await _promise2.default.all(onHealthStatusPromises);
          }
        }
      } else if (data.type === 'downgradeSubscription') {
        // eslint-disable-next-line no-console
        this._logger.info(`${primaryAccountId}:${instanceIndex}: Market data subscriptions for symbol ` + `${data.symbol} were downgraded by the server due to rate limits. Updated subscriptions: ` + `${(0, _stringify2.default)(data.updates)}, removed subscriptions: ${(0, _stringify2.default)(data.unsubscriptions)}. ` + 'Please read https://metaapi.cloud/docs/client/rateLimiting/ for more details.');
        const onSubscriptionDowngradePromises = [];
        for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
          onSubscriptionDowngradePromises.push(this._processEvent(() => listener.onSubscriptionDowngraded(instanceIndex, data.symbol, data.updates, data.unsubscriptions), `${primaryAccountId}:${instanceIndex}:onSubscriptionDowngraded`));
        }
        await _promise2.default.all(onSubscriptionDowngradePromises);
      } else if (data.type === 'specifications') {
        if (data.synchronizationId && data.synchronizationId !== this._synchronizationIdByInstance[instanceId]) {
          return;
        }
        const onSymbolSpecificationsUpdatedPromises = [];
        for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
          onSymbolSpecificationsUpdatedPromises.push(this._processEvent(() => listener.onSymbolSpecificationsUpdated(instanceIndex, data.specifications || [], data.removedSymbols || []), `${primaryAccountId}:${instanceIndex}:onSymbolSpecificationsUpdated`));
        }
        await _promise2.default.all(onSymbolSpecificationsUpdatedPromises);
        for (let specification of data.specifications || []) {
          const onSymbolSpecificationUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onSymbolSpecificationUpdatedPromises.push(this._processEvent(() => listener.onSymbolSpecificationUpdated(instanceIndex, specification), `${primaryAccountId}:${instanceIndex}:onSymbolSpecificationUpdated`));
          }
          await _promise2.default.all(onSymbolSpecificationUpdatedPromises);
        }
        for (let removedSymbol of data.removedSymbols || []) {
          const onSymbolSpecificationRemovedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onSymbolSpecificationRemovedPromises.push(this._processEvent(() => listener.onSymbolSpecificationRemoved(instanceIndex, removedSymbol), `${primaryAccountId}:${instanceIndex}:onSymbolSpecificationRemoved`));
          }
          await _promise2.default.all(onSymbolSpecificationRemovedPromises);
        }
      } else if (data.type === 'prices') {
        if (data.synchronizationId && data.synchronizationId !== this._synchronizationIdByInstance[instanceId]) {
          return;
        }
        let prices = data.prices || [];
        let candles = data.candles || [];
        let ticks = data.ticks || [];
        let books = data.books || [];
        const onSymbolPricesUpdatedPromises = [];
        for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
          if (prices.length) {
            onSymbolPricesUpdatedPromises.push(this._processEvent(() => listener.onSymbolPricesUpdated(instanceIndex, prices, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onSymbolPricesUpdated`));
          }
          if (candles.length) {
            onSymbolPricesUpdatedPromises.push(this._processEvent(() => listener.onCandlesUpdated(instanceIndex, candles, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onCandlesUpdated`));
          }
          if (ticks.length) {
            onSymbolPricesUpdatedPromises.push(this._processEvent(() => listener.onTicksUpdated(instanceIndex, ticks, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onTicksUpdated`));
          }
          if (books.length) {
            onSymbolPricesUpdatedPromises.push(this._processEvent(() => listener.onBooksUpdated(instanceIndex, books, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onBooksUpdated`));
          }
        }
        await _promise2.default.all(onSymbolPricesUpdatedPromises);
        for (let price of prices) {
          const onSymbolPriceUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[primaryAccountId] || []) {
            onSymbolPriceUpdatedPromises.push(this._processEvent(() => listener.onSymbolPriceUpdated(instanceIndex, price), `${primaryAccountId}:${instanceIndex}:onSymbolPriceUpdated`));
          }
          await _promise2.default.all(onSymbolPriceUpdatedPromises);
        }
        for (let price of prices) {
          if (price.timestamps) {
            price.timestamps.clientProcessingFinished = new Date();
            const onSymbolPricePromises = [];
            // eslint-disable-next-line max-depth
            for (let listener of this._latencyListeners || []) {
              onSymbolPricePromises.push(this._processEvent(() => listener.onSymbolPrice(data.accountId, price.symbol, price.timestamps), `${primaryAccountId}:${instanceIndex}:onSymbolPrice`));
            }
            await _promise2.default.all(onSymbolPricePromises);
          }
        }
      }
    } catch (err) {
      this._logger.error('Failed to process incoming synchronization packet', err);
    }
  }

  async _processEvent(callable, label, throwError) {
    const startTime = Date.now();
    let isLongEvent = false;
    let isEventDone = false;

    const checkLongEvent = async () => {
      await new _promise2.default(res => setTimeout(res, 1000));
      if (!isEventDone) {
        isLongEvent = true;
        this._logger.warn(`${label}: event is taking more than 1 second to process`);
      }
    };

    checkLongEvent();
    try {
      await callable();
    } catch (err) {
      if (throwError) {
        throw err;
      }
      this._logger.error(`${label}: event failed with error`, err);
    }
    isEventDone = true;
    if (isLongEvent) {
      this._logger.warn(`${label}: finished in ${Math.floor((Date.now() - startTime) / 1000)} seconds`);
    }
  }

  async _fireReconnected(instanceNumber, socketInstanceIndex, region) {
    try {
      const reconnectListeners = [];
      for (let listener of this._reconnectListeners) {
        if (this._socketInstancesByAccounts[instanceNumber][listener.accountId] === socketInstanceIndex && this.getAccountRegion(listener.accountId) === region) {
          reconnectListeners.push(listener);
        }
      }
      (0, _keys2.default)(this._synchronizationFlags).forEach(synchronizationId => {
        const accountId = this._synchronizationFlags[synchronizationId].accountId;
        if (this._socketInstancesByAccounts[instanceNumber][accountId] === socketInstanceIndex && this._synchronizationFlags[synchronizationId].instanceNumber === instanceNumber && this._regionsByAccounts[accountId] && this._regionsByAccounts[accountId].region === region) {
          delete this._synchronizationFlags[synchronizationId];
        }
      });
      const reconnectAccountIds = reconnectListeners.map(listener => listener.accountId);
      this._subscriptionManager.onReconnected(instanceNumber, socketInstanceIndex, reconnectAccountIds);
      this._packetOrderer.onReconnected(reconnectAccountIds);

      for (let listener of reconnectListeners) {
        _promise2.default.resolve(listener.listener.onReconnected(region, instanceNumber)).catch(err => this._logger.error('Failed to notify reconnect listener', err));
      }
    } catch (err) {
      this._logger.error('Failed to process reconnected event', err);
    }
  }

  _getSocketInstanceByAccount(accountId, instanceNumber) {
    const region = this.getAccountRegion(accountId);
    return this._socketInstances[region][instanceNumber][this._socketInstancesByAccounts[instanceNumber][accountId]];
  }

  async getUrlSettings(instanceNumber, region) {
    if (this._url) {
      return { url: this._url, isSharedClientApi: true };
    }

    const urlSettings = await this._domainClient.getSettings();
    const getUrl = hostname => `https://${hostname}.${region}-${String.fromCharCode(97 + Number(instanceNumber))}.${urlSettings.domain}`;

    let url;
    if (this._useSharedClientApi) {
      url = getUrl(this._hostname);
    } else {
      url = getUrl(urlSettings.hostname);
    }
    const isSharedClientApi = url === getUrl(this._hostname);
    return { url, isSharedClientApi };
  }

  // eslint-disable-next-line complexity
  async _getServerUrl(instanceNumber, socketInstanceIndex, region) {
    if (this._url) {
      return this._url;
    }

    while (this.socketInstances[region][instanceNumber][socketInstanceIndex].connected) {
      try {
        const urlSettings = await this.getUrlSettings(instanceNumber, region);
        const url = urlSettings.url;
        const isSharedClientApi = urlSettings.isSharedClientApi;
        let logMessage = 'Connecting MetaApi websocket client to the MetaApi server ' + `via ${url} ${isSharedClientApi ? 'shared' : 'dedicated'} server.`;
        if (this._firstConnect && !isSharedClientApi) {
          logMessage += ' Please note that it can take up to 3 minutes for your dedicated server to start for the ' + 'first time. During this time it is OK if you see some connection errors.';
          this._firstConnect = false;
        }
        this._logger.info(logMessage);
        return url;
      } catch (err) {
        this._logger.error('Failed to retrieve server URL', err);
        await new _promise2.default(res => setTimeout(res, 1000));
      }
    }
  }

  _throttleRequest(type, accountId, instanceNumber, timeInMs) {
    this._lastRequestsTime[instanceNumber] = this._lastRequestsTime[instanceNumber] || {};
    this._lastRequestsTime[instanceNumber][type] = this._lastRequestsTime[instanceNumber][type] || {};
    let lastTime = this._lastRequestsTime[instanceNumber][type][accountId];
    if (!lastTime || lastTime < Date.now() - timeInMs) {
      this._lastRequestsTime[instanceNumber][type][accountId] = Date.now();
      return !!lastTime;
    }
    return false;
  }

  _refreshAccountRegion(accountId) {
    if (this._regionsByAccounts[accountId]) {
      this._regionsByAccounts[accountId].lastUsed = Date.now();
    }
  }

  //eslint-disable-next-line complexity
  async _createSocketInstanceByAccount(accountId, instanceNumber) {
    const region = this.getAccountRegion(accountId);
    if (this._socketInstancesByAccounts[instanceNumber][accountId] === undefined) {
      let socketInstanceIndex = null;
      while (this._subscribeLock && (new Date(this._subscribeLock.recommendedRetryTime).getTime() > Date.now() && this.subscribedAccountIds(instanceNumber, undefined, region).length < this._subscribeLock.lockedAtAccounts || new Date(this._subscribeLock.lockedAtTime).getTime() + this._subscribeCooldownInSeconds * 1000 > Date.now() && this.subscribedAccountIds(instanceNumber, undefined, region).length >= this._subscribeLock.lockedAtAccounts)) {
        await new _promise2.default(res => setTimeout(res, 1000));
      }
      for (let index = 0; index < this._socketInstances[region][instanceNumber].length; index++) {
        const accountCounter = this.getAssignedAccounts(instanceNumber, index, region).length;
        const instance = this.socketInstances[region][instanceNumber][index];
        if (instance.subscribeLock) {
          if (instance.subscribeLock.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER_PER_SERVER' && (new Date(instance.subscribeLock.recommendedRetryTime).getTime() > Date.now() || this.subscribedAccountIds(instanceNumber, index, region).length >= instance.subscribeLock.lockedAtAccounts)) {
            continue;
          }
          if (instance.subscribeLock.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_SERVER' && new Date(instance.subscribeLock.recommendedRetryTime).getTime() > Date.now() && this.subscribedAccountIds(instanceNumber, index, region).length >= instance.subscribeLock.lockedAtAccounts) {
            continue;
          }
        }
        if (accountCounter < this._maxAccountsPerInstance) {
          socketInstanceIndex = index;
          break;
        }
      }
      if (socketInstanceIndex === null) {
        socketInstanceIndex = this._socketInstances[region][instanceNumber].length;
        await this.connect(instanceNumber, region);
      }
      this._socketInstancesByAccounts[instanceNumber][accountId] = socketInstanceIndex;
    }
  }

  _clearAccountCacheJob() {
    const date = Date.now();
    (0, _keys2.default)(this._regionsByAccounts).forEach(accountId => {
      const data = this._regionsByAccounts[accountId];
      if (data.connections === 0 && date - data.lastUsed > 2 * 60 * 60 * 1000) {
        const primaryAccountId = this._accountsByReplicaId[accountId];
        const replicas = (0, _values2.default)(this._accountReplicas[primaryAccountId]);
        replicas.forEach(replica => {
          delete this._accountsByReplicaId[replica];
          delete this._regionsByAccounts[replica];
        });
        delete this._accountReplicas[primaryAccountId];
      }
    });
  }

}
exports.default = MetaApiWebsocketClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvbWV0YUFwaVdlYnNvY2tldC5jbGllbnQuZXM2Il0sIm5hbWVzIjpbIlBhY2tldExvZ2dlciIsIndpbmRvdyIsInJlcXVpcmUiLCJkZWZhdWx0IiwiTWV0YUFwaVdlYnNvY2tldENsaWVudCIsImNvbnN0cnVjdG9yIiwiZG9tYWluQ2xpZW50IiwidG9rZW4iLCJvcHRzIiwidmFsaWRhdG9yIiwiT3B0aW9uc1ZhbGlkYXRvciIsInBhY2tldE9yZGVyaW5nVGltZW91dCIsInZhbGlkYXRlTm9uWmVybyIsInN5bmNocm9uaXphdGlvblRocm90dGxlciIsIl9kb21haW5DbGllbnQiLCJfYXBwbGljYXRpb24iLCJhcHBsaWNhdGlvbiIsIl9kb21haW4iLCJkb21haW4iLCJfcmVnaW9uIiwicmVnaW9uIiwiX2hvc3RuYW1lIiwiX3VybCIsIl9yZXF1ZXN0VGltZW91dCIsInJlcXVlc3RUaW1lb3V0IiwiX2Nvbm5lY3RUaW1lb3V0IiwiY29ubmVjdFRpbWVvdXQiLCJyZXRyeU9wdHMiLCJfcmV0cmllcyIsInZhbGlkYXRlTnVtYmVyIiwicmV0cmllcyIsIl9taW5SZXRyeURlbGF5SW5TZWNvbmRzIiwibWluRGVsYXlJblNlY29uZHMiLCJfbWF4UmV0cnlEZWxheUluU2Vjb25kcyIsIm1heERlbGF5SW5TZWNvbmRzIiwiX21heEFjY291bnRzUGVySW5zdGFuY2UiLCJfc3Vic2NyaWJlQ29vbGRvd25JblNlY29uZHMiLCJzdWJzY3JpYmVDb29sZG93bkluU2Vjb25kcyIsIl9zZXF1ZW50aWFsRXZlbnRQcm9jZXNzaW5nIiwiX3VzZVNoYXJlZENsaWVudEFwaSIsInZhbGlkYXRlQm9vbGVhbiIsInVzZVNoYXJlZENsaWVudEFwaSIsIl91bnN1YnNjcmliZVRocm90dGxpbmdJbnRlcnZhbCIsInVuc3Vic2NyaWJlVGhyb3R0bGluZ0ludGVydmFsSW5TZWNvbmRzIiwiX3NvY2tldE1pbmltdW1SZWNvbm5lY3RUaW1lb3V0IiwiX2xhdGVuY3lTZXJ2aWNlIiwiTGF0ZW5jeVNlcnZpY2UiLCJfdG9rZW4iLCJfc3luY2hyb25pemF0aW9uTGlzdGVuZXJzIiwiX2xhdGVuY3lMaXN0ZW5lcnMiLCJfcmVjb25uZWN0TGlzdGVuZXJzIiwiX2Nvbm5lY3RlZEhvc3RzIiwiX3NvY2tldEluc3RhbmNlcyIsIl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzIiwiX3JlZ2lvbnNCeUFjY291bnRzIiwiX2FjY291bnRzQnlSZXBsaWNhSWQiLCJfYWNjb3VudFJlcGxpY2FzIiwiX3N5bmNocm9uaXphdGlvblRocm90dGxlck9wdHMiLCJfc3Vic2NyaXB0aW9uTWFuYWdlciIsIlN1YnNjcmlwdGlvbk1hbmFnZXIiLCJfc3RhdHVzVGltZXJzIiwiX2V2ZW50UXVldWVzIiwiX3N5bmNocm9uaXphdGlvbkZsYWdzIiwiX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZSIsIl9zdWJzY3JpYmVMb2NrIiwiX2ZpcnN0Q29ubmVjdCIsIl9sYXN0UmVxdWVzdHNUaW1lIiwiX3BhY2tldE9yZGVyZXIiLCJQYWNrZXRPcmRlcmVyIiwic3RhcnQiLCJwYWNrZXRMb2dnZXIiLCJlbmFibGVkIiwiX3BhY2tldExvZ2dlciIsIl9sb2dnZXIiLCJMb2dnZXJNYW5hZ2VyIiwiZ2V0TG9nZ2VyIiwiX2NsZWFyQWNjb3VudENhY2hlSm9iIiwiYmluZCIsInNldEludGVydmFsIiwib25PdXRPZk9yZGVyUGFja2V0IiwiYWNjb3VudElkIiwiaW5zdGFuY2VJbmRleCIsImV4cGVjdGVkU2VxdWVuY2VOdW1iZXIiLCJhY3R1YWxTZXF1ZW5jZU51bWJlciIsInBhY2tldCIsInJlY2VpdmVkQXQiLCJpc1N1YnNjcmlwdGlvbkFjdGl2ZSIsImVycm9yIiwidHlwZSIsImVuc3VyZVN1YnNjcmliZSIsInVybCIsInNvY2tldEluc3RhbmNlcyIsInNvY2tldEluc3RhbmNlc0J5QWNjb3VudHMiLCJhY2NvdW50UmVwbGljYXMiLCJhY2NvdW50c0J5UmVwbGljYUlkIiwic3Vic2NyaWJlZEFjY291bnRJZHMiLCJpbnN0YW5jZU51bWJlciIsInNvY2tldEluc3RhbmNlSW5kZXgiLCJjb25uZWN0ZWRJZHMiLCJmb3JFYWNoIiwiaW5zdGFuY2VJZCIsInNwbGl0IiwiYWNjb3VudFJlZ2lvbiIsImdldEFjY291bnRSZWdpb24iLCJpbmNsdWRlcyIsInVuZGVmaW5lZCIsInB1c2giLCJjb25uZWN0ZWQiLCJpbnN0YW5jZSIsImxlbmd0aCIsInNvY2tldCIsImdldEFzc2lnbmVkQWNjb3VudHMiLCJhY2NvdW50SWRzIiwia2V5IiwiYWRkQWNjb3VudENhY2hlIiwicmVwbGljYXMiLCJyZXBsaWNhSWQiLCJjb25uZWN0aW9ucyIsImxhc3RVc2VkIiwiRGF0ZSIsIm5vdyIsInJlbW92ZUFjY291bnRDYWNoZSIsImxvY2tTb2NrZXRJbnN0YW5jZSIsIm1ldGFkYXRhIiwicmVjb21tZW5kZWRSZXRyeVRpbWUiLCJsb2NrZWRBdEFjY291bnRzIiwibG9ja2VkQXRUaW1lIiwic3Vic2NyaWJlZEFjY291bnRzIiwic29ja2V0SW5zdGFuY2UiLCJjbG9zZSIsIl9yZWNvbm5lY3QiLCJzdWJzY3JpYmVMb2NrIiwiY29ubmVjdCIsImNsaWVudElkIiwiTWF0aCIsInJhbmRvbSIsInJlc29sdmUiLCJyZXN1bHQiLCJyZXMiLCJyZWoiLCJpZCIsInJlY29ubmVjdFdhaXRUaW1lIiwicmVxdWVzdFJlc29sdmVzIiwicmVzb2x2ZWQiLCJjb25uZWN0UmVzdWx0Iiwic2Vzc2lvbklkIiwicmFuZG9tc3RyaW5nIiwiZ2VuZXJhdGUiLCJpc1JlY29ubmVjdGluZyIsIlN5bmNocm9uaXphdGlvblRocm90dGxlciIsInNlcnZlclVybCIsIl9nZXRTZXJ2ZXJVcmwiLCJwYXRoIiwicmVjb25uZWN0aW9uIiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwiSW5maW5pdHkiLCJ0aW1lb3V0IiwiZXh0cmFIZWFkZXJzIiwicXVlcnkiLCJwcm90b2NvbCIsIm9uIiwiaW5mbyIsIl9maXJlUmVjb25uZWN0ZWQiLCJlcnIiLCJyZWFzb24iLCJvbkRpc2Nvbm5lY3QiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZGVidWciLCJyZXF1ZXN0SWQiLCJ0aW1lc3RhbXBzIiwicmVxdWVzdFJlc29sdmUiLCJyZWplY3QiLCJfY29udmVydElzb1RpbWVUb0RhdGUiLCJjbGllbnRQcm9jZXNzaW5nRmluaXNoZWQiLCJsaXN0ZW5lciIsInRoZW4iLCJvblRyYWRlIiwib25SZXNwb25zZSIsImNhdGNoIiwiX2NvbnZlcnRFcnJvciIsInRyYWNlIiwic2VxdWVuY2VOdW1iZXIiLCJzZXF1ZW5jZVRpbWVzdGFtcCIsInN5bmNocm9uaXphdGlvbklkIiwiaG9zdCIsInNwZWNpZmljYXRpb25zVXBkYXRlZCIsInBvc2l0aW9uc1VwZGF0ZWQiLCJvcmRlcnNVcGRhdGVkIiwic3BlY2lmaWNhdGlvbnMiLCJhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMiLCJsb2dQYWNrZXQiLCJpZ25vcmVkUGFja2V0VHlwZXMiLCJfdGhyb3R0bGVSZXF1ZXN0IiwidW5zdWJzY3JpYmUiLCJ3YXJuIiwicXVldWVQYWNrZXQiLCJFcnJvciIsInN0b3AiLCJnZXRBY2NvdW50SW5mb3JtYXRpb24iLCJyZXNwb25zZSIsInJwY1JlcXVlc3QiLCJhY2NvdW50SW5mb3JtYXRpb24iLCJnZXRQb3NpdGlvbnMiLCJwb3NpdGlvbnMiLCJnZXRQb3NpdGlvbiIsInBvc2l0aW9uSWQiLCJwb3NpdGlvbiIsImdldE9yZGVycyIsIm9yZGVycyIsImdldE9yZGVyIiwib3JkZXJJZCIsIm9yZGVyIiwiZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0IiwidGlja2V0IiwiaGlzdG9yeU9yZGVycyIsInN5bmNocm9uaXppbmciLCJnZXRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbiIsImdldEhpc3RvcnlPcmRlcnNCeVRpbWVSYW5nZSIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJvZmZzZXQiLCJsaW1pdCIsImdldERlYWxzQnlUaWNrZXQiLCJkZWFscyIsImdldERlYWxzQnlQb3NpdGlvbiIsImdldERlYWxzQnlUaW1lUmFuZ2UiLCJyZW1vdmVBcHBsaWNhdGlvbiIsInRyYWRlIiwicmVsaWFiaWxpdHkiLCJycGNSZXF1ZXN0QWxsSW5zdGFuY2VzIiwic3RyaW5nQ29kZSIsImRlc2NyaXB0aW9uIiwibnVtZXJpY0NvZGUiLCJUcmFkZUVycm9yIiwibWVzc2FnZSIsInNjaGVkdWxlU3Vic2NyaWJlIiwic3Vic2NyaWJlIiwic3luY2hyb25pemUiLCJzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUiLCJzdGFydGluZ0RlYWxUaW1lIiwiZ2V0SGFzaGVzIiwiX2dldFNvY2tldEluc3RhbmNlQnlBY2NvdW50IiwiX2NyZWF0ZVNvY2tldEluc3RhbmNlQnlBY2NvdW50Iiwic3luY1Rocm90dGxlciIsInNjaGVkdWxlU3luY2hyb25pemUiLCJ3YWl0U3luY2hyb25pemVkIiwiYXBwbGljYXRpb25QYXR0ZXJuIiwidGltZW91dEluU2Vjb25kcyIsInN1YnNjcmliZVRvTWFya2V0RGF0YSIsInN5bWJvbCIsInN1YnNjcmlwdGlvbnMiLCJyZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMiLCJ1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhIiwiZ2V0U3ltYm9scyIsInN5bWJvbHMiLCJnZXRTeW1ib2xTcGVjaWZpY2F0aW9uIiwic3BlY2lmaWNhdGlvbiIsImdldFN5bWJvbFByaWNlIiwia2VlcFN1YnNjcmlwdGlvbiIsInByaWNlIiwiZ2V0Q2FuZGxlIiwidGltZWZyYW1lIiwiY2FuZGxlIiwiZ2V0VGljayIsInRpY2siLCJnZXRCb29rIiwiYm9vayIsInNhdmVVcHRpbWUiLCJ1cHRpbWUiLCJvblVuc3Vic2NyaWJlIiwiYWxsIiwibWFwIiwiTnVtYmVyIiwibmFtZSIsImdldFNlcnZlclRpbWUiLCJzZXJ2ZXJUaW1lIiwiY2FsY3VsYXRlTWFyZ2luIiwibWFyZ2luIiwidW5zdWJzY3JpYmVBY2NvdW50UmVnaW9uIiwidW5zdWJzY3JpYmVQcm9taXNlcyIsIl9wcm9jZXNzRXZlbnQiLCJvblVuc3Vic2NyaWJlUmVnaW9uIiwiYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJyZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsImZpbHRlciIsImwiLCJhZGRMYXRlbmN5TGlzdGVuZXIiLCJyZW1vdmVMYXRlbmN5TGlzdGVuZXIiLCJhZGRSZWNvbm5lY3RMaXN0ZW5lciIsInJlbW92ZVJlY29ubmVjdExpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicGFja2V0cyIsInJlc3RvcmVPcmRlciIsInAiLCJldmVudHMiLCJwYWNrZXRJdGVtIiwiX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQiLCJfY2FsbEFjY291bnRFdmVudHMiLCJjb25jYXQiLCJxdWV1ZUV2ZW50IiwiY2FsbGFibGUiLCJldmVudCIsInNoaWZ0IiwiX3RyeVJlY29ubmVjdCIsIm1pbiIsInNldFRpbWVvdXQiLCJpbyIsInVyaSIsInJlcXVlc3QiLCJlcnJvcnMiLCJpZ25vcmVkUmVxdWVzdFR5cGVzIiwicHJpbWFyeUFjY291bnRJZCIsImNvbm5lY3RlZEluc3RhbmNlIiwiZ2V0QWN0aXZlQWNjb3VudEluc3RhbmNlcyIsImFjdGl2ZVJlZ2lvbiIsIl9yZWZyZXNoQWNjb3VudFJlZ2lvbiIsIl9tYWtlUmVxdWVzdCIsInJldHJ5Q291bnRlciIsImNhbGNSZXRyeUNvdW50ZXIiLCJjYWxjUmVxdWVzdFRpbWUiLCJwb3ciLCJyZXRyeVRpbWUiLCJnZXRUaW1lIiwiY2xpZW50UHJvY2Vzc2luZ1N0YXJ0ZWQiLCJyYWNlIiwiVGltZW91dEVycm9yIiwiZW1pdCIsIlZhbGlkYXRpb25FcnJvciIsImRldGFpbHMiLCJOb3RGb3VuZEVycm9yIiwiTm90U3luY2hyb25pemVkRXJyb3IiLCJOb3RDb25uZWN0ZWRFcnJvciIsIlVuYXV0aG9yaXplZEVycm9yIiwiVG9vTWFueVJlcXVlc3RzRXJyb3IiLCJJbnRlcm5hbEVycm9yIiwiZmllbGQiLCJ2YWx1ZSIsIm1hdGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiaXRlbSIsInByaWNlcyIsInVwZGF0ZVN5bmNocm9uaXphdGlvbklkIiwiaXNPbmx5QWN0aXZlSW5zdGFuY2UiLCJhY3RpdmVJbnN0YW5jZUlkcyIsInN0YXJ0c1dpdGgiLCJjYW5jZWxEaXNjb25uZWN0VGltZXIiLCJjbGVhclRpbWVvdXQiLCJyZXNldERpc2Nvbm5lY3RUaW1lciIsIm9uVGltZW91dCIsIm9uRGlzY29ubmVjdGVkIiwiaXNUaW1lb3V0Iiwib25EaXNjb25uZWN0ZWRQcm9taXNlcyIsIm9uU3RyZWFtQ2xvc2VkUHJvbWlzZXMiLCJvblN0cmVhbUNsb3NlZCIsInJlbW92ZUlkQnlQYXJhbWV0ZXJzIiwib25Db25uZWN0ZWQiLCJvbkNvbm5lY3RlZFByb21pc2VzIiwiY2FuY2VsU3Vic2NyaWJlIiwiY2FuY2VsQWNjb3VudCIsInByb21pc2VzIiwib25TeW5jaHJvbml6YXRpb25TdGFydGVkIiwib25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMiLCJvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQiLCJvblBvc2l0aW9uc1N5bmNocm9uaXplZCIsIm9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZCIsImRlYWwiLCJvbkRlYWxBZGRlZFByb21pc2VzIiwib25EZWFsQWRkZWQiLCJvblBlbmRpbmdPcmRlcnNSZXBsYWNlZFByb21pc2VzIiwib25QZW5kaW5nT3JkZXJzUmVwbGFjZWQiLCJoaXN0b3J5T3JkZXIiLCJvbkhpc3RvcnlPcmRlckFkZGVkUHJvbWlzZXMiLCJvbkhpc3RvcnlPcmRlckFkZGVkIiwib25Qb3NpdGlvbnNSZXBsYWNlZFByb21pc2VzIiwib25Qb3NpdGlvbnNSZXBsYWNlZCIsInVwZGF0ZWRQb3NpdGlvbnMiLCJvblBvc2l0aW9uVXBkYXRlZFByb21pc2VzIiwib25Qb3NpdGlvblVwZGF0ZWQiLCJyZW1vdmVkUG9zaXRpb25JZHMiLCJvblBvc2l0aW9uUmVtb3ZlZFByb21pc2VzIiwib25Qb3NpdGlvblJlbW92ZWQiLCJ1cGRhdGVkT3JkZXJzIiwib25QZW5kaW5nT3JkZXJVcGRhdGVkUHJvbWlzZXMiLCJvblBlbmRpbmdPcmRlclVwZGF0ZWQiLCJjb21wbGV0ZWRPcmRlcklkcyIsIm9uUGVuZGluZ09yZGVyQ29tcGxldGVkUHJvbWlzZXMiLCJvblBlbmRpbmdPcmRlckNvbXBsZXRlZCIsIm9uVXBkYXRlUHJvbWlzZXMiLCJvblVwZGF0ZSIsIm9uRGVhbHNTeW5jaHJvbml6ZWQiLCJvbkRlYWxzU3luY2hyb25pemVkUHJvbWlzZXMiLCJyZW1vdmVTeW5jaHJvbml6YXRpb25JZCIsIm9uSGlzdG9yeU9yZGVyc1N5bmNocm9uaXplZFByb21pc2VzIiwib25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkIiwiYXV0aGVudGljYXRlZCIsImlzRGlzY29ubmVjdGVkUmV0cnlNb2RlIiwiaXNBY2NvdW50U3Vic2NyaWJpbmciLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkUHJvbWlzZXMiLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkIiwiaGVhbHRoU3RhdHVzIiwib25IZWFsdGhTdGF0dXNQcm9taXNlcyIsIm9uSGVhbHRoU3RhdHVzIiwidXBkYXRlcyIsInVuc3Vic2NyaXB0aW9ucyIsIm9uU3Vic2NyaXB0aW9uRG93bmdyYWRlUHJvbWlzZXMiLCJvblN1YnNjcmlwdGlvbkRvd25ncmFkZWQiLCJvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZFByb21pc2VzIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQiLCJyZW1vdmVkU3ltYm9scyIsIm9uU3ltYm9sU3BlY2lmaWNhdGlvblVwZGF0ZWRQcm9taXNlcyIsIm9uU3ltYm9sU3BlY2lmaWNhdGlvblVwZGF0ZWQiLCJyZW1vdmVkU3ltYm9sIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uUmVtb3ZlZFByb21pc2VzIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uUmVtb3ZlZCIsImNhbmRsZXMiLCJ0aWNrcyIsImJvb2tzIiwib25TeW1ib2xQcmljZXNVcGRhdGVkUHJvbWlzZXMiLCJvblN5bWJvbFByaWNlc1VwZGF0ZWQiLCJlcXVpdHkiLCJmcmVlTWFyZ2luIiwibWFyZ2luTGV2ZWwiLCJhY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUiLCJvbkNhbmRsZXNVcGRhdGVkIiwib25UaWNrc1VwZGF0ZWQiLCJvbkJvb2tzVXBkYXRlZCIsIm9uU3ltYm9sUHJpY2VVcGRhdGVkUHJvbWlzZXMiLCJvblN5bWJvbFByaWNlVXBkYXRlZCIsIm9uU3ltYm9sUHJpY2VQcm9taXNlcyIsIm9uU3ltYm9sUHJpY2UiLCJsYWJlbCIsInRocm93RXJyb3IiLCJpc0xvbmdFdmVudCIsImlzRXZlbnREb25lIiwiY2hlY2tMb25nRXZlbnQiLCJmbG9vciIsInJlY29ubmVjdExpc3RlbmVycyIsInJlY29ubmVjdEFjY291bnRJZHMiLCJvblJlY29ubmVjdGVkIiwiZ2V0VXJsU2V0dGluZ3MiLCJpc1NoYXJlZENsaWVudEFwaSIsInVybFNldHRpbmdzIiwiZ2V0U2V0dGluZ3MiLCJnZXRVcmwiLCJob3N0bmFtZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImxvZ01lc3NhZ2UiLCJ0aW1lSW5NcyIsImxhc3RUaW1lIiwiaW5kZXgiLCJhY2NvdW50Q291bnRlciIsImRhdGUiLCJyZXBsaWNhIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBSUEsWUFBSjtBQUNBLElBQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQztBQUFFO0FBQ25DRCxpQkFBZUUsUUFBUSxnQkFBUixFQUEwQkMsT0FBekM7QUFDRDs7QUFFRDs7O0FBR2UsTUFBTUMsc0JBQU4sQ0FBNkI7O0FBRTFDOzs7Ozs7QUFNQTtBQUNBQyxj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QixJQUEwQnFWLE9BQU9sUyxLQUFLbEQsUUFBWixHQUF1QixJQUFJLEVBQUosR0FBUyxFQUFULEdBQWMsSUFBbEUsRUFBd0U7QUFDdEUsY0FBTXNNLG1CQUFtQixLQUFLclEsb0JBQUwsQ0FBMEJ5QixTQUExQixDQUF6QjtBQUNBLGNBQU1tQyxXQUFXLHNCQUFjLEtBQUszRCxnQkFBTCxDQUFzQm9RLGdCQUF0QixDQUFkLENBQWpCO0FBQ0F6TSxpQkFBU2hCLE9BQVQsQ0FBaUJ3VyxXQUFXO0FBQzFCLGlCQUFPLEtBQUtwWixvQkFBTCxDQUEwQm9aLE9BQTFCLENBQVA7QUFDQSxpQkFBTyxLQUFLclosa0JBQUwsQ0FBd0JxWixPQUF4QixDQUFQO0FBQ0QsU0FIRDtBQUlBLGVBQU8sS0FBS25aLGdCQUFMLENBQXNCb1EsZ0JBQXRCLENBQVA7QUFDRDtBQUNGLEtBWEQ7QUFZRDs7QUF2MUV5QztrQkFBdkJ4VCxzQiIsImZpbGUiOiJtZXRhQXBpV2Vic29ja2V0LmNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHJhbmRvbXN0cmluZyBmcm9tICdyYW5kb21zdHJpbmcnO1xuaW1wb3J0IHNvY2tldElPIGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuaW1wb3J0IFRpbWVvdXRFcnJvciBmcm9tICcuLi90aW1lb3V0RXJyb3InO1xuaW1wb3J0IHtWYWxpZGF0aW9uRXJyb3IsIE5vdEZvdW5kRXJyb3IsIEludGVybmFsRXJyb3IsIFVuYXV0aG9yaXplZEVycm9yLCBUb29NYW55UmVxdWVzdHNFcnJvcn0gZnJvbSAnLi4vZXJyb3JIYW5kbGVyJztcbmltcG9ydCBPcHRpb25zVmFsaWRhdG9yIGZyb20gJy4uL29wdGlvbnNWYWxpZGF0b3InO1xuaW1wb3J0IE5vdFN5bmNocm9uaXplZEVycm9yIGZyb20gJy4vbm90U3luY2hyb25pemVkRXJyb3InO1xuaW1wb3J0IE5vdENvbm5lY3RlZEVycm9yIGZyb20gJy4vbm90Q29ubmVjdGVkRXJyb3InO1xuaW1wb3J0IFRyYWRlRXJyb3IgZnJvbSAnLi90cmFkZUVycm9yJztcbmltcG9ydCBQYWNrZXRPcmRlcmVyIGZyb20gJy4vcGFja2V0T3JkZXJlcic7XG5pbXBvcnQgU3luY2hyb25pemF0aW9uVGhyb3R0bGVyIGZyb20gJy4vc3luY2hyb25pemF0aW9uVGhyb3R0bGVyJztcbmltcG9ydCBTdWJzY3JpcHRpb25NYW5hZ2VyIGZyb20gJy4vc3Vic2NyaXB0aW9uTWFuYWdlcic7XG5pbXBvcnQgTG9nZ2VyTWFuYWdlciBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IGFueSBmcm9tICdwcm9taXNlLmFueSc7XG5pbXBvcnQgTGF0ZW5jeVNlcnZpY2UgZnJvbSAnLi9sYXRlbmN5U2VydmljZSc7XG5cbmxldCBQYWNrZXRMb2dnZXI7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgLy8gZG9uJ3QgaW1wb3J0IFBhY2tldExvZ2dlciBmb3IgYnJvd3NlciB2ZXJzaW9uXG4gIFBhY2tldExvZ2dlciA9IHJlcXVpcmUoJy4vcGFja2V0TG9nZ2VyJykuZGVmYXVsdDtcbn1cblxuLyoqXG4gKiBNZXRhQXBpIHdlYnNvY2tldCBBUEkgY2xpZW50IChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9vdmVydmlldy8pXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ldGFBcGlXZWJzb2NrZXRDbGllbnQge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIE1ldGFBcGkgd2Vic29ja2V0IEFQSSBjbGllbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtEb21haW5DbGllbnR9IGRvbWFpbkNsaWVudCBkb21haW4gY2xpZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBhdXRob3JpemF0aW9uIHRva2VuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIHdlYnNvY2tldCBjbGllbnQgb3B0aW9uc1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHksbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoZG9tYWluQ2xpZW50LCB0b2tlbiwgb3B0cykge1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBPcHRpb25zVmFsaWRhdG9yKCk7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgb3B0cy5wYWNrZXRPcmRlcmluZ1RpbWVvdXQgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMucGFja2V0T3JkZXJpbmdUaW1lb3V0LCA2MCwgJ3BhY2tldE9yZGVyaW5nVGltZW91dCcpO1xuICAgIG9wdHMuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyID0gb3B0cy5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIgfHwge307XG4gICAgdGhpcy5fZG9tYWluQ2xpZW50ID0gZG9tYWluQ2xpZW50O1xuICAgIHRoaXMuX2FwcGxpY2F0aW9uID0gb3B0cy5hcHBsaWNhdGlvbiB8fCAnTWV0YUFwaSc7XG4gICAgdGhpcy5fZG9tYWluID0gb3B0cy5kb21haW4gfHwgJ2FnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWknO1xuICAgIHRoaXMuX3JlZ2lvbiA9IG9wdHMucmVnaW9uO1xuICAgIHRoaXMuX2hvc3RuYW1lID0gJ210LWNsaWVudC1hcGktdjEnO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdFRpbWVvdXQgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMucmVxdWVzdFRpbWVvdXQsIDYwLCAncmVxdWVzdFRpbWVvdXQnKSAqIDEwMDA7XG4gICAgdGhpcy5fY29ubmVjdFRpbWVvdXQgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMuY29ubmVjdFRpbWVvdXQsIDYwLCAnY29ubmVjdFRpbWVvdXQnKSAqIDEwMDA7XG4gICAgY29uc3QgcmV0cnlPcHRzID0gb3B0cy5yZXRyeU9wdHMgfHwge307XG4gICAgdGhpcy5fcmV0cmllcyA9IHZhbGlkYXRvci52YWxpZGF0ZU51bWJlcihyZXRyeU9wdHMucmV0cmllcywgNSwgJ3JldHJ5T3B0cy5yZXRyaWVzJyk7XG4gICAgdGhpcy5fbWluUmV0cnlEZWxheUluU2Vjb25kcyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ocmV0cnlPcHRzLm1pbkRlbGF5SW5TZWNvbmRzLCAxLFxuICAgICAgJ3JldHJ5T3B0cy5taW5EZWxheUluU2Vjb25kcycpO1xuICAgIHRoaXMuX21heFJldHJ5RGVsYXlJblNlY29uZHMgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKHJldHJ5T3B0cy5tYXhEZWxheUluU2Vjb25kcywgMzAsXG4gICAgICAncmV0cnlPcHRzLm1heERlbGF5SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fbWF4QWNjb3VudHNQZXJJbnN0YW5jZSA9IDEwMDtcbiAgICB0aGlzLl9zdWJzY3JpYmVDb29sZG93bkluU2Vjb25kcyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ocmV0cnlPcHRzLnN1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzLCA2MDAsIFxuICAgICAgJ3JldHJ5T3B0cy5zdWJzY3JpYmVDb29sZG93bkluU2Vjb25kcycpO1xuICAgIHRoaXMuX3NlcXVlbnRpYWxFdmVudFByb2Nlc3NpbmcgPSB0cnVlO1xuICAgIHRoaXMuX3VzZVNoYXJlZENsaWVudEFwaSA9IHZhbGlkYXRvci52YWxpZGF0ZUJvb2xlYW4ob3B0cy51c2VTaGFyZWRDbGllbnRBcGksIGZhbHNlLCAndXNlU2hhcmVkQ2xpZW50QXBpJyk7XG4gICAgdGhpcy5fdW5zdWJzY3JpYmVUaHJvdHRsaW5nSW50ZXJ2YWwgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMudW5zdWJzY3JpYmVUaHJvdHRsaW5nSW50ZXJ2YWxJblNlY29uZHMsIDEwLFxuICAgICAgJ3Vuc3Vic2NyaWJlVGhyb3R0bGluZ0ludGVydmFsSW5TZWNvbmRzJykgKiAxMDAwO1xuICAgIHRoaXMuX3NvY2tldE1pbmltdW1SZWNvbm5lY3RUaW1lb3V0ID0gNTAwO1xuICAgIHRoaXMuX2xhdGVuY3lTZXJ2aWNlID0gbmV3IExhdGVuY3lTZXJ2aWNlKHRoaXMsIHRva2VuLCB0aGlzLl9jb25uZWN0VGltZW91dCk7XG4gICAgdGhpcy5fdG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fY29ubmVjdGVkSG9zdHMgPSB7fTtcbiAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXMgPSB7fTtcbiAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzID0ge307XG4gICAgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHMgPSB7fTtcbiAgICB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkID0ge307XG4gICAgdGhpcy5fYWNjb3VudFJlcGxpY2FzID0ge307XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uVGhyb3R0bGVyT3B0cyA9IG9wdHMuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLl9zdGF0dXNUaW1lcnMgPSB7fTtcbiAgICB0aGlzLl9ldmVudFF1ZXVlcyA9IHt9O1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzID0ge307XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlID0ge307XG4gICAgdGhpcy5fc3Vic2NyaWJlTG9jayA9IG51bGw7XG4gICAgdGhpcy5fZmlyc3RDb25uZWN0ID0gdHJ1ZTtcbiAgICB0aGlzLl9sYXN0UmVxdWVzdHNUaW1lID0ge307XG4gICAgdGhpcy5fcGFja2V0T3JkZXJlciA9IG5ldyBQYWNrZXRPcmRlcmVyKHRoaXMsIG9wdHMucGFja2V0T3JkZXJpbmdUaW1lb3V0KTtcbiAgICB0aGlzLl9wYWNrZXRPcmRlcmVyLnN0YXJ0KCk7XG4gICAgaWYob3B0cy5wYWNrZXRMb2dnZXIgJiYgb3B0cy5wYWNrZXRMb2dnZXIuZW5hYmxlZCkge1xuICAgICAgdGhpcy5fcGFja2V0TG9nZ2VyID0gbmV3IFBhY2tldExvZ2dlcihvcHRzLnBhY2tldExvZ2dlcik7XG4gICAgICB0aGlzLl9wYWNrZXRMb2dnZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyTWFuYWdlci5nZXRMb2dnZXIoJ01ldGFBcGlXZWJzb2NrZXRDbGllbnQnKTtcbiAgICB0aGlzLl9jbGVhckFjY291bnRDYWNoZUpvYiA9IHRoaXMuX2NsZWFyQWNjb3VudENhY2hlSm9iLmJpbmQodGhpcyk7XG4gICAgc2V0SW50ZXJ2YWwodGhpcy5fY2xlYXJBY2NvdW50Q2FjaGVKb2IsIDMwICogNjAgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0YXJ0cyB0aGUgYWNjb3VudCBzeW5jaHJvbml6YXRpb24gcHJvY2VzcyBvbiBhbiBvdXQgb2Ygb3JkZXIgcGFja2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VJbmRleCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRTZXF1ZW5jZU51bWJlciBleHBlY3RlZCBzL25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFjdHVhbFNlcXVlbmNlTnVtYmVyIGFjdHVhbCBzL25cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBwYWNrZXQgZGF0YVxuICAgKiBAcGFyYW0ge0RhdGV9IHJlY2VpdmVkQXQgdGltZSB0aGUgcGFja2V0IHdhcyByZWNlaXZlZCBhdFxuICAgKi9cbiAgb25PdXRPZk9yZGVyUGFja2V0KGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCwgZXhwZWN0ZWRTZXF1ZW5jZU51bWJlciwgYWN0dWFsU2VxdWVuY2VOdW1iZXIsIHBhY2tldCwgcmVjZWl2ZWRBdCkge1xuICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLmlzU3Vic2NyaXB0aW9uQWN0aXZlKGFjY291bnRJZCkpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IHJlY2VpdmVkIGFuIG91dCBvZiBvcmRlciAnICtcbiAgICAgICAgYHBhY2tldCB0eXBlICR7cGFja2V0LnR5cGV9IGZvciBhY2NvdW50IGlkICR7YWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9LiBFeHBlY3RlZCBzL24gYCArXG4gICAgICAgIGAke2V4cGVjdGVkU2VxdWVuY2VOdW1iZXJ9IGRvZXMgbm90IG1hdGNoIHRoZSBhY3R1YWwgb2YgJHthY3R1YWxTZXF1ZW5jZU51bWJlcn1gKTtcbiAgICAgIHRoaXMuZW5zdXJlU3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhdGNoIHNlcnZlciBVUkwgZm9yIHVzZSBpbiB1bml0IHRlc3RzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgcGF0Y2hlZCBzZXJ2ZXIgVVJMXG4gICAqL1xuICBzZXQgdXJsKHVybCkge1xuICAgIHRoaXMuX3VybCA9IHVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZWJzb2NrZXQgY2xpZW50IHByZWRlZmluZWQgcmVnaW9uXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWRlZmluZWQgcmVnaW9uXG4gICAqL1xuICBnZXQgcmVnaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWdpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBzb2NrZXQgaW5zdGFuY2UgZGljdGlvbmFyaWVzXG4gICAqIEByZXR1cm4ge09iamVjdFtdfSBsaXN0IG9mIHNvY2tldCBpbnN0YW5jZSBkaWN0aW9uYXJpZXNcbiAgICovXG4gIGdldCBzb2NrZXRJbnN0YW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldEluc3RhbmNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaWN0aW9uYXJ5IG9mIHNvY2tldCBpbnN0YW5jZXMgYnkgYWNjb3VudCBpZHNcbiAgICogQHJldHVybiB7T2JqZWN0fSBkaWN0aW9uYXJ5IG9mIHNvY2tldCBpbnN0YW5jZXMgYnkgYWNjb3VudCBpZHNcbiAgICovXG4gIGdldCBzb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpY3Rpb25hcnkgb2YgYWNjb3VudCByZXBsaWNhcyBieSByZWdpb25cbiAgICogQHJldHVybiB7T2JqZWN0fSBkaWN0aW9uYXJ5IG9mIGFjY291bnQgcmVwbGljYXMgYnkgcmVnaW9uXG4gICAqL1xuICBnZXQgYWNjb3VudFJlcGxpY2FzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY2NvdW50UmVwbGljYXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGljdGlvbmFyeSBvZiBwcmltYXJ5IGFjY291bnQgaWRzIGJ5IHJlcGxpY2EgaWRzXG4gICAqIEByZXR1cm4ge09iamVjdH0gZGljdGlvbmFyeSBvZiBwcmltYXJ5IGFjY291bnQgaWRzIGJ5IHJlcGxpY2EgaWRzXG4gICAqL1xuICBnZXQgYWNjb3VudHNCeVJlcGxpY2FJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHN1YnNjcmliZWQgYWNjb3VudCBpZHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc29ja2V0SW5zdGFuY2VJbmRleCBzb2NrZXQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBzZXJ2ZXIgcmVnaW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfSBsaXN0IG9mIHN1YnNjcmliZWQgYWNjb3VudCBpZHNcbiAgICovXG4gIHN1YnNjcmliZWRBY2NvdW50SWRzKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pIHtcbiAgICBjb25zdCBjb25uZWN0ZWRJZHMgPSBbXTtcbiAgICBpZih0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXSkge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fY29ubmVjdGVkSG9zdHMpLmZvckVhY2goaW5zdGFuY2VJZCA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnRJZCA9IGluc3RhbmNlSWQuc3BsaXQoJzonKVswXTtcbiAgICAgICAgY29uc3QgYWNjb3VudFJlZ2lvbiA9IHRoaXMuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgICAgICBpZighY29ubmVjdGVkSWRzLmluY2x1ZGVzKGFjY291bnRJZCkgJiYgXG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0gIT09IHVuZGVmaW5lZCAmJiAoXG4gICAgICAgICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSA9PT0gc29ja2V0SW5zdGFuY2VJbmRleCB8fCBcbiAgICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9PT0gdW5kZWZpbmVkKSAmJiBhY2NvdW50UmVnaW9uID09PSByZWdpb24pIHtcbiAgICAgICAgICBjb25uZWN0ZWRJZHMucHVzaChhY2NvdW50SWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3RlZElkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGlvbiBzdGF0dXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gc29ja2V0SW5zdGFuY2VJbmRleCBzb2NrZXQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBzZXJ2ZXIgcmVnaW9uXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB3ZWJzb2NrZXQgY2xpZW50IGNvbm5lY3Rpb24gc3RhdHVzXG4gICAqL1xuICBjb25uZWN0ZWQoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbikge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl0gJiYgXG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0ubGVuZ3RoID4gc29ja2V0SW5zdGFuY2VJbmRleCA/IFxuICAgICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdIDogbnVsbDtcbiAgICByZXR1cm4gKGluc3RhbmNlICYmIGluc3RhbmNlLnNvY2tldCAmJiBpbnN0YW5jZS5zb2NrZXQuY29ubmVjdGVkKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgYWNjb3VudHMgYXNzaWduZWQgdG8gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc29ja2V0SW5zdGFuY2VJbmRleCBzb2NrZXQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBzZXJ2ZXIgcmVnaW9uXG4gICAqIEByZXR1cm5zIFxuICAgKi9cbiAgZ2V0QXNzaWduZWRBY2NvdW50cyhpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKSB7XG4gICAgY29uc3QgYWNjb3VudElkcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBhY2NvdW50UmVnaW9uID0gdGhpcy5nZXRBY2NvdW50UmVnaW9uKGtleSk7XG4gICAgICBpZiAoYWNjb3VudFJlZ2lvbiA9PT0gcmVnaW9uICYmXG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2tleV0gPT09IHNvY2tldEluc3RhbmNlSW5kZXgpIHtcbiAgICAgICAgYWNjb3VudElkcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY291bnRJZHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHJlZ2lvbiBieSBpZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHJldHVybnMge1N0cmluZ30gYWNjb3VudCByZWdpb25cbiAgICovXG4gIGdldEFjY291bnRSZWdpb24oYWNjb3VudElkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF0gJiYgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXS5yZWdpb247XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhY2NvdW50IGNhY2hlIGluZm9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXBsaWNhcyBhY2NvdW50IHJlcGxpY2FzXG4gICAqL1xuICBhZGRBY2NvdW50Q2FjaGUoYWNjb3VudElkLCByZXBsaWNhcykge1xuICAgIHRoaXMuX2FjY291bnRSZXBsaWNhc1thY2NvdW50SWRdID0gcmVwbGljYXM7XG4gICAgT2JqZWN0LmtleXMocmVwbGljYXMpLmZvckVhY2gocmVnaW9uID0+IHtcbiAgICAgIGNvbnN0IHJlcGxpY2FJZCA9IHJlcGxpY2FzW3JlZ2lvbl07XG4gICAgICBpZighdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbcmVwbGljYUlkXSkge1xuICAgICAgICB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1tyZXBsaWNhSWRdID0ge1xuICAgICAgICAgIHJlZ2lvbixcbiAgICAgICAgICBjb25uZWN0aW9uczogMSxcbiAgICAgICAgICBsYXN0VXNlZDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbcmVwbGljYUlkXS5jb25uZWN0aW9ucysrO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFtyZXBsaWNhSWRdID0gYWNjb3VudElkO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWNjb3VudCByZWdpb24gaW5mb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICovXG4gIHJlbW92ZUFjY291bnRDYWNoZShhY2NvdW50SWQpIHtcbiAgICBpZih0aGlzLl9yZWdpb25zQnlBY2NvdW50c1thY2NvdW50SWRdKSB7XG4gICAgICBpZih0aGlzLl9yZWdpb25zQnlBY2NvdW50c1thY2NvdW50SWRdLmNvbm5lY3Rpb25zID4gMCkge1xuICAgICAgICB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1thY2NvdW50SWRdLmNvbm5lY3Rpb25zLS07IFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrcyBzdWJzY3JpcHRpb24gZm9yIGEgc29ja2V0IGluc3RhbmNlIGJhc2VkIG9uIFRvb01hbnlSZXF1ZXN0c0Vycm9yIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNvY2tldEluc3RhbmNlSW5kZXggc29ja2V0IGluc3RhbmNlIGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWdpb24gc2VydmVyIHJlZ2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YWRhdGEgVG9vTWFueVJlcXVlc3RzRXJyb3IgbWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIGxvY2tTb2NrZXRJbnN0YW5jZShpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uLCBtZXRhZGF0YSkge1xuICAgIGlmIChtZXRhZGF0YS50eXBlID09PSAnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSJykge1xuICAgICAgdGhpcy5fc3Vic2NyaWJlTG9jayA9IHtcbiAgICAgICAgcmVjb21tZW5kZWRSZXRyeVRpbWU6IG1ldGFkYXRhLnJlY29tbWVuZGVkUmV0cnlUaW1lLFxuICAgICAgICBsb2NrZWRBdEFjY291bnRzOiB0aGlzLnN1YnNjcmliZWRBY2NvdW50SWRzKGluc3RhbmNlTnVtYmVyLCB1bmRlZmluZWQsIHJlZ2lvbikubGVuZ3RoLFxuICAgICAgICBsb2NrZWRBdFRpbWU6IERhdGUubm93KClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN1YnNjcmliZWRBY2NvdW50cyA9IHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbik7XG4gICAgICBpZiAoc3Vic2NyaWJlZEFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBzb2NrZXRJbnN0YW5jZSA9IHRoaXMuc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdO1xuICAgICAgICBzb2NrZXRJbnN0YW5jZS5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcmVjb25uZWN0KGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLnNvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXVtzb2NrZXRJbnN0YW5jZUluZGV4XTtcbiAgICAgICAgaW5zdGFuY2Uuc3Vic2NyaWJlTG9jayA9IHtcbiAgICAgICAgICByZWNvbW1lbmRlZFJldHJ5VGltZTogbWV0YWRhdGEucmVjb21tZW5kZWRSZXRyeVRpbWUsXG4gICAgICAgICAgdHlwZTogbWV0YWRhdGEudHlwZSxcbiAgICAgICAgICBsb2NrZWRBdEFjY291bnRzOiBzdWJzY3JpYmVkQWNjb3VudHMubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIE1ldGFBcGkgc2VydmVyIHZpYSBzb2NrZXQuaW8gcHJvdG9jb2xcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVnaW9uIHNlcnZlciByZWdpb25cbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkXG4gICAqL1xuICBhc3luYyBjb25uZWN0KGluc3RhbmNlTnVtYmVyLCByZWdpb24pIHtcbiAgICBsZXQgY2xpZW50SWQgPSBNYXRoLnJhbmRvbSgpO1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgfSk7XG4gICAgY29uc3Qgc29ja2V0SW5zdGFuY2VJbmRleCA9IHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXS5sZW5ndGg7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgICBpZDogc29ja2V0SW5zdGFuY2VJbmRleCxcbiAgICAgIHJlY29ubmVjdFdhaXRUaW1lOiB0aGlzLl9zb2NrZXRNaW5pbXVtUmVjb25uZWN0VGltZW91dCxcbiAgICAgIGNvbm5lY3RlZDogZmFsc2UsXG4gICAgICByZXF1ZXN0UmVzb2x2ZXM6IHt9LFxuICAgICAgcmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgY29ubmVjdFJlc3VsdDogcmVzdWx0LFxuICAgICAgc2Vzc2lvbklkOiByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpLFxuICAgICAgaXNSZWNvbm5lY3Rpbmc6IGZhbHNlLFxuICAgICAgc29ja2V0OiBudWxsLFxuICAgICAgc3luY2hyb25pemF0aW9uVGhyb3R0bGVyOiBuZXcgU3luY2hyb25pemF0aW9uVGhyb3R0bGVyKHRoaXMsIHNvY2tldEluc3RhbmNlSW5kZXgsIGluc3RhbmNlTnVtYmVyLCByZWdpb24sXG4gICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblRocm90dGxlck9wdHMpLFxuICAgICAgc3Vic2NyaWJlTG9jazogbnVsbCxcbiAgICAgIGluc3RhbmNlTnVtYmVyXG4gICAgfTtcbiAgICBpbnN0YW5jZS5jb25uZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXS5wdXNoKGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuc3RhcnQoKTtcbiAgICBjb25zdCBzZXJ2ZXJVcmwgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJVcmwoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbik7XG4gICAgY29uc3Qgc29ja2V0SW5zdGFuY2UgPSBzb2NrZXRJTyhzZXJ2ZXJVcmwsIHtcbiAgICAgIHBhdGg6ICcvd3MnLFxuICAgICAgcmVjb25uZWN0aW9uOiB0cnVlLFxuICAgICAgcmVjb25uZWN0aW9uRGVsYXk6IDEwMDAsXG4gICAgICByZWNvbm5lY3Rpb25EZWxheU1heDogNTAwMCxcbiAgICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiBJbmZpbml0eSxcbiAgICAgIHRpbWVvdXQ6IHRoaXMuX2Nvbm5lY3RUaW1lb3V0LFxuICAgICAgZXh0cmFIZWFkZXJzOiB7XG4gICAgICAgICdDbGllbnQtSWQnOiBjbGllbnRJZFxuICAgICAgfSxcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdGhpcy5fdG9rZW4sXG4gICAgICAgIGNsaWVudElkOiBjbGllbnRJZCxcbiAgICAgICAgcHJvdG9jb2w6IDNcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpbnN0YW5jZS5zb2NrZXQgPSBzb2NrZXRJbnN0YW5jZTtcbiAgICBzb2NrZXRJbnN0YW5jZS5vbignY29ubmVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgJHtyZWdpb259OiR7aW5zdGFuY2VOdW1iZXJ9OiBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGVkIHRvIHRoZSBNZXRhQXBpIHNlcnZlcmApO1xuICAgICAgaW5zdGFuY2UucmVjb25uZWN0V2FpdFRpbWUgPSB0aGlzLl9zb2NrZXRNaW5pbXVtUmVjb25uZWN0VGltZW91dDtcbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBpZiAoIWluc3RhbmNlLnJlc29sdmVkKSB7XG4gICAgICAgIGluc3RhbmNlLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZmlyZVJlY29ubmVjdGVkKGluc3RhbmNlTnVtYmVyLCBpbnN0YW5jZS5pZCwgcmVnaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICAgIGluc3RhbmNlLnNvY2tldC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdyZWNvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfTogTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IHJlY29ubmVjdGVkYCk7XG4gICAgICBhd2FpdCB0aGlzLl9maXJlUmVjb25uZWN0ZWQoaW5zdGFuY2VOdW1iZXIsIGluc3RhbmNlLmlkLCByZWdpb24pO1xuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdjb25uZWN0X2Vycm9yJywgYXN5bmMgKGVycikgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHtyZWdpb259OiR7aW5zdGFuY2VOdW1iZXJ9OiBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGlvbiBlcnJvcmAsIGVycik7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKCFpbnN0YW5jZS5yZXNvbHZlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9yZWNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIGluc3RhbmNlLmlkLCByZWdpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdjb25uZWN0X3RpbWVvdXQnLCBhc3luYyAodGltZW91dCkgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHtyZWdpb259OiR7aW5zdGFuY2VOdW1iZXJ9OiBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGlvbiB0aW1lb3V0YCk7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKCFpbnN0YW5jZS5yZXNvbHZlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9yZWNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIGluc3RhbmNlLmlkLCByZWdpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdkaXNjb25uZWN0JywgYXN5bmMgKHJlYXNvbikgPT4ge1xuICAgICAgaW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLm9uRGlzY29ubmVjdCgpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn06IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgYCArXG4gICAgICAgIGBNZXRhQXBpIHNlcnZlciBiZWNhdXNlIG9mICR7cmVhc29ufWApO1xuICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIGF3YWl0IHRoaXMuX3JlY29ubmVjdChpbnN0YW5jZU51bWJlciwgaW5zdGFuY2UuaWQsIHJlZ2lvbik7XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Vycm9yJywgYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn06IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBlcnJvcmAsIGVycm9yKTtcbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBhd2FpdCB0aGlzLl9yZWNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIGluc3RhbmNlLmlkLCByZWdpb24pO1xuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdyZXNwb25zZScsIGRhdGEgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygoKSA9PiBgJHtkYXRhLmFjY291bnRJZH06IFJlc3BvbnNlIHJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgdGltZXN0YW1wczogZGF0YS50aW1lc3RhbXBzfSl9YCk7XG4gICAgICBsZXQgcmVxdWVzdFJlc29sdmUgPSAoaW5zdGFuY2UucmVxdWVzdFJlc29sdmVzW2RhdGEucmVxdWVzdElkXSB8fCB7cmVzb2x2ZTogKCkgPT4ge30sIHJlamVjdDogKCkgPT4ge319KTtcbiAgICAgIGRlbGV0ZSBpbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbZGF0YS5yZXF1ZXN0SWRdO1xuICAgICAgdGhpcy5fY29udmVydElzb1RpbWVUb0RhdGUoZGF0YSk7XG4gICAgICByZXF1ZXN0UmVzb2x2ZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgaWYgKGRhdGEudGltZXN0YW1wcyAmJiByZXF1ZXN0UmVzb2x2ZS50eXBlKSB7XG4gICAgICAgIGRhdGEudGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nRmluaXNoZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzKSB7XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHJlcXVlc3RSZXNvbHZlLnR5cGUgPT09ICd0cmFkZScgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5vblRyYWRlKGRhdGEuYWNjb3VudElkLCBkYXRhLnRpbWVzdGFtcHMpIDpcbiAgICAgICAgICAgICAgbGlzdGVuZXIub25SZXNwb25zZShkYXRhLmFjY291bnRJZCwgcmVxdWVzdFJlc29sdmUudHlwZSwgZGF0YS50aW1lc3RhbXBzKSlcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIG9uUmVzcG9uc2UgZXZlbnQgZm9yIGFjY291bnQgJyArXG4gICAgICAgICAgICAgIGRhdGEuYWNjb3VudElkICsgJywgcmVxdWVzdCB0eXBlICcgKyByZXF1ZXN0UmVzb2x2ZS50eXBlLCBlcnJvcikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ3Byb2Nlc3NpbmdFcnJvcicsIGRhdGEgPT4ge1xuICAgICAgbGV0IHJlcXVlc3RSZXNvbHZlID0gKGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlc1tkYXRhLnJlcXVlc3RJZF0gfHwge3Jlc29sdmU6ICgpID0+IHt9LCByZWplY3Q6ICgpID0+IHt9fSk7XG4gICAgICBkZWxldGUgaW5zdGFuY2UucmVxdWVzdFJlc29sdmVzW2RhdGEucmVxdWVzdElkXTtcbiAgICAgIHJlcXVlc3RSZXNvbHZlLnJlamVjdCh0aGlzLl9jb252ZXJ0RXJyb3IoZGF0YSkpO1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ3N5bmNocm9uaXphdGlvbicsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmluc3RhbmNlSW5kZXggJiYgZGF0YS5pbnN0YW5jZUluZGV4ICE9PSBpbnN0YW5jZU51bWJlcikge1xuICAgICAgICB0aGlzLl9sb2dnZXIudHJhY2UoKCkgPT4gYCR7ZGF0YS5hY2NvdW50SWR9OiR7ZGF0YS5pbnN0YW5jZU51bWJlcn06IHJlY2VpdmVkIHBhY2tldCB3aXRoIHdyb25nIGluc3RhbmNlIGAgK1xuICAgICAgICAgIGBpbmRleCB2aWEgYSBzb2NrZXQgd2l0aCBpbnN0YW5jZSBudW1iZXIgb2YgJHtpbnN0YW5jZU51bWJlcn0sIGRhdGE9JHtKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB0eXBlOiBkYXRhLnR5cGUsIHNlcXVlbmNlTnVtYmVyOiBkYXRhLnNlcXVlbmNlTnVtYmVyLCBzZXF1ZW5jZVRpbWVzdGFtcDogZGF0YS5zZXF1ZW5jZVRpbWVzdGFtcCxcbiAgICAgICAgICAgIHN5bmNocm9uaXphdGlvbklkOiBkYXRhLnN5bmNocm9uaXphdGlvbklkLCBhcHBsaWNhdGlvbjogZGF0YS5hcHBsaWNhdGlvbiwgaG9zdDogZGF0YS5ob3N0LFxuICAgICAgICAgICAgc3BlY2lmaWNhdGlvbnNVcGRhdGVkOiBkYXRhLnNwZWNpZmljYXRpb25zVXBkYXRlZCwgcG9zaXRpb25zVXBkYXRlZDogZGF0YS5wb3NpdGlvbnNVcGRhdGVkLFxuICAgICAgICAgICAgb3JkZXJzVXBkYXRlZDogZGF0YS5vcmRlcnNVcGRhdGVkLFxuICAgICAgICAgICAgc3BlY2lmaWNhdGlvbnM6IGRhdGEuc3BlY2lmaWNhdGlvbnMgPyAoZGF0YS5zcGVjaWZpY2F0aW9ucyB8fCBbXSkubGVuZ3RoIDogdW5kZWZpbmVkfSl9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmKCF0aGlzLl9yZWdpb25zQnlBY2NvdW50c1tkYXRhLmFjY291bnRJZF0pIHtcbiAgICAgICAgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbZGF0YS5hY2NvdW50SWRdID0ge3JlZ2lvbiwgY29ubmVjdGlvbnM6IDAsIGxhc3RVc2VkOiBEYXRlLm5vdygpfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvZ2dlci50cmFjZSgoKSA9PiBgJHtkYXRhLmFjY291bnRJZH06JHtkYXRhLmluc3RhbmNlSW5kZXh9OiBTeW5jIHBhY2tldCByZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHR5cGU6IGRhdGEudHlwZSwgc2VxdWVuY2VOdW1iZXI6IGRhdGEuc2VxdWVuY2VOdW1iZXIsIHNlcXVlbmNlVGltZXN0YW1wOiBkYXRhLnNlcXVlbmNlVGltZXN0YW1wLFxuICAgICAgICBzeW5jaHJvbml6YXRpb25JZDogZGF0YS5zeW5jaHJvbml6YXRpb25JZCwgYXBwbGljYXRpb246IGRhdGEuYXBwbGljYXRpb24sIGhvc3Q6IGRhdGEuaG9zdCwgXG4gICAgICAgIHNwZWNpZmljYXRpb25zVXBkYXRlZDogZGF0YS5zcGVjaWZpY2F0aW9uc1VwZGF0ZWQsIHBvc2l0aW9uc1VwZGF0ZWQ6IGRhdGEucG9zaXRpb25zVXBkYXRlZCxcbiAgICAgICAgb3JkZXJzVXBkYXRlZDogZGF0YS5vcmRlcnNVcGRhdGVkLCBcbiAgICAgICAgc3BlY2lmaWNhdGlvbnM6IGRhdGEuc3BlY2lmaWNhdGlvbnMgPyAoZGF0YS5zcGVjaWZpY2F0aW9ucyB8fCBbXSkubGVuZ3RoIDogdW5kZWZpbmVkfSl9LCBgICtcbiAgICAgICAgYGFjdGl2ZSBsaXN0ZW5lcnM6ICR7KHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pLmxlbmd0aH1gKTtcbiAgICAgIGxldCBhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMgPSBpbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuYWN0aXZlU3luY2hyb25pemF0aW9uSWRzOyBcbiAgICAgIGlmICghZGF0YS5zeW5jaHJvbml6YXRpb25JZCB8fCBhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMuaW5jbHVkZXMoZGF0YS5zeW5jaHJvbml6YXRpb25JZCkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhY2tldExvZ2dlcikge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3BhY2tldExvZ2dlci5sb2dQYWNrZXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWdub3JlZFBhY2tldFR5cGVzID0gWydkaXNjb25uZWN0ZWQnLCAnc3RhdHVzJywgJ2tlZXBhbGl2ZSddO1xuICAgICAgICBpZiAoIXRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuaXNTdWJzY3JpcHRpb25BY3RpdmUoZGF0YS5hY2NvdW50SWQpICYmIFxuICAgICAgICAgICFpZ25vcmVkUGFja2V0VHlwZXMuaW5jbHVkZXMoZGF0YS50eXBlKSkge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHtkYXRhLmFjY291bnRJZH06IFBhY2tldCBhcnJpdmVkIHRvIGluYWN0aXZlIGNvbm5lY3Rpb24sIGF0dGVtcHRpbmdgICtcbiAgICAgICAgICAgIGAgdW5zdWJzY3JpYmUsIHBhY2tldDogJHtkYXRhLnR5cGV9YCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3Rocm90dGxlUmVxdWVzdCgndW5zdWJzY3JpYmUnLCBkYXRhLmFjY291bnRJZCwgZGF0YS5pbnN0YW5jZUluZGV4LCBcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlVGhyb3R0bGluZ0ludGVydmFsKSkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZShkYXRhLmFjY291bnRJZCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYCR7ZGF0YS5hY2NvdW50SWR9OiR7ZGF0YS5pbnN0YW5jZUluZGV4IHx8IDB9OiBmYWlsZWQgdG8gdW5zdWJzY3JpYmVgLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb252ZXJ0SXNvVGltZVRvRGF0ZShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICdub29wJztcbiAgICAgIH1cbiAgICAgIHRoaXMucXVldWVQYWNrZXQoZGF0YSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgY29ubmVjdGlvbiB0byBNZXRhQXBpIHNlcnZlclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc29ja2V0SW5zdGFuY2VzKS5mb3JFYWNoKHJlZ2lvbiA9PiB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXSkuZm9yRWFjaChpbnN0YW5jZU51bWJlciA9PiB7XG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXS5mb3JFYWNoKGFzeW5jIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCByZXF1ZXN0UmVzb2x2ZSBvZiBPYmplY3QudmFsdWVzKGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlcykpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdFJlc29sdmUucmVqZWN0KG5ldyBFcnJvcignTWV0YUFwaSBjb25uZWN0aW9uIGNsb3NlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdID0ge307XG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXSA9IFtdO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fbGF0ZW5jeUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3BhY2tldE9yZGVyZXIuc3RvcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgYWNjb3VudCBpbmZvcm1hdGlvbiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9tb2RlbHMvbWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvbi8pXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJBY2NvdW50SW5mb3JtYXRpb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBsYXRmb3JtIHBsYXRmb3JtIGlkIChtdDQgb3IgbXQ1KVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYnJva2VyIGJyb2tlciBuYW1lXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjdXJyZW5jeSBhY2NvdW50IGJhc2UgY3VycmVuY3kgSVNPIGNvZGVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHNlcnZlciBicm9rZXIgc2VydmVyIG5hbWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJhbGFuY2UgYWNjb3VudCBiYWxhbmNlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBlcXVpdHkgYWNjb3VudCBsaXF1aWRhdGlvbiB2YWx1ZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWFyZ2luIHVzZWQgbWFyZ2luXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBmcmVlTWFyZ2luIGZyZWUgbWFyZ2luXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsZXZlcmFnZSBhY2NvdW50IGxldmVyYWdlIGNvZWZmaWNpZW50XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXJnaW5MZXZlbCBtYXJnaW4gbGV2ZWwgY2FsY3VsYXRlZCBhcyAlIG9mIGVxdWl0eS9tYXJnaW5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSB0cmFkZUFsbG93ZWQgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdHJhZGluZyBpcyBhbGxvd2VkXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludmVzdG9yTW9kZV0gZmxhZyBpbmRpY2F0aW5nIHRoYXQgaW52ZXN0b3IgcGFzc3dvcmQgd2FzIHVzZWQgKHN1cHBvcnRlZCBmb3IgZzIgb25seSlcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1hcmdpbk1vZGUgbWFyZ2luIGNhbGN1bGF0aW9uIG1vZGUsIG9uZSBvZiBBQ0NPVU5UX01BUkdJTl9NT0RFX0VYQ0hBTkdFLFxuICAgKiBBQ0NPVU5UX01BUkdJTl9NT0RFX1JFVEFJTF9ORVRUSU5HLCBBQ0NPVU5UX01BUkdJTl9NT0RFX1JFVEFJTF9IRURHSU5HXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lIEFjY291bnQgb3duZXIgbmFtZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbG9naW4gQWNjb3VudCBsb2dpblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gY3JlZGl0IEFjY291bnQgY3JlZGl0IGluIHRoZSBkZXBvc2l0IGN1cnJlbmN5XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUgY3VycmVudCBleGNoYW5nZSByYXRlIG9mIGFjY291bnQgY3VycmVuY3kgaW50byBhY2NvdW50IGJhc2UgY3VycmVuY3lcbiAgICogKFVTRCBpZiB5b3UgZGlkIG5vdCBvdmVycmlkZSBpdClcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWNjb3VudCBpbmZvcm1hdGlvbiBmb3IgYSBzcGVjaWZpZWQgTWV0YVRyYWRlciBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRBY2NvdW50SW5mb3JtYXRpb24vKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm9ybWF0aW9uKGFjY291bnRJZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRBY2NvdW50SW5mb3JtYXRpb24nfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmFjY291bnRJbmZvcm1hdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxvc3MgdGhyZXNob2xkXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFN0b3BMb3NzVGhyZXNob2xkXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aHJlc2hvbGQgcHJpY2UgdGhyZXNob2xkIHJlbGF0aXZlIHRvIHBvc2l0aW9uIG9wZW4gcHJpY2UsIGludGVycHJldGVkIGFjY29yZGluZyB0byB1bml0c1xuICAgKiBmaWVsZCB2YWx1ZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gc3RvcExvc3Mgc3RvcCBsb3NzIHZhbHVlLCBpbnRlcnByZXRlZCBhY2NvcmRpbmcgdG8gdW5pdHMgYW5kIGJhc2VQcmljZSBmaWVsZCB2YWx1ZXNcbiAgICovXG5cbiAgLyoqXG4gICAqIFRocmVzaG9sZCB0cmFpbGluZyBzdG9wIGxvc3MgY29uZmlndXJhdGlvblxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUaHJlc2hvbGRUcmFpbGluZ1N0b3BMb3NzXG4gICAqIEBwcm9wZXJ0eSB7U3RvcExvc3NUaHJlc2hvbGRbXX0gdGhyZXNob2xkcyBzdG9wIGxvc3MgdGhyZXNob2xkc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3VuaXRzXSB0aHJlc2hvbGQgc3RvcCBsb3NzIHVuaXRzLiBBQlNPTFVURV9QUklDRSBtZWFucyB0aGUgdGhhdCB0aGUgdmFsdWUgb2Ygc3RvcCBsb3NzXG4gICAqIHRocmVzaG9sZCBmaWVsZHMgY29udGFpbiBhIGZpbmFsIHRocmVzaG9sZCAmIHN0b3AgbG9zcyB2YWx1ZS4gUkVMQVRJVkUqIG1lYW5zIHRoYXQgdGhlIHRocmVzaG9sZCBmaWVsZHMgdmFsdWVcbiAgICogY29udGFpbnMgcmVsYXRpdmUgdGhyZXNob2xkICYgc3RvcCBsb3NzIHZhbHVlcywgZXhwcmVzc2VkIGVpdGhlciBpbiBwcmljZSwgcG9pbnRzLCBwaXBzLCBhY2NvdW50IGN1cnJlbmN5IG9yXG4gICAqIGJhbGFuY2UgcGVyY2VudGFnZS4gRGVmYXVsdCBpcyBBQlNPTFVURV9QUklDRS4gT25lIG9mIEFCU09MVVRFX1BSSUNFLCBSRUxBVElWRV9QUklDRSwgUkVMQVRJVkVfUE9JTlRTLFxuICAgKiBSRUxBVElWRV9QSVBTLCBSRUxBVElWRV9DVVJSRU5DWSwgUkVMQVRJVkVfQkFMQU5DRV9QRVJDRU5UQUdFXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3RvcFByaWNlQmFzZV0gZGVmaW5lZCB0aGUgYmFzZSBwcmljZSB0byBjYWxjdWxhdGUgU0wgcmVsYXRpdmUgdG8gZm9yIFBPU0lUSU9OX01PRElGWSBhbmRcbiAgICogcGVuZGluZyBvcmRlciByZXF1ZXN0cy4gRGVmYXVsdCBpcyBPUEVOX1BSSUNFLiBPbmUgb2YgQ1VSUkVOVF9QUklDRSwgT1BFTl9QUklDRVxuICAgKi9cblxuICAvKipcbiAgICogRGlzdGFuY2UgdHJhaWxpbmcgc3RvcCBsb3NzIGNvbmZpZ3VyYXRpb25cbiAgICogQHR5cGVkZWYge09iamVjdH0gRGlzdGFuY2VUcmFpbGluZ1N0b3BMb3NzXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGlzdGFuY2VdIFNMIGRpc3RhbmNlIHJlbGF0aXZlIHRvIGN1cnJlbnQgcHJpY2UsIGludGVycHJldGVkIGFjY29yZGluZyB0byB1bml0cyBmaWVsZCB2YWx1ZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3VuaXRzXSBkaXN0YW5jZSB0cmFpbGluZyBzdG9wIGxvc3MgdW5pdHMuIFJFTEFUSVZFXyogbWVhbnMgdGhhdCB0aGUgZGlzdGFuY2UgZmllbGQgdmFsdWUgXG4gICAqIGNvbnRhaW5zIHJlbGF0aXZlIHN0b3AgbG9zcyBleHByZXNzZWQgZWl0aGVyIGluIHByaWNlLCBwb2ludHMsIHBpcHMsIGFjY291bnQgY3VycmVuY3kgb3IgYmFsYW5jZSBwZXJjZW50YWdlLiBcbiAgICogRGVmYXVsdCBpcyBSRUxBVElWRV9QUklDRS4gT25lIG9mIFJFTEFUSVZFX1BSSUNFLCBSRUxBVElWRV9QT0lOVFMsIFJFTEFUSVZFX1BJUFMsIFJFTEFUSVZFX0NVUlJFTkNZLFxuICAgKiBSRUxBVElWRV9CQUxBTkNFX1BFUkNFTlRBR0VcbiAgICovXG5cbiAgLyoqXG4gICAqIERpc3RhbmNlIHRyYWlsaW5nIHN0b3AgbG9zcyBjb25maWd1cmF0aW9uXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYWlsaW5nU3RvcExvc3NcbiAgICogQHByb3BlcnR5IHtEaXN0YW5jZVRyYWlsaW5nU3RvcExvc3N9IFtkaXN0YW5jZV0gZGlzdGFuY2UgdHJhaWxpbmcgc3RvcCBsb3NzIGNvbmZpZ3VyYXRpb24uIElmIGJvdGggZGlzdGFuY2UgYW5kXG4gICAqIHRocmVzaG9sZCBUU0wgYXJlIHNldCwgdGhlbiB0aGUgcmVzdWx0aW5nIFNMIHdpbGwgYmUgdGhlIG9uZSB3aGljaCBpcyBjbG9zZXN0IHRvIHRoZSBjdXJyZW50IHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7VGhyZXNob2xkVHJhaWxpbmdTdG9wTG9zc30gW3RocmVzaG9sZF0gZGlzdGFuY2UgdHJhaWxpbmcgc3RvcCBsb3NzIGNvbmZpZ3VyYXRpb24uIElmIGJvdGggZGlzdGFuY2UgYW5kXG4gICAqIHRocmVzaG9sZCBUU0wgYXJlIHNldCwgdGhlbiB0aGUgcmVzdWx0aW5nIFNMIHdpbGwgYmUgdGhlIG9uZSB3aGljaCBpcyBjbG9zZXN0IHRvIHRoZSBjdXJyZW50IHByaWNlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIHBvc2l0aW9uXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJQb3NpdGlvblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gaWQgcG9zaXRpb24gaWQgKHRpY2tldCBudW1iZXIpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIHBvc2l0aW9uIHR5cGUgKG9uZSBvZiBQT1NJVElPTl9UWVBFX0JVWSwgUE9TSVRJT05fVFlQRV9TRUxMKVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3ltYm9sIHBvc2l0aW9uIHN5bWJvbFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWFnaWMgcG9zaXRpb24gbWFnaWMgbnVtYmVyLCBpZGVudGlmaWVzIHRoZSBFQSB3aGljaCBvcGVuZWQgdGhlIHBvc2l0aW9uXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSB0aW1lIHBvc2l0aW9uIHdhcyBvcGVuZWQgYXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlclRpbWUgdGltZSBwb3NpdGlvbiB3YXMgb3BlbmVkIGF0LCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge0RhdGV9IHVwZGF0ZVRpbWUgbGFzdCBwb3NpdGlvbiBtb2RpZmljYXRpb24gdGltZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gb3BlblByaWNlIHBvc2l0aW9uIG9wZW4gcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGN1cnJlbnRQcmljZSBjdXJyZW50IHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50VGlja1ZhbHVlIGN1cnJlbnQgdGljayB2YWx1ZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N0b3BMb3NzXSBvcHRpb25hbCBwb3NpdGlvbiBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0YWtlUHJvZml0XSBvcHRpb25hbCBwb3NpdGlvbiB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcHJvcGVydHkge1RyYWlsaW5nU3RvcExvc3N9IFt0cmFpbGluZ1N0b3BMb3NzXSBkaXN0YW5jZSB0cmFpbGluZyBzdG9wIGxvc3MgY29uZmlndXJhdGlvblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gdm9sdW1lIHBvc2l0aW9uIHZvbHVtZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gcHJvZml0IHBvc2l0aW9uIGN1bXVsYXRpdmUgcHJvZml0LCBpbmNsdWRpbmcgdW5yZWFsaXplZCBwcm9maXQgcmVzdWx0aW5nIGZyb20gY3VycmVudGx5IG9wZW5cbiAgICogcG9zaXRpb24gcGFydCAoZXhjZXB0IHN3YXAgYW5kIGNvbW1pc3Npb25zKSBhbmQgcmVhbGl6ZWQgcHJvZml0IHJlc3VsdGluZyBmcm9tIHBhcnRpYWxseSBjbG9zZWQgcG9zaXRpb24gcGFydFxuICAgKiBhbmQgaW5jbHVkaW5nIHN3YXAgYW5kIGNvbW1pc3Npb25zXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZWFsaXplZFByb2ZpdCBwcm9maXQgb2YgdGhlIGFscmVhZHkgY2xvc2VkIHBhcnQsIGluY2x1ZGluZyBjb21taXNzaW9ucyBhbmQgc3dhcCAocmVhbGl6ZWQgYW5kXG4gICAqIHVucmVhbGl6ZWQpXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB1bnJlYWxpemVkUHJvZml0IHByb2ZpdCBvZiB0aGUgcGFydCBvZiB0aGUgcG9zaXRpb24gd2hpY2ggaXMgbm90IHlldCBjbG9zZWQsIGV4Y2x1ZGluZyBzd2FwIGFuZFxuICAgKiBjb21taXNzaW9uc1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gc3dhcCBwb3NpdGlvbiBjdW11bGF0aXZlIHN3YXAsIGluY2x1ZGluZyBib3RoIHN3YXAgZnJvbSBjdXJyZW50bHkgb3BlbiBwb3NpdGlvbiBwYXJ0ICh1bnJlYWxpemVkXG4gICAqIHN3YXApIGFuZCBzd2FwIGZyb20gcGFydGlhbGx5IGNsb3NlZCBwb3NpdGlvbiBwYXJ0IChyZWFsaXplZCBzd2FwKVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gcmVhbGl6ZWRTd2FwIHN3YXAgZnJvbSBwYXJ0aWFsbHkgY2xvc2VkIHBvc2l0aW9uIHBhcnRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHVucmVhbGl6ZWRTd2FwIHN3YXAgcmVzdWx0aW5nIGZyb20gY3VycmVudGx5IG9wZW4gcG9zaXRpb24gcGFydFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gY29tbWlzc2lvbiB0b3RhbCBwb3NpdGlvbiBjb21taXNzaW9ucywgcmVzdWx0aW5nIGJvdGggZnJvbSBjdXJyZW50bHkgb3BlbiBhbmQgY2xvc2VkIHBvc2l0aW9uXG4gICAqIHBhcnRzXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZWFsaXplZENvbW1pc3Npb24gcG9zaXRpb24gcmVhbGl6ZWQgY29tbWlzc2lvbiwgcmVzdWx0aW5nIGZyb20gcGFydGlhbGx5IGNsb3NlZCBwb3NpdGlvbiBwYXJ0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB1bnJlYWxpemVkQ29tbWlzc2lvbiBwb3NpdGlvbiB1bnJlYWxpemVkIGNvbW1pc3Npb24sIHJlc3VsdGluZyBmcm9tIGN1cnJlbnRseSBvcGVuIHBvc2l0aW9uIHBhcnRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb21tZW50XSBvcHRpb25hbCBwb3NpdGlvbiBjb21tZW50LiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlIGNvbW1lbnQgYW5kIHRoZSBjbGllbnRJZFxuICAgKiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NsaWVudElkXSBvcHRpb25hbCBjbGllbnQtYXNzaWduZWQgaWQuIFRoZSBpZCB2YWx1ZSBjYW4gYmUgYXNzaWduZWQgd2hlbiBzdWJtaXR0aW5nIGEgdHJhZGUgYW5kXG4gICAqIHdpbGwgYmUgcHJlc2VudCBvbiBwb3NpdGlvbiwgaGlzdG9yeSBvcmRlcnMgYW5kIGhpc3RvcnkgZGVhbHMgcmVsYXRlZCB0byB0aGUgdHJhZGUuIFlvdSBjYW4gdXNlIHRoaXMgZmllbGQgdG8gYmluZFxuICAgKiB5b3VyIHRyYWRlcyB0byBvYmplY3RzIGluIHlvdXIgYXBwbGljYXRpb24gYW5kIHRoZW4gdHJhY2sgdHJhZGUgcHJvZ3Jlc3MuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGVcbiAgICogY29tbWVudCBhbmQgdGhlIGNsaWVudElkIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZWFzb24gcG9zaXRpb24gb3BlbmluZyByZWFzb24uIE9uZSBvZiBQT1NJVElPTl9SRUFTT05fQ0xJRU5ULCBQT1NJVElPTl9SRUFTT05fRVhQRVJULFxuICAgKiBQT1NJVElPTl9SRUFTT05fTU9CSUxFLCBQT1NJVElPTl9SRUFTT05fV0VCLCBQT1NJVElPTl9SRUFTT05fVU5LTk9XTi4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvcG9zaXRpb25wcm9wZXJ0aWVzI2VudW1fcG9zaXRpb25fcmVhc29uJyxcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFthY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGVdIGN1cnJlbnQgZXhjaGFuZ2UgcmF0ZSBvZiBhY2NvdW50IGN1cnJlbmN5IGludG8gYWNjb3VudCBiYXNlXG4gICAqIGN1cnJlbmN5IChVU0QgaWYgeW91IGRpZCBub3Qgb3ZlcnJpZGUgaXQpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbYnJva2VyQ29tbWVudF0gY3VycmVudCBjb21tZW50IHZhbHVlIG9uIGJyb2tlciBzaWRlIChwb3NzaWJseSBvdmVycmlkZW4gYnkgdGhlIGJyb2tlcilcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgcG9zaXRpb25zIGZvciBhIHNwZWNpZmllZCBNZXRhVHJhZGVyIGFjY291bnQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZFBvc2l0aW9ucy8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyUG9zaXRpb24+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGFycmF5IG9mIG9wZW4gcG9zaXRpb25zXG4gICAqL1xuICBhc3luYyBnZXRQb3NpdGlvbnMoYWNjb3VudElkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFBvc2l0aW9ucyd9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UucG9zaXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3BlY2lmaWMgcG9zaXRpb24gZm9yIGEgTWV0YVRyYWRlciBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRQb3NpdGlvbi8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1ldGF0cmFkZXJQb3NpdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggTWV0YVRyYWRlciBwb3NpdGlvbiBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0UG9zaXRpb24oYWNjb3VudElkLCBwb3NpdGlvbklkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFBvc2l0aW9uJywgcG9zaXRpb25JZH0pO1xuICAgIHJldHVybiByZXNwb25zZS5wb3NpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIG9yZGVyXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJPcmRlclxuICAgKiBAcHJvcGVydHkge051bWJlcn0gaWQgb3JkZXIgaWQgKHRpY2tldCBudW1iZXIpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIG9yZGVyIHR5cGUgKG9uZSBvZiBPUkRFUl9UWVBFX1NFTEwsIE9SREVSX1RZUEVfQlVZLCBPUkRFUl9UWVBFX0JVWV9MSU1JVCxcbiAgICogT1JERVJfVFlQRV9TRUxMX0xJTUlULCBPUkRFUl9UWVBFX0JVWV9TVE9QLCBPUkRFUl9UWVBFX1NFTExfU1RPUCkuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL29yZGVycHJvcGVydGllcyNlbnVtX29yZGVyX3R5cGVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN0YXRlIG9yZGVyIHN0YXRlIG9uZSBvZiAoT1JERVJfU1RBVEVfU1RBUlRFRCwgT1JERVJfU1RBVEVfUExBQ0VELCBPUkRFUl9TVEFURV9DQU5DRUxFRCxcbiAgICogT1JERVJfU1RBVEVfUEFSVElBTCwgT1JERVJfU1RBVEVfRklMTEVELCBPUkRFUl9TVEFURV9SRUpFQ1RFRCwgT1JERVJfU1RBVEVfRVhQSVJFRCwgT1JERVJfU1RBVEVfUkVRVUVTVF9BREQsXG4gICAqIE9SREVSX1NUQVRFX1JFUVVFU1RfTU9ESUZZLCBPUkRFUl9TVEFURV9SRVFVRVNUX0NBTkNFTCkuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL29yZGVycHJvcGVydGllcyNlbnVtX29yZGVyX3N0YXRlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYWdpYyBvcmRlciBtYWdpYyBudW1iZXIsIGlkZW50aWZpZXMgdGhlIEVBIHdoaWNoIGNyZWF0ZWQgdGhlIG9yZGVyXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSB0aW1lIG9yZGVyIHdhcyBjcmVhdGVkIGF0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBicm9rZXJUaW1lIHRpbWUgdGltZSBvcmRlciB3YXMgY3JlYXRlZCBhdCwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtEYXRlfSBbZG9uZVRpbWVdIHRpbWUgb3JkZXIgd2FzIGV4ZWN1dGVkIG9yIGNhbmNlbGVkIGF0LiBXaWxsIGJlIHNwZWNpZmllZCBmb3JcbiAgICogY29tcGxldGVkIG9yZGVycyBvbmx5XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZG9uZUJyb2tlclRpbWVdIHRpbWUgb3JkZXIgd2FzIGV4ZWN1dGVkIG9yIGNhbmNlbGVkIGF0LCBpbiBicm9rZXIgdGltZXpvbmUsXG4gICAqIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdC4gV2lsbCBiZSBzcGVjaWZpZWQgZm9yIGNvbXBsZXRlZCBvcmRlcnMgb25seVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3ltYm9sIG9yZGVyIHN5bWJvbFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gb3BlblByaWNlIG9yZGVyIG9wZW4gcHJpY2UgKG1hcmtldCBwcmljZSBmb3IgbWFya2V0IG9yZGVycywgbGltaXQgcHJpY2UgZm9yIGxpbWl0IG9yZGVycyBvciBzdG9wXG4gICAqIHByaWNlIGZvciBzdG9wIG9yZGVycylcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjdXJyZW50UHJpY2VdIGN1cnJlbnQgcHJpY2UsIGZpbGxlZCBmb3IgcGVuZGluZyBvcmRlcnMgb25seS4gTm90IGZpbGxlZCBmb3IgaGlzdG9yeSBvcmRlcnMuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3RvcExvc3NdIG9yZGVyIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3Rha2VQcm9maXRdIG9yZGVyIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7VHJhaWxpbmdTdG9wTG9zc30gW3RyYWlsaW5nU3RvcExvc3NdIGRpc3RhbmNlIHRyYWlsaW5nIHN0b3AgbG9zcyBjb25maWd1cmF0aW9uXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB2b2x1bWUgb3JkZXIgcmVxdWVzdGVkIHF1YW50aXR5XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50Vm9sdW1lIG9yZGVyIHJlbWFpbmluZyBxdWFudGl0eSwgaS5lLiByZXF1ZXN0ZWQgcXVhbnRpdHkgLSBmaWxsZWQgcXVhbnRpdHlcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBvc2l0aW9uSWQgb3JkZXIgcG9zaXRpb24gaWQuIFByZXNlbnQgb25seSBpZiB0aGUgb3JkZXIgaGFzIGEgcG9zaXRpb24gYXR0YWNoZWQgdG8gaXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb21tZW50XSBvcmRlciBjb21tZW50LiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlIGNvbW1lbnQgYW5kIHRoZSBjbGllbnRJZFxuICAgKiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2Jyb2tlckNvbW1lbnRdIGN1cnJlbnQgY29tbWVudCB2YWx1ZSBvbiBicm9rZXIgc2lkZSAocG9zc2libHkgb3ZlcnJpZGVuIGJ5IHRoZSBicm9rZXIpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY2xpZW50SWRdIGNsaWVudC1hc3NpZ25lZCBpZC4gVGhlIGlkIHZhbHVlIGNhbiBiZSBhc3NpZ25lZCB3aGVuIHN1Ym1pdHRpbmcgYSB0cmFkZSBhbmRcbiAgICogd2lsbCBiZSBwcmVzZW50IG9uIHBvc2l0aW9uLCBoaXN0b3J5IG9yZGVycyBhbmQgaGlzdG9yeSBkZWFscyByZWxhdGVkIHRvIHRoZSB0cmFkZS4gWW91IGNhbiB1c2UgdGhpcyBmaWVsZCB0byBiaW5kXG4gICAqIHlvdXIgdHJhZGVzIHRvIG9iamVjdHMgaW4geW91ciBhcHBsaWNhdGlvbiBhbmQgdGhlbiB0cmFjayB0cmFkZSBwcm9ncmVzcy4gVGhlIHN1bSBvZiB0aGUgbGluZSBsZW5ndGhzIG9mIHRoZVxuICAgKiBjb21tZW50IGFuZCB0aGUgY2xpZW50SWQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjYuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvY2xpZW50SWRVc2FnZS9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBsYXRmb3JtIHBsYXRmb3JtIGlkIChtdDQgb3IgbXQ1KVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcmVhc29uIG9yZGVyIG9wZW5pbmcgcmVhc29uLiBPbmUgb2YgT1JERVJfUkVBU09OX0NMSUVOVCwgT1JERVJfUkVBU09OX01PQklMRSwgT1JERVJfUkVBU09OX1dFQixcbiAgICogT1JERVJfUkVBU09OX0VYUEVSVCwgT1JERVJfUkVBU09OX1NMLCBPUkRFUl9SRUFTT05fVFAsIE9SREVSX1JFQVNPTl9TTywgT1JERVJfUkVBU09OX1VOS05PV04uIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL29yZGVycHJvcGVydGllcyNlbnVtX29yZGVyX3JlYXNvbi5cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGZpbGxpbmdNb2RlIG9yZGVyIGZpbGxpbmcgbW9kZS4gT25lIG9mIE9SREVSX0ZJTExJTkdfRk9LLCBPUkRFUl9GSUxMSU5HX0lPQyxcbiAgICogT1JERVJfRklMTElOR19SRVRVUk4uIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL29yZGVycHJvcGVydGllcyNlbnVtX29yZGVyX3R5cGVfZmlsbGluZy5cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGV4cGlyYXRpb25UeXBlIG9yZGVyIGV4cGlyYXRpb24gdHlwZS4gT25lIG9mIE9SREVSX1RJTUVfR1RDLCBPUkRFUl9USU1FX0RBWSxcbiAgICogT1JERVJfVElNRV9TUEVDSUZJRUQsIE9SREVSX1RJTUVfU1BFQ0lGSUVEX0RBWS4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvb3JkZXJwcm9wZXJ0aWVzI2VudW1fb3JkZXJfdHlwZV90aW1lXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gZXhwaXJhdGlvblRpbWUgb3B0aW9uYWwgb3JkZXIgZXhwaXJhdGlvbiB0aW1lXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlXSBjdXJyZW50IGV4Y2hhbmdlIHJhdGUgb2YgYWNjb3VudCBjdXJyZW5jeSBpbnRvIGFjY291bnQgYmFzZVxuICAgKiBjdXJyZW5jeSAoVVNEIGlmIHlvdSBkaWQgbm90IG92ZXJyaWRlIGl0KVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2Nsb3NlQnlQb3NpdGlvbklkXSBpZGVudGlmaWVyIG9mIGFuIG9wcG9zaXRlIHBvc2l0aW9uIHVzZWQgZm9yIGNsb3NpbmcgYnkgb3JkZXJcbiAgICogT1JERVJfVFlQRV9DTE9TRV9CWVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N0b3BMaW1pdFByaWNlXSB0aGUgTGltaXQgb3JkZXIgcHJpY2UgZm9yIHRoZSBTdG9wTGltaXQgb3JkZXJcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgb3BlbiBvcmRlcnMgZm9yIGEgc3BlY2lmaWVkIE1ldGFUcmFkZXIgYWNjb3VudCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JlYWRUcmFkaW5nVGVybWluYWxTdGF0ZS9yZWFkT3JkZXJzLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8TWV0YXRyYWRlck9yZGVyPj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggb3BlbiBNZXRhVHJhZGVyIG9yZGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0T3JkZXJzKGFjY291bnRJZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRPcmRlcnMnfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLm9yZGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHNwZWNpZmljIG9wZW4gb3JkZXIgZm9yIGEgTWV0YVRyYWRlciBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRPcmRlci8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JkZXJJZCBvcmRlciBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyT3JkZXI+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIG1ldGF0cmFkZXIgb3JkZXIgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldE9yZGVyKGFjY291bnRJZCwgb3JkZXJJZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRPcmRlcicsIG9yZGVySWR9KTtcbiAgICByZXR1cm4gcmVzcG9uc2Uub3JkZXI7XG4gIH1cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBoaXN0b3J5IG9yZGVycyBzZWFyY2ggcXVlcnkgcmVzcG9uc2VcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlckhpc3RvcnlPcmRlcnNcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyT3JkZXI+fSBoaXN0b3J5T3JkZXJzIGFycmF5IG9mIGhpc3Rvcnkgb3JkZXJzIHJldHVybmVkXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc3luY2hyb25pemluZyBmbGFnIGluZGljYXRpbmcgdGhhdCBoaXN0b3J5IG9yZGVyIGluaXRpYWwgc3luY2hyb25pemF0aW9uIGlzIHN0aWxsIGluIHByb2dyZXNzXG4gICAqIGFuZCB0aHVzIHNlYXJjaCByZXN1bHRzIG1heSBiZSBpbmNvbXBsZXRlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaXN0b3J5IG9mIGNvbXBsZXRlZCBvcmRlcnMgZm9yIGEgc3BlY2lmaWMgdGlja2V0IG51bWJlciAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZEhpc3RvcnlPcmRlcnNCeVRpY2tldC8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGlja2V0IHRpY2tldCBudW1iZXIgKG9yZGVyIGlkKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVySGlzdG9yeU9yZGVycz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgaGlzdG9yeSBvcmRlcnMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldEhpc3RvcnlPcmRlcnNCeVRpY2tldChhY2NvdW50SWQsIHRpY2tldCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRIaXN0b3J5T3JkZXJzQnlUaWNrZXQnLCB0aWNrZXR9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaGlzdG9yeU9yZGVyczogcmVzcG9uc2UuaGlzdG9yeU9yZGVycyxcbiAgICAgIHN5bmNocm9uaXppbmc6IHJlc3BvbnNlLnN5bmNocm9uaXppbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpc3Rvcnkgb2YgY29tcGxldGVkIG9yZGVycyBmb3IgYSBzcGVjaWZpYyBwb3NpdGlvbiBpZCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9uLylcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWRcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckhpc3RvcnlPcmRlcnM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGhpc3Rvcnkgb3JkZXJzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbihhY2NvdW50SWQsIHBvc2l0aW9uSWQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24nLFxuICAgICAgcG9zaXRpb25JZH0pO1xuICAgIHJldHVybiB7XG4gICAgICBoaXN0b3J5T3JkZXJzOiByZXNwb25zZS5oaXN0b3J5T3JkZXJzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHRpbWUgcmFuZ2UgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZUhpc3RvcmljYWxEYXRhL3JlYWRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UvKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge0RhdGV9IHN0YXJ0VGltZSBzdGFydCBvZiB0aW1lIHJhbmdlLCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtEYXRlfSBlbmRUaW1lIGVuZCBvZiB0aW1lIHJhbmdlLCBleGNsdXNpdmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBwYWdpbmF0aW9uIG9mZnNldCwgZGVmYXVsdCBpcyAwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCBwYWdpbmF0aW9uIGxpbWl0LCBkZWZhdWx0IGlzIDEwMDBcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckhpc3RvcnlPcmRlcnM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGhpc3Rvcnkgb3JkZXJzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UoYWNjb3VudElkLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9mZnNldCA9IDAsIGxpbWl0ID0gMTAwMCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UnLFxuICAgICAgc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQsIGxpbWl0fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpc3RvcnlPcmRlcnM6IHJlc3BvbnNlLmhpc3RvcnlPcmRlcnMsXG4gICAgICBzeW5jaHJvbml6aW5nOiByZXNwb25zZS5zeW5jaHJvbml6aW5nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIGhpc3RvcnkgZGVhbHMgc2VhcmNoIHF1ZXJ5IHJlc3BvbnNlXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJEZWFsc1xuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJEZWFsPn0gZGVhbHMgYXJyYXkgb2YgaGlzdG9yeSBkZWFscyByZXR1cm5lZFxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHN5bmNocm9uaXppbmcgZmxhZyBpbmRpY2F0aW5nIHRoYXQgZGVhbCBpbml0aWFsIHN5bmNocm9uaXphdGlvbiBpcyBzdGlsbCBpbiBwcm9ncmVzc1xuICAgKiBhbmQgdGh1cyBzZWFyY2ggcmVzdWx0cyBtYXkgYmUgaW5jb21wbGV0ZVxuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBkZWFsXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJEZWFsXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBpZCBkZWFsIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSBkZWFsIHR5cGUgKG9uZSBvZiBERUFMX1RZUEVfQlVZLCBERUFMX1RZUEVfU0VMTCwgREVBTF9UWVBFX0JBTEFOQ0UsIERFQUxfVFlQRV9DUkVESVQsXG4gICAqIERFQUxfVFlQRV9DSEFSR0UsIERFQUxfVFlQRV9DT1JSRUNUSU9OLCBERUFMX1RZUEVfQk9OVVMsIERFQUxfVFlQRV9DT01NSVNTSU9OLCBERUFMX1RZUEVfQ09NTUlTU0lPTl9EQUlMWSxcbiAgICogREVBTF9UWVBFX0NPTU1JU1NJT05fTU9OVEhMWSwgREVBTF9UWVBFX0NPTU1JU1NJT05fQUdFTlRfREFJTFksIERFQUxfVFlQRV9DT01NSVNTSU9OX0FHRU5UX01PTlRITFksXG4gICAqIERFQUxfVFlQRV9JTlRFUkVTVCwgREVBTF9UWVBFX0JVWV9DQU5DRUxFRCwgREVBTF9UWVBFX1NFTExfQ0FOQ0VMRUQsIERFQUxfRElWSURFTkQsIERFQUxfRElWSURFTkRfRlJBTktFRCxcbiAgICogREVBTF9UQVgpLiBTZWUgaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9kZWFscHJvcGVydGllcyNlbnVtX2RlYWxfdHlwZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gZW50cnlUeXBlIGRlYWwgZW50cnkgdHlwZSAob25lIG9mIERFQUxfRU5UUllfSU4sIERFQUxfRU5UUllfT1VULCBERUFMX0VOVFJZX0lOT1VULFxuICAgKiBERUFMX0VOVFJZX09VVF9CWSkuIFNlZSBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL2RlYWxwcm9wZXJ0aWVzI2VudW1fZGVhbF9lbnRyeVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N5bWJvbF0gc3ltYm9sIGRlYWwgcmVsYXRlcyB0b1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gW21hZ2ljXSBkZWFsIG1hZ2ljIG51bWJlciwgaWRlbnRpZmllcyB0aGUgRUEgd2hpY2ggaW5pdGlhdGVkIHRoZSBkZWFsXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSB0aW1lIHRoZSBkZWFsIHdhcyBjb25kdWN0ZWQgYXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlclRpbWUgdGltZSB0aW1lIHRoZSBkZWFsIHdhcyBjb25kdWN0ZWQgYXQsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdm9sdW1lXSBkZWFsIHZvbHVtZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3ByaWNlXSB0aGUgcHJpY2UgdGhlIGRlYWwgd2FzIGNvbmR1Y3RlZCBhdFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2NvbW1pc3Npb25dIGRlYWwgY29tbWlzc2lvblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N3YXBdIGRlYWwgc3dhcFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gcHJvZml0IGRlYWwgcHJvZml0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcG9zaXRpb25JZF0gaWQgb2YgcG9zaXRpb24gdGhlIGRlYWwgcmVsYXRlcyB0b1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW29yZGVySWRdIGlkIG9mIG9yZGVyIHRoZSBkZWFsIHJlbGF0ZXMgdG9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb21tZW50XSBkZWFsIGNvbW1lbnQuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGUgY29tbWVudCBhbmQgdGhlIGNsaWVudElkXG4gICAqIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbYnJva2VyQ29tbWVudF0gY3VycmVudCBjb21tZW50IHZhbHVlIG9uIGJyb2tlciBzaWRlIChwb3NzaWJseSBvdmVycmlkZW4gYnkgdGhlIGJyb2tlcilcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjbGllbnRJZF0gY2xpZW50LWFzc2lnbmVkIGlkLiBUaGUgaWQgdmFsdWUgY2FuIGJlIGFzc2lnbmVkIHdoZW4gc3VibWl0dGluZyBhIHRyYWRlIGFuZFxuICAgKiB3aWxsIGJlIHByZXNlbnQgb24gcG9zaXRpb24sIGhpc3Rvcnkgb3JkZXJzIGFuZCBoaXN0b3J5IGRlYWxzIHJlbGF0ZWQgdG8gdGhlIHRyYWRlLiBZb3UgY2FuIHVzZSB0aGlzIGZpZWxkIHRvIGJpbmRcbiAgICogeW91ciB0cmFkZXMgdG8gb2JqZWN0cyBpbiB5b3VyIGFwcGxpY2F0aW9uIGFuZCB0aGVuIHRyYWNrIHRyYWRlIHByb2dyZXNzLiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlXG4gICAqIGNvbW1lbnQgYW5kIHRoZSBjbGllbnRJZCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcGxhdGZvcm0gcGxhdGZvcm0gaWQgKG10NCBvciBtdDUpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcmVhc29uXSBvcHRpb25hbCBkZWFsIGV4ZWN1dGlvbiByZWFzb24uIE9uZSBvZiBERUFMX1JFQVNPTl9DTElFTlQsIERFQUxfUkVBU09OX01PQklMRSxcbiAgICogREVBTF9SRUFTT05fV0VCLCBERUFMX1JFQVNPTl9FWFBFUlQsIERFQUxfUkVBU09OX1NMLCBERUFMX1JFQVNPTl9UUCwgREVBTF9SRUFTT05fU08sIERFQUxfUkVBU09OX1JPTExPVkVSLFxuICAgKiBERUFMX1JFQVNPTl9WTUFSR0lOLCBERUFMX1JFQVNPTl9TUExJVCwgREVBTF9SRUFTT05fVU5LTk9XTi4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvZGVhbHByb3BlcnRpZXMjZW51bV9kZWFsX3JlYXNvbi5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFthY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGVdIGN1cnJlbnQgZXhjaGFuZ2UgcmF0ZSBvZiBhY2NvdW50IGN1cnJlbmN5IGludG8gYWNjb3VudCBiYXNlXG4gICAqIGN1cnJlbmN5IChVU0QgaWYgeW91IGRpZCBub3Qgb3ZlcnJpZGUgaXQpXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3RvcExvc3NdIGRlYWwgc3RvcCBsb3NzLiBGb3IgTVQ1IG9wZW5pbmcgZGVhbCB0aGlzIGlzIHRoZSBTTCBvZiB0aGUgb3JkZXIgb3BlbmluZyB0aGUgXG4gICAqIHBvc2l0aW9uLiBGb3IgTVQ0IGRlYWxzIG9yIE1UNSBjbG9zaW5nIGRlYWwgdGhpcyBpcyB0aGUgbGFzdCBrbm93biBwb3NpdGlvbiBTTC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YWtlUHJvZml0XSBkZWFsIHRha2UgcHJvZml0LiBGb3IgTVQ1IG9wZW5pbmcgZGVhbCB0aGlzIGlzIHRoZSBUUCBvZiB0aGUgb3JkZXIgb3BlbmluZyB0aGUgXG4gICAqIHBvc2l0aW9uLiBGb3IgTVQ0IGRlYWxzIG9yIE1UNSBjbG9zaW5nIGRlYWwgdGhpcyBpcyB0aGUgbGFzdCBrbm93biBwb3NpdGlvbiBUUC5cbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yeSBkZWFscyB3aXRoIGEgc3BlY2lmaWMgdGlja2V0IG51bWJlciAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZERlYWxzQnlUaWNrZXQvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRpY2tldCB0aWNrZXQgbnVtYmVyIChkZWFsIGlkIGZvciBNVDUgb3Igb3JkZXIgaWQgZm9yIE1UNClcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckRlYWxzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBkZWFscyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0RGVhbHNCeVRpY2tldChhY2NvdW50SWQsIHRpY2tldCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXREZWFsc0J5VGlja2V0JywgdGlja2V0fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWxzOiByZXNwb25zZS5kZWFscyxcbiAgICAgIHN5bmNocm9uaXppbmc6IHJlc3BvbnNlLnN5bmNocm9uaXppbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yeSBkZWFscyBmb3IgYSBzcGVjaWZpYyBwb3NpdGlvbiBpZCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZERlYWxzQnlQb3NpdGlvbi8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyRGVhbHM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGRlYWxzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXREZWFsc0J5UG9zaXRpb24oYWNjb3VudElkLCBwb3NpdGlvbklkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldERlYWxzQnlQb3NpdGlvbicsIHBvc2l0aW9uSWR9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVhbHM6IHJlc3BvbnNlLmRlYWxzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIHdpdGggZm9yIGEgc3BlY2lmaWMgdGltZSByYW5nZSAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZERlYWxzQnlUaW1lUmFuZ2UvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydFRpbWUgc3RhcnQgb2YgdGltZSByYW5nZSwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7RGF0ZX0gZW5kVGltZSBlbmQgb2YgdGltZSByYW5nZSwgZXhjbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgcGFnaW5hdGlvbiBvZmZzZXQsIGRlZmF1bHQgaXMgMFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgcGFnaW5hdGlvbiBsaW1pdCwgZGVmYXVsdCBpcyAxMDAwXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldERlYWxzQnlUaW1lUmFuZ2UoYWNjb3VudElkLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9mZnNldCA9IDAsIGxpbWl0ID0gMTAwMCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXREZWFsc0J5VGltZVJhbmdlJywgc3RhcnRUaW1lLFxuICAgICAgZW5kVGltZSwgb2Zmc2V0LCBsaW1pdH0pO1xuICAgIHJldHVybiB7XG4gICAgICBkZWFsczogcmVzcG9uc2UuZGVhbHMsXG4gICAgICBzeW5jaHJvbml6aW5nOiByZXNwb25zZS5zeW5jaHJvbml6aW5nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIG9yZGVyIGFuZCB0cmFuc2FjdGlvbiBoaXN0b3J5IG9mIGEgc3BlY2lmaWVkIGFwcGxpY2F0aW9uIGFuZCByZW1vdmVzIHRoZSBhcHBsaWNhdGlvbiAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JlbW92ZUFwcGxpY2F0aW9uLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZW1vdmUgaGlzdG9yeSBhbmQgYXBwbGljYXRpb24gZm9yXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGhpc3RvcnkgaXMgY2xlYXJlZFxuICAgKi9cbiAgcmVtb3ZlQXBwbGljYXRpb24oYWNjb3VudElkKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAncmVtb3ZlQXBwbGljYXRpb24nfSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0YVRyYWRlciB0cmFkZSByZXNwb25zZVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyVHJhZGVSZXNwb25zZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbnVtZXJpY0NvZGUgbnVtZXJpYyByZXNwb25zZSBjb2RlLCBzZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZXJyb3Jzd2FybmluZ3MvZW51bV90cmFkZV9yZXR1cm5fY29kZXMgYW5kXG4gICAqIGh0dHBzOi8vYm9vay5tcWw0LmNvbS9hcHBlbmRpeC9lcnJvcnMuIFJlc3BvbnNlIGNvZGVzIHdoaWNoIGluZGljYXRlIHN1Y2Nlc3MgYXJlIDAsIDEwMDA4LTEwMDEwLCAxMDAyNS4gVGhlIHJlc3RcbiAgICogY29kZXMgYXJlIGVycm9yc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3RyaW5nQ29kZSBzdHJpbmcgcmVzcG9uc2UgY29kZSwgc2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vycm9yc3dhcm5pbmdzL2VudW1fdHJhZGVfcmV0dXJuX2NvZGVzIGFuZFxuICAgKiBodHRwczovL2Jvb2subXFsNC5jb20vYXBwZW5kaXgvZXJyb3JzLiBSZXNwb25zZSBjb2RlcyB3aGljaCBpbmRpY2F0ZSBzdWNjZXNzIGFyZSBFUlJfTk9fRVJST1IsXG4gICAqIFRSQURFX1JFVENPREVfUExBQ0VELCBUUkFERV9SRVRDT0RFX0RPTkUsIFRSQURFX1JFVENPREVfRE9ORV9QQVJUSUFMLCBUUkFERV9SRVRDT0RFX05PX0NIQU5HRVMuIFRoZSByZXN0IGNvZGVzIGFyZVxuICAgKiBlcnJvcnMuXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXNzYWdlIGh1bWFuLXJlYWRhYmxlIHJlc3BvbnNlIG1lc3NhZ2VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG9yZGVySWQgb3JkZXIgaWQgd2hpY2ggd2FzIGNyZWF0ZWQvbW9kaWZpZWQgZHVyaW5nIHRoZSB0cmFkZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZCB3aGljaCB3YXMgbW9kaWZpZWQgZHVyaW5nIHRoZSB0cmFkZVxuICAgKi9cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHRyYWRlIG9uIGEgY29ubmVjdGVkIE1ldGFUcmFkZXIgYWNjb3VudCAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byBleGVjdXRlIHRyYWRlIGZvclxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJUcmFkZX0gdHJhZGUgdHJhZGUgdG8gZXhlY3V0ZSAoc2VlIGRvY3MgZm9yIHBvc3NpYmxlIHRyYWRlIHR5cGVzKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FwcGxpY2F0aW9uXSBhcHBsaWNhdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtyZWxpYWJpbGl0eV0gYWNjb3VudCByZWxpYWJpbGl0eVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyVHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGFzeW5jIHRyYWRlKGFjY291bnRJZCwgdHJhZGUsIGFwcGxpY2F0aW9uLCByZWxpYWJpbGl0eSkge1xuICAgIGxldCByZXNwb25zZTtcbiAgICBpZihhcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICd0cmFkZScsIHRyYWRlLCBhcHBsaWNhdGlvbn0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdEFsbEluc3RhbmNlcyhhY2NvdW50SWQsIHt0eXBlOiAndHJhZGUnLCB0cmFkZSxcbiAgICAgICAgYXBwbGljYXRpb246IGFwcGxpY2F0aW9uIHx8IHRoaXMuX2FwcGxpY2F0aW9uLCByZXF1ZXN0SWQ6IHJhbmRvbXN0cmluZy5nZW5lcmF0ZSgzMil9LCByZWxpYWJpbGl0eSk7XG4gICAgfVxuICAgIHJlc3BvbnNlLnJlc3BvbnNlID0gcmVzcG9uc2UucmVzcG9uc2UgfHwge307XG4gICAgcmVzcG9uc2UucmVzcG9uc2Uuc3RyaW5nQ29kZSA9IHJlc3BvbnNlLnJlc3BvbnNlLnN0cmluZ0NvZGUgfHwgcmVzcG9uc2UucmVzcG9uc2UuZGVzY3JpcHRpb247XG4gICAgcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUgPSByZXNwb25zZS5yZXNwb25zZS5udW1lcmljQ29kZSAhPT0gdW5kZWZpbmVkID8gcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUgOlxuICAgICAgcmVzcG9uc2UucmVzcG9uc2UuZXJyb3I7XG4gICAgaWYgKFsnRVJSX05PX0VSUk9SJywgJ1RSQURFX1JFVENPREVfUExBQ0VEJywgJ1RSQURFX1JFVENPREVfRE9ORScsICdUUkFERV9SRVRDT0RFX0RPTkVfUEFSVElBTCcsXG4gICAgICAnVFJBREVfUkVUQ09ERV9OT19DSEFOR0VTJ10uaW5jbHVkZXMocmVzcG9uc2UucmVzcG9uc2Uuc3RyaW5nQ29kZSB8fCByZXNwb25zZS5yZXNwb25zZS5kZXNjcmlwdGlvbikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFRyYWRlRXJyb3IocmVzcG9uc2UucmVzcG9uc2UubWVzc2FnZSwgcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUsIHJlc3BvbnNlLnJlc3BvbnNlLnN0cmluZ0NvZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGFzayB0aGF0IGVuc3VyZXMgdGhlIGFjY291bnQgZ2V0cyBzdWJzY3JpYmVkIHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkIHRvIHN1YnNjcmliZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqL1xuICBlbnN1cmVTdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuc2NoZWR1bGVTdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcik7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyB0byB0aGUgTWV0YXRyYWRlciB0ZXJtaW5hbCBldmVudHMgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9zdWJzY3JpYmUvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHN1YnNjcmliZSB0b1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3Vic2NyaXB0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIHN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuc3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSB0ZXJtaW5hbCB0byBzdGFydCBzeW5jaHJvbml6YXRpb24gcHJvY2Vzc1xuICAgKiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvc3luY2hyb25pemluZy9zeW5jaHJvbml6ZS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gc3luY2hyb25pemVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlSW5kZXggaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGhvc3QgbmFtZSBvZiBob3N0IHRvIHN5bmNocm9uaXplIHdpdGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lIGZyb20gd2hhdCBkYXRlIHRvIHN0YXJ0IHN5bmNocm9uaXppbmcgaGlzdG9yeSBvcmRlcnMgZnJvbS4gSWYgbm90IHNwZWNpZmllZCxcbiAgICogdGhlIGVudGlyZSBvcmRlciBoaXN0b3J5IHdpbGwgYmUgZG93bmxvYWRlZC5cbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydGluZ0RlYWxUaW1lIGZyb20gd2hhdCBkYXRlIHRvIHN0YXJ0IGRlYWwgc3luY2hyb25pemF0aW9uIGZyb20uIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gYWxsXG4gICAqIGhpc3RvcnkgZGVhbHMgd2lsbCBiZSBkb3dubG9hZGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRIYXNoZXMgZnVuY3Rpb24gdG8gZ2V0IHRlcm1pbmFsIHN0YXRlIGhhc2hlc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiBzdGFydGVkXG4gICAqL1xuICBhc3luYyBzeW5jaHJvbml6ZShhY2NvdW50SWQsIGluc3RhbmNlSW5kZXgsIGhvc3QsIHN5bmNocm9uaXphdGlvbklkLCBzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUsIHN0YXJ0aW5nRGVhbFRpbWUsICBcbiAgICBnZXRIYXNoZXMpIHtcbiAgICBpZih0aGlzLl9nZXRTb2NrZXRJbnN0YW5jZUJ5QWNjb3VudChhY2NvdW50SWQsIGluc3RhbmNlSW5kZXgpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHthY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IGNyZWF0aW5nIHNvY2tldCBpbnN0YW5jZSBvbiBzeW5jaHJvbml6ZWApO1xuICAgICAgYXdhaXQgdGhpcy5fY3JlYXRlU29ja2V0SW5zdGFuY2VCeUFjY291bnQoYWNjb3VudElkLCBpbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gICAgY29uc3Qgc3luY1Rocm90dGxlciA9IHRoaXMuX2dldFNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VJbmRleClcbiAgICAgIC5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXI7XG4gICAgcmV0dXJuIHN5bmNUaHJvdHRsZXIuc2NoZWR1bGVTeW5jaHJvbml6ZShhY2NvdW50SWQsIHtyZXF1ZXN0SWQ6IHN5bmNocm9uaXphdGlvbklkLCBcbiAgICAgIHR5cGU6ICdzeW5jaHJvbml6ZScsIHN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSwgc3RhcnRpbmdEZWFsVGltZSwgaW5zdGFuY2VJbmRleCwgaG9zdH0sIGdldEhhc2hlcyk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgZm9yIHNlcnZlci1zaWRlIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvbiB0byBjb21wbGV0ZS5cbiAgICogKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L3N5bmNocm9uaXppbmcvd2FpdFN5bmNocm9uaXplZC8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gc3luY2hyb25pemVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbnN0YW5jZU51bWJlcl0gaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBsaWNhdGlvblBhdHRlcm4gTWV0YUFwaSBhcHBsaWNhdGlvbiByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiwgZGVmYXVsdCBpcyAuKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dEluU2Vjb25kcyB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgMzAwIHNlY29uZHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFthcHBsaWNhdGlvbl0gYXBwbGljYXRpb24gdG8gc3luY2hyb25pemUgd2l0aFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiBzdGFydGVkXG4gICAqL1xuICB3YWl0U3luY2hyb25pemVkKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIGFwcGxpY2F0aW9uUGF0dGVybiwgdGltZW91dEluU2Vjb25kcywgYXBwbGljYXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICd3YWl0U3luY2hyb25pemVkJywgYXBwbGljYXRpb25QYXR0ZXJuLCB0aW1lb3V0SW5TZWNvbmRzLFxuICAgICAgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXIsIGFwcGxpY2F0aW9uOiBhcHBsaWNhdGlvbiB8fCB0aGlzLl9hcHBsaWNhdGlvbn0sXG4gICAgdGltZW91dEluU2Vjb25kcyArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtldCBkYXRhIHN1YnNjcmlwdGlvblxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXJrZXREYXRhU3Vic2NyaXB0aW9uXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIHN1YnNjcmlwdGlvbiB0eXBlLCBvbmUgb2YgcXVvdGVzLCBjYW5kbGVzLCB0aWNrcywgb3IgbWFya2V0RGVwdGhcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aW1lZnJhbWVdIHdoZW4gc3Vic2NyaXB0aW9uIHR5cGUgaXMgY2FuZGxlcywgZGVmaW5lcyB0aGUgdGltZWZyYW1lIGFjY29yZGluZyB0byB3aGljaCB0aGVcbiAgICogY2FuZGxlcyBtdXN0IGJlIGdlbmVyYXRlZC4gQWxsb3dlZCB2YWx1ZXMgZm9yIE1UNSBhcmUgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsXG4gICAqIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW4uIEFsbG93ZWQgdmFsdWVzIGZvciBNVDQgYXJlIDFtLCA1bSwgMTVtIDMwbSwgMWgsIDRoLCAxZCwgMXcsIDFtblxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2ludGVydmFsSW5NaWxsaXNlY29uZHNdIGRlZmluZXMgaG93IGZyZXF1ZW50bHkgdGhlIHRlcm1pbmFsIHdpbGwgc3RyZWFtIGRhdGEgdG8gY2xpZW50LiBJZiBub3RcbiAgICogc2V0LCB0aGVuIHRoZSB2YWx1ZSBjb25maWd1cmVkIGluIGFjY291bnQgd2lsbCBiZSB1c2VkXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIG9uIG1hcmtldCBkYXRhIG9mIHNwZWNpZmllZCBzeW1ib2wgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L21hcmtldERhdGFTdHJlYW1pbmcvc3Vic2NyaWJlVG9NYXJrZXREYXRhLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFTdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbiB0byBjcmVhdGUgb3IgdXBkYXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVsaWFiaWxpdHldIGFjY291bnQgcmVsaWFiaWxpdHlcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzdWJzY3JpcHRpb24gcmVxdWVzdCB3YXMgcHJvY2Vzc2VkXG4gICAqL1xuICBzdWJzY3JpYmVUb01hcmtldERhdGEoYWNjb3VudElkLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMsIHJlbGlhYmlsaXR5KSB7XG4gICAgcmV0dXJuIHRoaXMucnBjUmVxdWVzdEFsbEluc3RhbmNlcyhhY2NvdW50SWQsXG4gICAgICB7dHlwZTogJ3N1YnNjcmliZVRvTWFya2V0RGF0YScsIHN5bWJvbCwgc3Vic2NyaXB0aW9uc30sIHJlbGlhYmlsaXR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9ucyBvbiB0aGUgc2VydmVyIHRvIHByZXZlbnQgdGhlbSBmcm9tIGV4cGlyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNjcmlwdGlvbnMgYXJyYXkgb2Ygc3Vic2NyaXB0aW9ucyB0byByZWZyZXNoXG4gICAqL1xuICByZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgc3Vic2NyaXB0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucycsIHN1YnNjcmlwdGlvbnMsXG4gICAgICBpbnN0YW5jZUluZGV4OiBpbnN0YW5jZU51bWJlcn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtldCBkYXRhIHVuc3Vic2NyaXB0aW9uXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcmtldERhdGFVbnN1YnNjcmlwdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBzdWJzY3JpcHRpb24gdHlwZSwgb25lIG9mIHF1b3RlcywgY2FuZGxlcywgdGlja3MsIG9yIG1hcmtldERlcHRoXG4gICAqL1xuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3Vuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVVuc3Vic2NyaXB0aW9uPn0gc3Vic2NyaXB0aW9ucyBhcnJheSBvZiBzdWJzY3JpcHRpb25zIHRvIGNhbmNlbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlbGlhYmlsaXR5XSBhY2NvdW50IHJlbGlhYmlsaXR5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdW5zdWJzY3JpcHRpb24gcmVxdWVzdCB3YXMgcHJvY2Vzc2VkXG4gICAqL1xuICB1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhKGFjY291bnRJZCwgc3ltYm9sLCBzdWJzY3JpcHRpb25zLCByZWxpYWJpbGl0eSkge1xuICAgIHJldHVybiB0aGlzLnJwY1JlcXVlc3RBbGxJbnN0YW5jZXMoYWNjb3VudElkLCB7dHlwZTogJ3Vuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEnLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnN9LFxuICAgICAgcmVsaWFiaWxpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBzeW1ib2xzIGF2YWlsYWJsZSBvbiBhbiBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRTeW1ib2xzLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2xzIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxzdHJpbmc+Pn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bWJvbHMgYXJlIHJldHJpZXZlZFxuICAgKi9cbiAgYXN5bmMgZ2V0U3ltYm9scyhhY2NvdW50SWQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0U3ltYm9scyd9KTtcbiAgICByZXR1cm4gcmVzcG9uc2Uuc3ltYm9scztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgc3BlY2lmaWNhdGlvbiBmb3IgYSBzeW1ib2wgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZU1hcmtldERhdGEvcmVhZFN5bWJvbFNwZWNpZmljYXRpb24vKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHJpZXZlIHN5bWJvbCBzcGVjaWZpY2F0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBzcGVjaWZpY2F0aW9uIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbj59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzcGVjaWZpY2F0aW9uIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgYXN5bmMgZ2V0U3ltYm9sU3BlY2lmaWNhdGlvbihhY2NvdW50SWQsIHN5bWJvbCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRTeW1ib2xTcGVjaWZpY2F0aW9uJywgc3ltYm9sfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnNwZWNpZmljYXRpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHByaWNlIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkU3ltYm9sUHJpY2UvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHJpZXZlIHN5bWJvbCBwcmljZSBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgcHJpY2UgZm9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFN1YnNjcmlwdGlvbiBpZiBzZXQgdG8gdHJ1ZSwgdGhlIGFjY291bnQgd2lsbCBnZXQgYSBsb25nLXRlcm0gc3Vic2NyaXB0aW9uIHRvIHN5bWJvbCBtYXJrZXRcbiAgICogZGF0YS4gTG9uZy10ZXJtIHN1YnNjcmlwdGlvbiBtZWFucyB0aGF0IG9uIHN1YnNlcXVlbnQgY2FsbHMgeW91IHdpbGwgZ2V0IHVwZGF0ZWQgdmFsdWUgZmFzdGVyLiBJZiBzZXQgdG8gZmFsc2Ugb3JcbiAgICogbm90IHNldCwgdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIHNldCB0byBleHBpcmUgaW4gMTIgbWludXRlcy5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclN5bWJvbFByaWNlPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHByaWNlIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgYXN5bmMgZ2V0U3ltYm9sUHJpY2UoYWNjb3VudElkLCBzeW1ib2wsIGtlZXBTdWJzY3JpcHRpb24gPSBmYWxzZSkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRTeW1ib2xQcmljZScsIHN5bWJvbCxcbiAgICAgIGtlZXBTdWJzY3JpcHRpb259KTtcbiAgICByZXR1cm4gcmVzcG9uc2UucHJpY2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHByaWNlIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkQ2FuZGxlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBjYW5kbGUgZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIGNhbmRsZSBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWVmcmFtZSBkZWZpbmVzIHRoZSB0aW1lZnJhbWUgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZSBjYW5kbGUgbXVzdCBiZSBnZW5lcmF0ZWQuIEFsbG93ZWQgdmFsdWVzIGZvclxuICAgKiBNVDUgYXJlIDFtLCAybSwgM20sIDRtLCA1bSwgNm0sIDEwbSwgMTJtLCAxNW0sIDIwbSwgMzBtLCAxaCwgMmgsIDNoLCA0aCwgNmgsIDhoLCAxMmgsIDFkLCAxdywgMW1uLiBBbGxvd2VkIHZhbHVlc1xuICAgKiBmb3IgTVQ0IGFyZSAxbSwgNW0sIDE1bSAzMG0sIDFoLCA0aCwgMWQsIDF3LCAxbW5cbiAgICogQHBhcmFtIHtib29sZWFufSBrZWVwU3Vic2NyaXB0aW9uIGlmIHNldCB0byB0cnVlLCB0aGUgYWNjb3VudCB3aWxsIGdldCBhIGxvbmctdGVybSBzdWJzY3JpcHRpb24gdG8gc3ltYm9sIG1hcmtldFxuICAgKiBkYXRhLiBMb25nLXRlcm0gc3Vic2NyaXB0aW9uIG1lYW5zIHRoYXQgb24gc3Vic2VxdWVudCBjYWxscyB5b3Ugd2lsbCBnZXQgdXBkYXRlZCB2YWx1ZSBmYXN0ZXIuIElmIHNldCB0byBmYWxzZSBvclxuICAgKiBub3Qgc2V0LCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgc2V0IHRvIGV4cGlyZSBpbiAxMiBtaW51dGVzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyQ2FuZGxlPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGNhbmRsZSBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldENhbmRsZShhY2NvdW50SWQsIHN5bWJvbCwgdGltZWZyYW1lLCBrZWVwU3Vic2NyaXB0aW9uID0gZmFsc2UpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0Q2FuZGxlJywgc3ltYm9sLCB0aW1lZnJhbWUsXG4gICAgICBrZWVwU3Vic2NyaXB0aW9ufSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmNhbmRsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbGF0ZXN0IHRpY2sgZm9yIGEgc3ltYm9sLiBNVDQgRzEgYWNjb3VudHMgZG8gbm90IHN1cHBvcnQgdGhpcyBBUEkgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZU1hcmtldERhdGEvcmVhZFRpY2svKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHJpZXZlIHN5bWJvbCB0aWNrIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSB0aWNrIGZvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBTdWJzY3JpcHRpb24gaWYgc2V0IHRvIHRydWUsIHRoZSBhY2NvdW50IHdpbGwgZ2V0IGEgbG9uZy10ZXJtIHN1YnNjcmlwdGlvbiB0byBzeW1ib2wgbWFya2V0XG4gICAqIGRhdGEuIExvbmctdGVybSBzdWJzY3JpcHRpb24gbWVhbnMgdGhhdCBvbiBzdWJzZXF1ZW50IGNhbGxzIHlvdSB3aWxsIGdldCB1cGRhdGVkIHZhbHVlIGZhc3Rlci4gSWYgc2V0IHRvIGZhbHNlIG9yXG4gICAqIG5vdCBzZXQsIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSBzZXQgdG8gZXhwaXJlIGluIDEyIG1pbnV0ZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJUaWNrPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRpY2sgaXMgcmV0cmlldmVkXG4gICAqL1xuICBhc3luYyBnZXRUaWNrKGFjY291bnRJZCwgc3ltYm9sLCBrZWVwU3Vic2NyaXB0aW9uID0gZmFsc2UpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0VGljaycsIHN5bWJvbCwga2VlcFN1YnNjcmlwdGlvbn0pO1xuICAgIHJldHVybiByZXNwb25zZS50aWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBsYXRlc3Qgb3JkZXIgYm9vayBmb3IgYSBzeW1ib2wuIE1UNCBhY2NvdW50cyBkbyBub3Qgc3VwcG9ydCB0aGlzIEFQSSAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkQm9vay8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9sIG9yZGVyIGJvb2sgZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIG9yZGVyIGJvb2sgZm9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFN1YnNjcmlwdGlvbiBpZiBzZXQgdG8gdHJ1ZSwgdGhlIGFjY291bnQgd2lsbCBnZXQgYSBsb25nLXRlcm0gc3Vic2NyaXB0aW9uIHRvIHN5bWJvbCBtYXJrZXRcbiAgICogZGF0YS4gTG9uZy10ZXJtIHN1YnNjcmlwdGlvbiBtZWFucyB0aGF0IG9uIHN1YnNlcXVlbnQgY2FsbHMgeW91IHdpbGwgZ2V0IHVwZGF0ZWQgdmFsdWUgZmFzdGVyLiBJZiBzZXQgdG8gZmFsc2Ugb3JcbiAgICogbm90IHNldCwgdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIHNldCB0byBleHBpcmUgaW4gMTIgbWludXRlcy5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckJvb2s+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gb3JkZXIgYm9vayBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldEJvb2soYWNjb3VudElkLCBzeW1ib2wsIGtlZXBTdWJzY3JpcHRpb24gPSBmYWxzZSkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRCb29rJywgc3ltYm9sLCBrZWVwU3Vic2NyaXB0aW9ufSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvb2s7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgY2xpZW50IHVwdGltZSBzdGF0cyB0byB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gc2F2ZSB1cHRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IHVwdGltZSB1cHRpbWUgc3RhdGlzdGljcyB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1cHRpbWUgc3RhdGlzdGljcyBpcyBzdWJtaXR0ZWRcbiAgICovXG4gIHNhdmVVcHRpbWUoYWNjb3VudElkLCB1cHRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICdzYXZlVXB0aW1lJywgdXB0aW1lfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvc3luY2hyb25pemluZy91bnN1YnNjcmliZSkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byB1bnN1YnNjcmliZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHNvY2tldCB1bnN1YnNjcmliZWRcbiAgICovXG4gIGFzeW5jIHVuc3Vic2NyaWJlKGFjY291bnRJZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKTtcbiAgICAgIHRoaXMuX2xhdGVuY3lTZXJ2aWNlLm9uVW5zdWJzY3JpYmUoYWNjb3VudElkKTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dKS5tYXAoYXN5bmMgaW5zdGFuY2VOdW1iZXIgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLnVuc3Vic2NyaWJlKGFjY291bnRJZCwgTnVtYmVyKGluc3RhbmNlTnVtYmVyKSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdO1xuICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCEoWydUaW1lb3V0RXJyb3InLCAnTm90Rm91bmRFcnJvciddLmluY2x1ZGVzKGVyci5uYW1lKSkpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHNlcnZlciB0aW1lIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9zZXJ2ZXJUaW1lLylcbiAgICogQHR5cGVkZWYge09iamVjdH0gU2VydmVyVGltZVxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgY3VycmVudCBzZXJ2ZXIgdGltZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYnJva2VyVGltZSBjdXJyZW50IGJyb2tlciB0aW1lLCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge0RhdGV9IFtsYXN0UXVvdGVUaW1lXSBsYXN0IHF1b3RlIHRpbWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtsYXN0UXVvdGVCcm9rZXJUaW1lXSBsYXN0IHF1b3RlIHRpbWUsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlcnZlciB0aW1lIGZvciBhIHNwZWNpZmllZCBNZXRhVHJhZGVyIGFjY291bnQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZFNlcnZlclRpbWUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBzZXJ2ZXIgdGltZSBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8U2VydmVyVGltZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggc2VydmVyIHRpbWVcbiAgICovXG4gIGFzeW5jIGdldFNlcnZlclRpbWUoYWNjb3VudElkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFNlcnZlclRpbWUnfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnNlcnZlclRpbWU7XG4gIH1cblxuICAvKipcbiAgICogTWFyZ2luIHJlcXVpcmVkIHRvIG9wZW4gYSB0cmFkZSAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9tb2RlbHMvbWFyZ2luLylcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWFyZ2luXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWFyZ2luXSBtYXJnaW4gcmVxdWlyZWQgdG8gb3BlbiBhIHRyYWRlLiBJZiBtYXJnaW4gY2FuIG5vdCBiZSBjYWxjdWxhdGVkLCB0aGVuIHRoaXMgZmllbGQgaXNcbiAgICogbm90IGRlZmluZWRcbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnRhaW5zIG9yZGVyIHRvIGNhbGN1bGF0ZSBtYXJnaW4gZm9yIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9tYXJnaW5PcmRlci8pXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcmdpbk9yZGVyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzeW1ib2wgb3JkZXIgc3ltYm9sXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIG9yZGVyIHR5cGUsIG9uZSBvZiBPUkRFUl9UWVBFX0JVWSBvciBPUkRFUl9UWVBFX1NFTExcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWUsIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBvcGVuIHByaWNlLCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIG1hcmdpbiByZXF1aXJlZCB0byBvcGVuIGEgdHJhZGUgb24gdGhlIHNwZWNpZmllZCB0cmFkaW5nIGFjY291bnQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9jYWxjdWxhdGVNYXJnaW4vKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgdHJhZGluZyBhY2NvdW50IHRvIGNhbGN1bGF0ZSBtYXJnaW4gZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBsaWNhdGlvbiBhcHBsaWNhdGlvbiB0byBzZW5kIHRoZSByZXF1ZXN0IHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWxpYWJpbGl0eSBhY2NvdW50IHJlbGlhYmlsaXR5XG4gICAqIEBwYXJhbSB7TWFyZ2luT3JkZXJ9IG9yZGVyIG9yZGVyIHRvIGNhbGN1bGF0ZSBtYXJnaW4gZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1hcmdpbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggbWFyZ2luIGNhbGN1bGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgYXN5bmMgY2FsY3VsYXRlTWFyZ2luKGFjY291bnRJZCwgYXBwbGljYXRpb24sIHJlbGlhYmlsaXR5LCBvcmRlcikge1xuICAgIGxldCByZXNwb25zZTtcbiAgICBpZihhcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uLCB0eXBlOiAnY2FsY3VsYXRlTWFyZ2luJywgb3JkZXJ9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3RBbGxJbnN0YW5jZXMoYWNjb3VudElkLCB7YXBwbGljYXRpb24sIHR5cGU6ICdjYWxjdWxhdGVNYXJnaW4nLCBvcmRlcn0sXG4gICAgICAgIHJlbGlhYmlsaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLm1hcmdpbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBvblVuc3Vic2NyaWJlUmVnaW9uIGxpc3RlbmVyIGV2ZW50IFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBhY2NvdW50IHJlZ2lvbiB0byB1bnN1YnNjcmliZVxuICAgKi9cbiAgYXN5bmMgdW5zdWJzY3JpYmVBY2NvdW50UmVnaW9uKGFjY291bnRJZCwgcmVnaW9uKSB7XG4gICAgY29uc3QgdW5zdWJzY3JpYmVQcm9taXNlcyA9IFtdO1xuICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICB1bnN1YnNjcmliZVByb21pc2VzLnB1c2goXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uVW5zdWJzY3JpYmVSZWdpb24ocmVnaW9uKSxcbiAgICAgICAgICAgIGAke2FjY291bnRJZH06JHtyZWdpb259Om9uVW5zdWJzY3JpYmVSZWdpb25gLCB0cnVlKTtcbiAgICAgICAgfSkoKSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHthY2NvdW50SWR9OiR7cmVnaW9ufTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICdhYm91dCBvblVuc3Vic2NyaWJlUmVnaW9uIGV2ZW50JywgZXJyKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHVuc3Vic2NyaWJlUHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyIGZvciBzcGVjaWZpYyBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge1N5bmNocm9uaXphdGlvbkxpc3RlbmVyfSBsaXN0ZW5lciBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgdG8gYWRkXG4gICAqL1xuICBhZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50SWQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGAke2FjY291bnRJZH06IEFkZGVkIHN5bmNocm9uaXphdGlvbiBsaXN0ZW5lcmApO1xuICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbYWNjb3VudElkXTtcbiAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXJzID0gW107XG4gICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbYWNjb3VudElkXSA9IGxpc3RlbmVycztcbiAgICB9XG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyIGZvciBzcGVjaWZpYyBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge1N5bmNocm9uaXphdGlvbkxpc3RlbmVyfSBsaXN0ZW5lciBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50SWQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGAke2FjY291bnRJZH06IFJlbW92ZWQgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyYCk7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbYWNjb3VudElkXSA9IGxpc3RlbmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGxhdGVuY3kgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtMYXRlbmN5TGlzdGVuZXJ9IGxpc3RlbmVyIGxhdGVuY3kgbGlzdGVuZXIgdG8gYWRkXG4gICAqL1xuICBhZGRMYXRlbmN5TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGF0ZW5jeSBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0xhdGVuY3lMaXN0ZW5lcn0gbGlzdGVuZXIgbGF0ZW5jeSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUxhdGVuY3lMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMgPSB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHJlY29ubmVjdCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge1JlY29ubmVjdExpc3RlbmVyfSBsaXN0ZW5lciByZWNvbm5lY3QgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZCBvZiBsaXN0ZW5lclxuICAgKi9cbiAgYWRkUmVjb25uZWN0TGlzdGVuZXIobGlzdGVuZXIsIGFjY291bnRJZCkge1xuICAgIHRoaXMuX3JlY29ubmVjdExpc3RlbmVycy5wdXNoKHthY2NvdW50SWQsIGxpc3RlbmVyfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyByZWNvbm5lY3QgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtSZWNvbm5lY3RMaXN0ZW5lcn0gbGlzdGVuZXIgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVSZWNvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3JlY29ubmVjdExpc3RlbmVycyA9IHRoaXMuX3JlY29ubmVjdExpc3RlbmVycy5maWx0ZXIobCA9PiBsLmxpc3RlbmVyICE9PSBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBJbnRlbmRlZCBmb3IgdXNlIGluIHVuaXQgdGVzdHMuXG4gICAqL1xuICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzID0gW107XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBRdWV1ZXMgYW4gYWNjb3VudCBwYWNrZXQgZm9yIHByb2Nlc3NpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBwYWNrZXQgdG8gcHJvY2Vzc1xuICAgKi9cbiAgcXVldWVQYWNrZXQocGFja2V0KSB7XG4gICAgY29uc3QgYWNjb3VudElkID0gcGFja2V0LmFjY291bnRJZDtcbiAgICBjb25zdCBwYWNrZXRzID0gdGhpcy5fcGFja2V0T3JkZXJlci5yZXN0b3JlT3JkZXIocGFja2V0KS5maWx0ZXIocCA9PiBwLnR5cGUgIT09ICdub29wJyk7XG4gICAgaWYodGhpcy5fc2VxdWVudGlhbEV2ZW50UHJvY2Vzc2luZyAmJiBwYWNrZXQuc2VxdWVuY2VOdW1iZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZXZlbnRzID0gcGFja2V0cy5tYXAocGFja2V0SXRlbSA9PiAoKSA9PiBcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQocGFja2V0SXRlbSkpKTtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXSkge1xuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdID0gZXZlbnRzO1xuICAgICAgICB0aGlzLl9jYWxsQWNjb3VudEV2ZW50cyhhY2NvdW50SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXSA9IHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0uY29uY2F0KGV2ZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldHMuZm9yRWFjaChwYWNrZXRJdGVtID0+IHRoaXMuX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQocGFja2V0SXRlbSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBRdWV1ZXMgYWNjb3VudCBldmVudCBmb3IgcHJvY2Vzc2luZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgZXZlbnQgbGFiZWwgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYWJsZSBhc3luYyBvciByZWd1bGFyIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICovXG4gIHF1ZXVlRXZlbnQoYWNjb3VudElkLCBuYW1lLCBjYWxsYWJsZSkge1xuICAgIGxldCBldmVudCA9ICgpID0+IHRoaXMuX3Byb2Nlc3NFdmVudChjYWxsYWJsZSwgYCR7YWNjb3VudElkfToke25hbWV9YCk7XG4gICAgaWYodGhpcy5fc2VxdWVudGlhbEV2ZW50UHJvY2Vzc2luZykge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdKSB7IFxuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdID0gW2V2ZW50XTtcbiAgICAgICAgdGhpcy5fY2FsbEFjY291bnRFdmVudHMoYWNjb3VudElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0ucHVzaChldmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2NhbGxBY2NvdW50RXZlbnRzKGFjY291bnRJZCkge1xuICAgIGlmKHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0pIHtcbiAgICAgIHdoaWxlKHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0ubGVuZ3RoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF1bMF0oKTtcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXS5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX3JlY29ubmVjdChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLnNvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXVtzb2NrZXRJbnN0YW5jZUluZGV4XTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIHdoaWxlICghaW5zdGFuY2Uuc29ja2V0LmNvbm5lY3RlZCAmJiAhaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgJiYgaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3RyeVJlY29ubmVjdChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfdHJ5UmVjb25uZWN0KGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdO1xuICAgIGluc3RhbmNlLnJlY29ubmVjdFdhaXRUaW1lID0gTWF0aC5taW4oaW5zdGFuY2UucmVjb25uZWN0V2FpdFRpbWUgKiAyLCAzMDAwMCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghaW5zdGFuY2Uuc29ja2V0LmNvbm5lY3RlZCAmJiAhaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgJiYgaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2Uuc2Vzc2lvbklkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmlvLm9wdHMuZXh0cmFIZWFkZXJzWydDbGllbnQtSWQnXSA9IGNsaWVudElkO1xuICAgICAgICAgIGluc3RhbmNlLnNvY2tldC5pby5vcHRzLnF1ZXJ5LmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgIGluc3RhbmNlLnNvY2tldC5pby51cmkgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJVcmwoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbik7XG4gICAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSwgaW5zdGFuY2UucmVjb25uZWN0V2FpdFRpbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW11bGF0YW5lb3VzbHkgc2VuZHMgUlBDIHJlcXVlc3RzIHRvIGFsbCBzeW5jaHJvbml6ZWQgaW5zdGFuY2VzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgbWV0YXRyYWRlciBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IGJhc2UgcmVxdWVzdCBkYXRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVsaWFiaWxpdHldIGFjY291bnQgcmVsaWFiaWxpdHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSByZXF1ZXN0IHRpbWVvdXQgaW4gc2Vjb25kc1xuICAgKi9cbiAgYXN5bmMgcnBjUmVxdWVzdEFsbEluc3RhbmNlcyhhY2NvdW50SWQsIHJlcXVlc3QsIHJlbGlhYmlsaXR5LCB0aW1lb3V0SW5TZWNvbmRzKSAge1xuICAgIGlmKHJlbGlhYmlsaXR5ID09PSAnaGlnaCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhbnkoWzAsIDFdLm1hcChpbnN0YW5jZU51bWJlciA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QsIFxuICAgICAgICAgICAge2luc3RhbmNlSW5kZXg6IGluc3RhbmNlTnVtYmVyfSksIHRpbWVvdXRJblNlY29uZHMpO1xuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvci5lcnJvcnNbMF07IFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwgcmVxdWVzdCwgdGltZW91dEluU2Vjb25kcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgUlBDIHJlcXVlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBtZXRhdHJhZGVyIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgYmFzZSByZXF1ZXN0IGRhdGFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSByZXF1ZXN0IHRpbWVvdXQgaW4gc2Vjb25kc1xuICAgKi9cbiAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHNcbiAgYXN5bmMgcnBjUmVxdWVzdChhY2NvdW50SWQsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICBjb25zdCBpZ25vcmVkUmVxdWVzdFR5cGVzID0gWydzdWJzY3JpYmUnLCAnc3luY2hyb25pemUnLCAncmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zJywgJ3Vuc3Vic2NyaWJlJ107XG4gICAgY29uc3QgcHJpbWFyeUFjY291bnRJZCA9IHRoaXMuX2FjY291bnRzQnlSZXBsaWNhSWRbYWNjb3VudElkXTtcbiAgICBjb25zdCBjb25uZWN0ZWRJbnN0YW5jZSA9IHRoaXMuX2xhdGVuY3lTZXJ2aWNlLmdldEFjdGl2ZUFjY291bnRJbnN0YW5jZXMocHJpbWFyeUFjY291bnRJZClbMF07XG4gICAgaWYoIWlnbm9yZWRSZXF1ZXN0VHlwZXMuaW5jbHVkZXMocmVxdWVzdC50eXBlKSAmJiBjb25uZWN0ZWRJbnN0YW5jZSkge1xuICAgICAgY29uc3QgYWN0aXZlUmVnaW9uID0gY29ubmVjdGVkSW5zdGFuY2Uuc3BsaXQoJzonKVsxXTtcbiAgICAgIGFjY291bnRJZCA9IHRoaXMuX2FjY291bnRSZXBsaWNhc1twcmltYXJ5QWNjb3VudElkXVthY3RpdmVSZWdpb25dO1xuICAgIH1cbiAgICBsZXQgc29ja2V0SW5zdGFuY2VJbmRleCA9IG51bGw7XG4gICAgbGV0IGluc3RhbmNlTnVtYmVyID0gMDtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKTtcbiAgICB0aGlzLl9yZWZyZXNoQWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIGlmKHJlcXVlc3QuaW5zdGFuY2VJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0YW5jZU51bWJlciA9IHJlcXVlc3QuaW5zdGFuY2VJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoY29ubmVjdGVkSW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBOdW1iZXIoY29ubmVjdGVkSW5zdGFuY2Uuc3BsaXQoJzonKVsyXSk7XG4gICAgICB9XG4gICAgICBpZihyZXF1ZXN0LmFwcGxpY2F0aW9uICE9PSAnUlBDJykge1xuICAgICAgICByZXF1ZXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCwge2luc3RhbmNlSW5kZXg6IGluc3RhbmNlTnVtYmVyfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKCF0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXSkge1xuICAgICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl0gPSB7fTtcbiAgICB9XG4gICAgaWYoIXRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dKSB7XG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXSA9IHt9O1xuICAgIH1cbiAgICBpZighdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdKSB7XG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0gPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9IHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHthY2NvdW50SWR9OiR7aW5zdGFuY2VOdW1iZXJ9OiBjcmVhdGluZyBzb2NrZXQgaW5zdGFuY2Ugb24gUlBDIHJlcXVlc3RgKTtcbiAgICAgIGF3YWl0IHRoaXMuX2NyZWF0ZVNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9IHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF07XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdO1xuICAgIGlmICghaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7YWNjb3VudElkfToke2luc3RhbmNlTnVtYmVyfTogY29ubmVjdGluZyBzb2NrZXQgaW5zdGFuY2Ugb24gUlBDIHJlcXVlc3RgKTtcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdChpbnN0YW5jZU51bWJlciwgcmVnaW9uKTtcbiAgICB9IGVsc2UgaWYoIXRoaXMuY29ubmVjdGVkKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pKSB7XG4gICAgICBhd2FpdCBpbnN0YW5jZS5jb25uZWN0UmVzdWx0O1xuICAgIH1cbiAgICBpZihyZXF1ZXN0LnR5cGUgPT09ICdzdWJzY3JpYmUnKSB7XG4gICAgICByZXF1ZXN0LnNlc3Npb25JZCA9IGluc3RhbmNlLnNlc3Npb25JZDtcbiAgICB9XG4gICAgaWYoWyd0cmFkZScsICdzdWJzY3JpYmUnXS5pbmNsdWRlcyhyZXF1ZXN0LnR5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFrZVJlcXVlc3QoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgcmVxdWVzdCwgdGltZW91dEluU2Vjb25kcyk7XG4gICAgfVxuICAgIGxldCByZXRyeUNvdW50ZXIgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9tYWtlUmVxdWVzdChhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCByZXF1ZXN0LCB0aW1lb3V0SW5TZWNvbmRzKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGlmKGVyci5uYW1lID09PSAnVG9vTWFueVJlcXVlc3RzRXJyb3InKSB7XG4gICAgICAgICAgbGV0IGNhbGNSZXRyeUNvdW50ZXIgPSByZXRyeUNvdW50ZXI7XG4gICAgICAgICAgbGV0IGNhbGNSZXF1ZXN0VGltZSA9IDA7XG4gICAgICAgICAgd2hpbGUoY2FsY1JldHJ5Q291bnRlciA8IHRoaXMuX3JldHJpZXMpIHtcbiAgICAgICAgICAgIGNhbGNSZXRyeUNvdW50ZXIrKztcbiAgICAgICAgICAgIGNhbGNSZXF1ZXN0VGltZSArPSBNYXRoLm1pbihNYXRoLnBvdygyLCBjYWxjUmV0cnlDb3VudGVyKSAqIHRoaXMuX21pblJldHJ5RGVsYXlJblNlY29uZHMsXG4gICAgICAgICAgICAgIHRoaXMuX21heFJldHJ5RGVsYXlJblNlY29uZHMpICogMTAwMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmV0cnlUaW1lID0gbmV3IERhdGUoZXJyLm1ldGFkYXRhLnJlY29tbWVuZGVkUmV0cnlUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgICAgaWYgKERhdGUubm93KCkgKyBjYWxjUmVxdWVzdFRpbWUgPiByZXRyeVRpbWUgJiYgcmV0cnlDb3VudGVyIDwgdGhpcy5fcmV0cmllcykge1xuICAgICAgICAgICAgaWYoRGF0ZS5ub3coKSA8IHJldHJ5VGltZSkge1xuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIHJldHJ5VGltZSAtIERhdGUubm93KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHJ5Q291bnRlcisrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoWydOb3RTeW5jaHJvbml6ZWRFcnJvcicsICdUaW1lb3V0RXJyb3InLCAnTm90QXV0aGVudGljYXRlZEVycm9yJyxcbiAgICAgICAgICAnSW50ZXJuYWxFcnJvciddLmluY2x1ZGVzKGVyci5uYW1lKSAmJiBcbiAgICAgICAgICByZXRyeUNvdW50ZXIgPCB0aGlzLl9yZXRyaWVzKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeUNvdW50ZXIpICogXG4gICAgICAgICAgICB0aGlzLl9taW5SZXRyeURlbGF5SW5TZWNvbmRzLCB0aGlzLl9tYXhSZXRyeURlbGF5SW5TZWNvbmRzKSAqIDEwMDApKTtcbiAgICAgICAgICByZXRyeUNvdW50ZXIrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX21ha2VSZXF1ZXN0KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICBjb25zdCBzb2NrZXRJbnN0YW5jZSA9IHRoaXMuX2dldFNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgIGxldCByZXF1ZXN0SWQgPSByZXF1ZXN0LnJlcXVlc3RJZCB8fCByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHJlcXVlc3QudGltZXN0YW1wcyA9IHtjbGllbnRQcm9jZXNzaW5nU3RhcnRlZDogbmV3IERhdGUoKX07XG4gICAgbGV0IHJlc3VsdCA9IFByb21pc2UucmFjZShbXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzb2NrZXRJbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbcmVxdWVzdElkXSA9IFxuICAgICAgICB7cmVzb2x2ZSwgcmVqZWN0LCB0eXBlOiByZXF1ZXN0LnR5cGV9KSxcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IFRpbWVvdXRFcnJvcihgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IHJlcXVlc3QgJHtyZXF1ZXN0LnJlcXVlc3RJZH0gb2YgdHlwZSAke3JlcXVlc3QudHlwZX0gYCArXG4gICAgICAgICAgJ3RpbWVkIG91dC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3VyIGFjY291bnQgaXMgY29ubmVjdGVkIHRvIGJyb2tlciBiZWZvcmUgcmV0cnlpbmcgeW91ciByZXF1ZXN0LicpKTtcbiAgICAgICAgZGVsZXRlIHNvY2tldEluc3RhbmNlLnJlcXVlc3RSZXNvbHZlc1tyZXF1ZXN0SWRdO1xuICAgICAgfSwgKHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSB8fCB0aGlzLl9yZXF1ZXN0VGltZW91dCkpXG4gICAgXSk7XG4gICAgcmVxdWVzdC5hY2NvdW50SWQgPSBhY2NvdW50SWQ7XG4gICAgcmVxdWVzdC5hcHBsaWNhdGlvbiA9IHJlcXVlc3QuYXBwbGljYXRpb24gfHwgdGhpcy5fYXBwbGljYXRpb247XG4gICAgaWYgKCFyZXF1ZXN0LnJlcXVlc3RJZCkge1xuICAgICAgcmVxdWVzdC5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LnR5cGUgPT09ICd1bnN1YnNjcmliZScgfHwgcmVxdWVzdC5hcHBsaWNhdGlvbiA9PT0gJ1JQQycgfHxcbiAgICAgIHJlcXVlc3QuaW5zdGFuY2VJbmRleCA9PT0gc29ja2V0SW5zdGFuY2UuaW5zdGFuY2VOdW1iZXIpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygoKSA9PiBgJHthY2NvdW50SWR9OiBTZW5kaW5nIHJlcXVlc3Q6ICR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdCl9YCk7XG4gICAgICBzb2NrZXRJbnN0YW5jZS5zb2NrZXQuZW1pdCgncmVxdWVzdCcsIHJlcXVlc3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKCgpID0+IGAke2FjY291bnRJZH06JHtyZXF1ZXN0Lmluc3RhbmNlSW5kZXh9OiBza2lwcGluZyByZXF1ZXN0IGJlY2F1c2UgaXQgaXMgYmVpbmcgc2VudCB0byBgICtcbiAgICAgICAgYHRoZSBzb2NrZXQgb2YgdGhlIHdyb25nIGluc3RhbmNlIGluZGV4LCByZXF1ZXN0PSR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdCl9YCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIF9jb252ZXJ0RXJyb3IoZGF0YSkge1xuICAgIGlmIChkYXRhLmVycm9yID09PSAnVmFsaWRhdGlvbkVycm9yJykge1xuICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoZGF0YS5tZXNzYWdlLCBkYXRhLmRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvciA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdOb3RTeW5jaHJvbml6ZWRFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgTm90U3luY2hyb25pemVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUaW1lb3V0RXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IFRpbWVvdXRFcnJvcihkYXRhLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvciA9PT0gJ05vdEF1dGhlbnRpY2F0ZWRFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgTm90Q29ubmVjdGVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUcmFkZUVycm9yJykge1xuICAgICAgcmV0dXJuIG5ldyBUcmFkZUVycm9yKGRhdGEubWVzc2FnZSwgZGF0YS5udW1lcmljQ29kZSwgZGF0YS5zdHJpbmdDb2RlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdVbmF1dGhvcml6ZWRFcnJvcicpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHJldHVybiBuZXcgVW5hdXRob3JpemVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUb29NYW55UmVxdWVzdHNFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgVG9vTWFueVJlcXVlc3RzRXJyb3IoZGF0YS5tZXNzYWdlLCBkYXRhLm1ldGFkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbEVycm9yKGRhdGEubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgX2NvbnZlcnRJc29UaW1lVG9EYXRlKHBhY2tldCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKGxldCBmaWVsZCBpbiBwYWNrZXQpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHBhY2tldFtmaWVsZF07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBmaWVsZC5tYXRjaCgvdGltZSR8VGltZSQvKSAmJiBcbiAgICAgICAgIWZpZWxkLm1hdGNoKC9icm9rZXJUaW1lJHxCcm9rZXJUaW1lJHx0aW1lZnJhbWUkLykpIHtcbiAgICAgICAgcGFja2V0W2ZpZWxkXSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fY29udmVydElzb1RpbWVUb0RhdGUoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuX2NvbnZlcnRJc29UaW1lVG9EYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhY2tldCAmJiBwYWNrZXQudGltZXN0YW1wcykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgZm9yIChsZXQgZmllbGQgaW4gcGFja2V0LnRpbWVzdGFtcHMpIHtcbiAgICAgICAgcGFja2V0LnRpbWVzdGFtcHNbZmllbGRdID0gbmV3IERhdGUocGFja2V0LnRpbWVzdGFtcHNbZmllbGRdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhY2tldCAmJiBwYWNrZXQudHlwZSA9PT0gJ3ByaWNlcycpIHtcbiAgICAgIGZvciAobGV0IHByaWNlIG9mIHBhY2tldC5wcmljZXMgfHwgW10pIHtcbiAgICAgICAgaWYgKHByaWNlLnRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICAgICAgZm9yIChsZXQgZmllbGQgaW4gcHJpY2UudGltZXN0YW1wcykge1xuICAgICAgICAgICAgcHJpY2UudGltZXN0YW1wc1tmaWVsZF0gPSBuZXcgRGF0ZShwcmljZS50aW1lc3RhbXBzW2ZpZWxkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgc3ltYm9sIHNwZWNpZmljYXRpb24uIENvbnRhaW5zIHN5bWJvbCBzcGVjaWZpY2F0aW9uIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9tZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbi8pXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpY2tTaXplIHRpY2sgc2l6ZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWluVm9sdW1lIG1pbmltdW0gb3JkZXIgdm9sdW1lIGZvciB0aGUgc3ltYm9sXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXhWb2x1bWUgbWF4aW11bSBvcmRlciB2b2x1bWUgZm9yIHRoZSBzeW1ib2xcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHZvbHVtZVN0ZXAgb3JkZXIgdm9sdW1lIHN0ZXAgZm9yIHRoZSBzeW1ib2xcbiAgICogQHByb3BlcnR5IHtBcnJheTxTdHJpbmc+fSBsaXN0IG9mIGFsbG93ZWQgb3JkZXIgZmlsbGluZyBtb2Rlcy4gQ2FuIGNvbnRhaW4gT1JERVJfRklMTElOR19GT0ssIE9SREVSX0ZJTExJTkdfSU9DIG9yXG4gICAqIGJvdGguIFNlZSBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI3N5bWJvbF9maWxsaW5nX21vZGUgZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlYWwgZXhlY3V0aW9uIG1vZGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgU1lNQk9MX1RSQURFX0VYRUNVVElPTl9SRVFVRVNULFxuICAgKiBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX0lOU1RBTlQsIFNZTUJPTF9UUkFERV9FWEVDVVRJT05fTUFSS0VULCBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX0VYQ0hBTkdFLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF90cmFkZV9leGVjdXRpb24gZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbnRyYWN0U2l6ZSB0cmFkZSBjb250cmFjdCBzaXplXG4gICAqIEBwcm9wZXJ0eSB7TWV0YXRyYWRlclNlc3Npb25zfSBxdW90ZVNlc3Npb25zIHF1b3RlIHNlc3Npb25zLCBpbmRleGVkIGJ5IGRheSBvZiB3ZWVrXG4gICAqIEBwcm9wZXJ0eSB7TWV0YXRyYWRlclNlc3Npb25zfSB0cmFkZVNlc3Npb25zIHRyYWRlIHNlc3Npb25zLCBpbmRleGVkIGJ5IGRheSBvZiB3ZWVrXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdHJhZGVNb2RlXSBvcmRlciBleGVjdXRpb24gdHlwZS4gUG9zc2libGUgdmFsdWVzIGFyZSBTWU1CT0xfVFJBREVfTU9ERV9ESVNBQkxFRCxcbiAgICogU1lNQk9MX1RSQURFX01PREVfTE9OR09OTFksIFNZTUJPTF9UUkFERV9NT0RFX1NIT1JUT05MWSwgU1lNQk9MX1RSQURFX01PREVfQ0xPU0VPTkxZLCBTWU1CT0xfVFJBREVfTU9ERV9GVUxMLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF90cmFkZV9tb2RlIGZvciBtb3JlXG4gICAqIGRldGFpbHNcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtib25kQWNjcnVlZEludGVyZXN0XSBhY2NydWVkIGludGVyZXN0IOKAkyBhY2N1bXVsYXRlZCBjb3Vwb24gaW50ZXJlc3QsIGkuZS4gcGFydCBvZiB0aGUgY291cG9uXG4gICAqIGludGVyZXN0IGNhbGN1bGF0ZWQgaW4gcHJvcG9ydGlvbiB0byB0aGUgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIGNvdXBvbiBib25kIGlzc3VhbmNlIG9yIHRoZSBsYXN0IGNvdXBvbiBpbnRlcmVzdFxuICAgKiBwYXltZW50XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYm9uZEZhY2VWYWx1ZV0gZmFjZSB2YWx1ZSDigJMgaW5pdGlhbCBib25kIHZhbHVlIHNldCBieSB0aGUgaXNzdWVyXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbb3B0aW9uU3RyaWtlXSB0aGUgc3RyaWtlIHByaWNlIG9mIGFuIG9wdGlvbi4gVGhlIHByaWNlIGF0IHdoaWNoIGFuIG9wdGlvbiBidXllciBjYW4gYnV5IChpbiBhXG4gICAqIENhbGwgb3B0aW9uKSBvciBzZWxsIChpbiBhIFB1dCBvcHRpb24pIHRoZSB1bmRlcmx5aW5nIGFzc2V0LCBhbmQgdGhlIG9wdGlvbiBzZWxsZXIgaXMgb2JsaWdlZCB0byBzZWxsIG9yIGJ1eSB0aGVcbiAgICogYXBwcm9wcmlhdGUgYW1vdW50IG9mIHRoZSB1bmRlcmx5aW5nIGFzc2V0LlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW29wdGlvblByaWNlU2Vuc2l2aXR5XSBvcHRpb24vd2FycmFudCBzZW5zaXRpdml0eSBzaG93cyBieSBob3cgbWFueSBwb2ludHMgdGhlIHByaWNlIG9mIHRoZVxuICAgKiBvcHRpb24ncyB1bmRlcmx5aW5nIGFzc2V0IHNob3VsZCBjaGFuZ2Ugc28gdGhhdCB0aGUgcHJpY2Ugb2YgdGhlIG9wdGlvbiBjaGFuZ2VzIGJ5IG9uZSBwb2ludFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2xpcXVpZGl0eVJhdGVdIGxpcXVpZGl0eSBSYXRlIGlzIHRoZSBzaGFyZSBvZiB0aGUgYXNzZXQgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIG1hcmdpblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gaW5pdGlhbE1hcmdpbiBpbml0aWFsIG1hcmdpbiBtZWFucyB0aGUgYW1vdW50IGluIHRoZSBtYXJnaW4gY3VycmVuY3kgcmVxdWlyZWQgZm9yIG9wZW5pbmcgYVxuICAgKiBwb3NpdGlvbiB3aXRoIHRoZSB2b2x1bWUgb2Ygb25lIGxvdC4gSXQgaXMgdXNlZCBmb3IgY2hlY2tpbmcgYSBjbGllbnQncyBhc3NldHMgd2hlbiBoZSBvciBzaGUgZW50ZXJzIHRoZSBtYXJrZXRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1haW50ZW5hbmNlTWFyZ2luIHRoZSBtYWludGVuYW5jZSBtYXJnaW4uIElmIGl0IGlzIHNldCwgaXQgc2V0cyB0aGUgbWFyZ2luIGFtb3VudCBpbiB0aGUgbWFyZ2luXG4gICAqIGN1cnJlbmN5IG9mIHRoZSBzeW1ib2wsIGNoYXJnZWQgZnJvbSBvbmUgbG90LiBJdCBpcyB1c2VkIGZvciBjaGVja2luZyBhIGNsaWVudCdzIGFzc2V0cyB3aGVuIGhpcy9oZXIgYWNjb3VudCBzdGF0ZVxuICAgKiBjaGFuZ2VzLiBJZiB0aGUgbWFpbnRlbmFuY2UgbWFyZ2luIGlzIGVxdWFsIHRvIDAsIHRoZSBpbml0aWFsIG1hcmdpbiBpcyB1c2VkXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBoZWRnZWRNYXJnaW4gY29udHJhY3Qgc2l6ZSBvciBtYXJnaW4gdmFsdWUgcGVyIG9uZSBsb3Qgb2YgaGVkZ2VkIHBvc2l0aW9ucyAob3Bwb3NpdGVseSBkaXJlY3RlZFxuICAgKiBwb3NpdGlvbnMgb2Ygb25lIHN5bWJvbCkuIFR3byBtYXJnaW4gY2FsY3VsYXRpb24gbWV0aG9kcyBhcmUgcG9zc2libGUgZm9yIGhlZGdlZCBwb3NpdGlvbnMuIFRoZSBjYWxjdWxhdGlvbiBtZXRob2RcbiAgICogaXMgZGVmaW5lZCBieSB0aGUgYnJva2VyXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2hlZGdlZE1hcmdpblVzZXNMYXJnZXJMZWddIGNhbGN1bGF0aW5nIGhlZGdpbmcgbWFyZ2luIHVzaW5nIHRoZSBsYXJnZXIgbGVnIChCdXkgb3IgU2VsbClcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1hcmdpbkN1cnJlbmN5IG1hcmdpbiBjdXJyZW5jeVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcHJpY2VDYWxjdWxhdGlvbk1vZGUgY29udHJhY3QgcHJpY2UgY2FsY3VsYXRpb24gbW9kZS4gT25lIG9mIFNZTUJPTF9DQUxDX01PREVfVU5LTk9XTixcbiAgICogU1lNQk9MX0NBTENfTU9ERV9GT1JFWCwgU1lNQk9MX0NBTENfTU9ERV9GT1JFWF9OT19MRVZFUkFHRSwgU1lNQk9MX0NBTENfTU9ERV9GVVRVUkVTLCBTWU1CT0xfQ0FMQ19NT0RFX0NGRCxcbiAgICogU1lNQk9MX0NBTENfTU9ERV9DRkRJTkRFWCwgU1lNQk9MX0NBTENfTU9ERV9DRkRMRVZFUkFHRSwgU1lNQk9MX0NBTENfTU9ERV9FWENIX1NUT0NLUyxcbiAgICogU1lNQk9MX0NBTENfTU9ERV9FWENIX0ZVVFVSRVMsIFNZTUJPTF9DQUxDX01PREVfRVhDSF9GVVRVUkVTX0ZPUlRTLCBTWU1CT0xfQ0FMQ19NT0RFX0VYQ0hfQk9ORFMsXG4gICAqIFNZTUJPTF9DQUxDX01PREVfRVhDSF9TVE9DS1NfTU9FWCwgU1lNQk9MX0NBTENfTU9ERV9FWENIX0JPTkRTX01PRVgsIFNZTUJPTF9DQUxDX01PREVfU0VSVl9DT0xMQVRFUkFMLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9jYWxjX21vZGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYmFzZUN1cnJlbmN5IGJhc2UgY3VycmVuY3lcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtwcm9maXRDdXJyZW5jeV0gcHJvZml0IGN1cnJlbmN5XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzd2FwTW9kZSBzd2FwIGNhbGN1bGF0aW9uIG1vZGVsLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1lNQk9MX1NXQVBfTU9ERV9ESVNBQkxFRCxcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9QT0lOVFMsIFNZTUJPTF9TV0FQX01PREVfQ1VSUkVOQ1lfU1lNQk9MLCBTWU1CT0xfU1dBUF9NT0RFX0NVUlJFTkNZX01BUkdJTixcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9DVVJSRU5DWV9ERVBPU0lULCBTWU1CT0xfU1dBUF9NT0RFX0lOVEVSRVNUX0NVUlJFTlQsIFNZTUJPTF9TV0FQX01PREVfSU5URVJFU1RfT1BFTixcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9SRU9QRU5fQ1VSUkVOVCwgU1lNQk9MX1NXQVBfTU9ERV9SRU9QRU5fQklELiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9zd2FwX21vZGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N3YXBMb25nXSBsb25nIHN3YXAgdmFsdWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzd2FwU2hvcnRdIHNob3J0IHN3YXAgdmFsdWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzd2FwUm9sbG92ZXIzRGF5c10gZGF5IG9mIHdlZWsgdG8gY2hhcmdlIDMgZGF5cyBzd2FwIHJvbGxvdmVyLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1VOREFZLFxuICAgKiBNT05EQVksIFRVRVNEQVksIFdFRE5FU0RBWSwgVEhVUkRBWSwgRlJJREFZLCBTQVRVUkRBWSwgTk9ORVxuICAgKiBAcHJvcGVydHkge0FycmF5PFN0cmluZz59IGFsbG93ZWRFeHBpcmF0aW9uTW9kZXMgYWxsb3dlZCBvcmRlciBleHBpcmF0aW9uIG1vZGVzLiBBbGxvd2VkIHZhbHVlcyBhcmVcbiAgICogU1lNQk9MX0VYUElSQVRJT05fR1RDLCBTWU1CT0xfRVhQSVJBVElPTl9EQVksIFNZTUJPTF9FWFBJUkFUSU9OX1NQRUNJRklFRCwgU1lNQk9MX0VYUElSQVRJT05fU1BFQ0lGSUVEX0RBWS5cbiAgICogU2VlIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vudmlyb25tZW50X3N0YXRlL21hcmtldGluZm9jb25zdGFudHMjc3ltYm9sX2V4cGlyYXRpb25fbW9kZSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8U3RyaW5nPn0gYWxsb3dlZE9yZGVyVHlwZXMgYWxsb3dlZCBvcmRlciB0eXBlcy4gQWxsb3dlZCB2YWx1ZXMgYXJlIFNZTUJPTF9PUkRFUl9NQVJLRVQsXG4gICAqIFNZTUJPTF9PUkRFUl9MSU1JVCwgU1lNQk9MX09SREVSX1NUT1AsIFNZTUJPTF9PUkRFUl9TVE9QX0xJTUlULCBTWU1CT0xfT1JERVJfU0wsIFNZTUJPTF9PUkRFUl9UUCxcbiAgICogU1lNQk9MX09SREVSX0NMT1NFQlkuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI3N5bWJvbF9vcmRlcl9tb2RlIGZvciBtb3JlIGRldGFpbHNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG9yZGVyR1RDTW9kZSBpZiB0aGUgZXhwaXJhdGlvbk1vZGUgcHJvcGVydHkgaXMgc2V0IHRvIFNZTUJPTF9FWFBJUkFUSU9OX0dUQyAoZ29vZCB0aWxsXG4gICAqIGNhbmNlbGVkKSwgdGhlIGV4cGlyYXRpb24gb2YgcGVuZGluZyBvcmRlcnMsIGFzIHdlbGwgYXMgb2YgU3RvcCBMb3NzL1Rha2UgUHJvZml0IG9yZGVycyBzaG91bGQgYmUgYWRkaXRpb25hbGx5IHNldFxuICAgKiB1c2luZyB0aGlzIGVudW1lcmF0aW9uLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1lNQk9MX09SREVSU19HVEMsIFNZTUJPTF9PUkRFUlNfREFJTFksXG4gICAqIFNZTUJPTF9PUkRFUlNfREFJTFlfRVhDTFVESU5HX1NUT1BTLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9vcmRlcl9ndGNfbW9kZSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkaWdpdHMgZGlnaXRzIGFmdGVyIGEgZGVjaW1hbCBwb2ludFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gcG9pbnQgcG9pbnQgc2l6ZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3BhdGhdIHBhdGggaW4gdGhlIHN5bWJvbCB0cmVlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBzeW1ib2wgZGVzY3JpcHRpb25cbiAgICogQHByb3BlcnR5IHtEYXRlfSBbc3RhcnRUaW1lXSBkYXRlIG9mIHRoZSBzeW1ib2wgdHJhZGUgYmVnaW5uaW5nICh1c3VhbGx5IHVzZWQgZm9yIGZ1dHVyZXMpXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gW2V4cGlyYXRpb25UaW1lXSBkYXRlIG9mIHRoZSBzeW1ib2wgdHJhZGUgZW5kICh1c3VhbGx5IHVzZWQgZm9yIGZ1dHVyZXMpXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGlwU2l6ZV0gc2l6ZSBvZiBhIHBpcC4gUGlwIHNpemUgaXMgZGVmaW5lZCBmb3Igc3BvdCBhbmQgQ0ZEIHN5bWJvbHMgb25seVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RvcHNMZXZlbCBtaW5pbWFsIGluZGVudGlvbiBpbiBwb2ludHMgZnJvbSB0aGUgY3VycmVudCBjbG9zZSBwcmljZSB0byBwbGFjZSBTdG9wIG9yZGVyc1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gZnJlZXplTGV2ZWwgZGlzdGFuY2UgdG8gZnJlZXplIHRyYWRlIG9wZXJhdGlvbnMgaW4gcG9pbnRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhdHJhZGVyIHRyYWRlIG9yIHF1b3RlIHNlc3Npb24gY29udGFpbmVyLCBpbmRleGVkIGJ5IHdlZWtkYXlcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlclNlc3Npb25zXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbU1VOREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgU1VOREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbTU9OREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgTU9OREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbVFVFU0RBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIFRVRVNEQVlcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyU2Vzc2lvbj59IFtXRURORVNEQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBXRURORVNEQVlcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyU2Vzc2lvbj59IFtUSFVSU0RBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIFRIVVJTREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbRlJJREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgRlJJREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbU0FUVVJEQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBTQVRVUkRBWVxuICAgKi9cblxuICAvKipcbiAgICogTWV0YXRyYWRlciB0cmFkZSBvciBxdW90ZSBzZXNzaW9uXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJTZXNzaW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmcm9tIHNlc3Npb24gc3RhcnQgdGltZSwgaW4gaGgubW0uc3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gdG8gc2Vzc2lvbiBlbmQgdGltZSwgaW4gaGgubW0uc3MuU1NTIGZvcm1hdFxuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBzeW1ib2wgcHJpY2UuIENvbnRhaW5zIGN1cnJlbnQgcHJpY2UgZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9tZXRhdHJhZGVyU3ltYm9sUHJpY2UvKVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyU3ltYm9sUHJpY2VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gYSBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gYmlkIGJpZCBwcmljZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gYXNrIGFzayBwcmljZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gcHJvZml0VGlja1ZhbHVlIHRpY2sgdmFsdWUgZm9yIGEgcHJvZml0YWJsZSBwb3NpdGlvblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbG9zc1RpY2tWYWx1ZSB0aWNrIHZhbHVlIGZvciBhIGxvc2luZyBwb3NpdGlvblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2FjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZV0gY3VycmVudCBleGNoYW5nZSByYXRlIG9mIGFjY291bnQgY3VycmVuY3kgaW50byBhY2NvdW50IGJhc2VcbiAgICogY3VycmVuY3kgKFVTRCBpZiB5b3UgZGlkIG5vdCBvdmVycmlkZSBpdClcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIHF1b3RlIHRpbWUsIGluIElTTyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlclRpbWUgdGltZSBxdW90ZSB0aW1lLCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBjYW5kbGVcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlckNhbmRsZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGltZWZyYW1lIHRpbWVmcmFtZSBjYW5kbGUgd2FzIGdlbmVyYXRlZCBmb3IsIGUuZy4gMWguIE9uZSBvZiAxbSwgMm0sIDNtLCA0bSwgNW0sIDZtLCAxMG0sIDEybSxcbiAgICogMTVtLCAyMG0sIDMwbSwgMWgsIDJoLCAzaCwgNGgsIDZoLCA4aCwgMTJoLCAxZCwgMXcsIDFtblxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgY2FuZGxlIG9wZW5pbmcgdGltZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gYnJva2VyVGltZSBjYW5kbGUgb3BlbmluZyB0aW1lLCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gb3BlbiBvcGVuIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIGhpZ2ggcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBsb3cgcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNsb3NlIGNsb3NlIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aWNrVm9sdW1lIHRpY2sgdm9sdW1lLCBpLmUuIG51bWJlciBvZiB0aWNrcyBpbnNpZGUgdGhlIGNhbmRsZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gc3ByZWFkIHNwcmVhZCBpbiBwb2ludHNcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZvbHVtZSB0cmFkZSB2b2x1bWVcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgdGljayBkYXRhXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJUaWNrXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIHRpbWVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJyb2tlclRpbWUgdGltZSwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtiaWRdIGJpZCBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2Fza10gYXNrIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGFzdF0gbGFzdCBkZWFsIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdm9sdW1lXSB2b2x1bWUgZm9yIHRoZSBjdXJyZW50IGxhc3QgZGVhbCBwcmljZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2lkZSBpcyB0aWNrIGEgcmVzdWx0IG9mIGJ1eSBvciBzZWxsIGRlYWwsIG9uZSBvZiBidXkgb3Igc2VsbFxuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBvcmRlciBib29rXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJCb29rXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIHRpbWVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJyb2tlclRpbWUgdGltZSwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyQm9va0VudHJ5Pn0gYm9vayBsaXN0IG9mIG9yZGVyIGJvb2sgZW50cmllc1xuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBvcmRlciBib29rIGVudHJ5XG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJCb29rRW50cnlcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgZW50cnkgdHlwZSwgb25lIG9mIEJPT0tfVFlQRV9TRUxMLCBCT09LX1RZUEVfQlVZLCBCT09LX1RZUEVfU0VMTF9NQVJLRVQsXG4gICAqIEJPT0tfVFlQRV9CVVlfTUFSS0VUXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcmljZSBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdm9sdW1lIHZvbHVtZVxuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSxtYXgtc3RhdGVtZW50c1xuICBhc3luYyBfcHJvY2Vzc1N5bmNocm9uaXphdGlvblBhY2tldChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlTnVtYmVyID0gZGF0YS5pbnN0YW5jZUluZGV4IHx8IDA7XG4gICAgICBjb25zdCBzb2NrZXRJbnN0YW5jZSA9IHRoaXMuX2dldFNvY2tldEluc3RhbmNlQnlBY2NvdW50KGRhdGEuYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcik7XG4gICAgICBpZiAoZGF0YS5zeW5jaHJvbml6YXRpb25JZCAmJiBzb2NrZXRJbnN0YW5jZSkge1xuICAgICAgICBzb2NrZXRJbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIudXBkYXRlU3luY2hyb25pemF0aW9uSWQoZGF0YS5zeW5jaHJvbml6YXRpb25JZCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldEFjY291bnRSZWdpb24oZGF0YS5hY2NvdW50SWQpO1xuICAgICAgY29uc3QgcHJpbWFyeUFjY291bnRJZCA9IHRoaXMuX2FjY291bnRzQnlSZXBsaWNhSWRbZGF0YS5hY2NvdW50SWRdO1xuICAgICAgbGV0IGluc3RhbmNlSWQgPSB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkW2RhdGEuYWNjb3VudElkXSArICc6JyArIFxuICAgICAgICByZWdpb24gKyAnOicgKyBpbnN0YW5jZU51bWJlciArICc6JyArIChkYXRhLmhvc3QgfHwgMCk7XG4gICAgICBsZXQgaW5zdGFuY2VJbmRleCA9IHJlZ2lvbiArICc6JyArIGluc3RhbmNlTnVtYmVyICsgJzonICsgKGRhdGEuaG9zdCB8fCAwKTtcblxuICAgICAgY29uc3QgaXNPbmx5QWN0aXZlSW5zdGFuY2UgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUluc3RhbmNlSWRzID0gT2JqZWN0LmtleXModGhpcy5fY29ubmVjdGVkSG9zdHMpLmZpbHRlcihpbnN0YW5jZSA9PiBcbiAgICAgICAgICBpbnN0YW5jZS5zdGFydHNXaXRoKHByaW1hcnlBY2NvdW50SWQgKyAnOicgKyByZWdpb24gKyAnOicgKyBpbnN0YW5jZU51bWJlcikpO1xuICAgICAgICByZXR1cm4gIWFjdGl2ZUluc3RhbmNlSWRzLmxlbmd0aCB8fCBhY3RpdmVJbnN0YW5jZUlkcy5sZW5ndGggPT09IDEgJiYgYWN0aXZlSW5zdGFuY2VJZHNbMF0gPT09IGluc3RhbmNlSWQ7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjYW5jZWxEaXNjb25uZWN0VGltZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0dXNUaW1lcnNbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RhdHVzVGltZXJzW2luc3RhbmNlSWRdKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzZXREaXNjb25uZWN0VGltZXIgPSAoKSA9PiB7XG4gICAgICAgIGNhbmNlbERpc2Nvbm5lY3RUaW1lcigpO1xuICAgICAgICB0aGlzLl9zdGF0dXNUaW1lcnNbaW5zdGFuY2VJZF0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZihpc09ubHlBY3RpdmVJbnN0YW5jZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLm9uVGltZW91dChkYXRhLmFjY291bnRJZCwgMCk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLm9uVGltZW91dChkYXRhLmFjY291bnRJZCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucXVldWVFdmVudChwcmltYXJ5QWNjb3VudElkLCBgJHtpbnN0YW5jZUluZGV4fTpvbkRpc2Nvbm5lY3RlZGAsICgpID0+IG9uRGlzY29ubmVjdGVkKHRydWUpKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RhdHVzVGltZXJzW2luc3RhbmNlSWRdKTtcbiAgICAgICAgfSwgNjAwMDApO1xuICAgICAgfTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICAgIGNvbnN0IG9uRGlzY29ubmVjdGVkID0gYXN5bmMgKGlzVGltZW91dCA9IGZhbHNlKSA9PiB7IFxuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICB0aGlzLl9sYXRlbmN5U2VydmljZS5vbkRpc2Nvbm5lY3RlZChpbnN0YW5jZUlkKTtcbiAgICAgICAgICBpZihpc09ubHlBY3RpdmVJbnN0YW5jZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3RlZFByb21pc2VzID0gW107XG4gICAgICAgICAgICBpZighaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIG9uRGlzY29ubmVjdGVkUHJvbWlzZXMucHVzaCh0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLm9uRGlzY29ubmVjdGVkKGRhdGEuYWNjb3VudElkLCAwKSk7XG4gICAgICAgICAgICAgIG9uRGlzY29ubmVjdGVkUHJvbWlzZXMucHVzaCh0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLm9uRGlzY29ubmVjdGVkKGRhdGEuYWNjb3VudElkLCAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgICAgb25EaXNjb25uZWN0ZWRQcm9taXNlcy5wdXNoKHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkRpc2Nvbm5lY3RlZChpbnN0YW5jZUluZGV4KSxcbiAgICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uRGlzY29ubmVjdGVkYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25EaXNjb25uZWN0ZWRQcm9taXNlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9uU3RyZWFtQ2xvc2VkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9wYWNrZXRPcmRlcmVyLm9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSWQpO1xuICAgICAgICAgIGlmKHNvY2tldEluc3RhbmNlKSB7XG4gICAgICAgICAgICBzb2NrZXRJbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIucmVtb3ZlSWRCeVBhcmFtZXRlcnMoZGF0YS5hY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBkYXRhLmhvc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uU3RyZWFtQ2xvc2VkUHJvbWlzZXMucHVzaCh0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSW5kZXgpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uU3RyZWFtQ2xvc2VkYCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN0cmVhbUNsb3NlZFByb21pc2VzKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnYXV0aGVudGljYXRlZCcpIHtcbiAgICAgICAgcmVzZXREaXNjb25uZWN0VGltZXIoKTtcbiAgICAgICAgaWYoKCFkYXRhLnNlc3Npb25JZCkgfHwgc29ja2V0SW5zdGFuY2UgJiYgKGRhdGEuc2Vzc2lvbklkID09PSBzb2NrZXRJbnN0YW5jZS5zZXNzaW9uSWQpKSB7XG4gICAgICAgICAgdGhpcy5fbGF0ZW5jeVNlcnZpY2Uub25Db25uZWN0ZWQoaW5zdGFuY2VJZCk7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF0gPSBkYXRhLmhvc3Q7XG4gICAgICAgICAgY29uc3Qgb25Db25uZWN0ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgb25Db25uZWN0ZWRQcm9taXNlcy5wdXNoKHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25Db25uZWN0ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5yZXBsaWNhcyksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25Db25uZWN0ZWRgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsU3Vic2NyaWJlKGRhdGEuYWNjb3VudElkICsgJzonICsgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgIGlmKGRhdGEucmVwbGljYXMgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsQWNjb3VudChkYXRhLmFjY291bnRJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsU3Vic2NyaWJlKGRhdGEuYWNjb3VudElkICsgJzonICsgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkNvbm5lY3RlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgIGNhbmNlbERpc2Nvbm5lY3RUaW1lcigpO1xuICAgICAgICBhd2FpdCBvbkRpc2Nvbm5lY3RlZCgpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdzeW5jaHJvbml6YXRpb25TdGFydGVkJykge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSA9IHtcbiAgICAgICAgICBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLFxuICAgICAgICAgIGluc3RhbmNlTnVtYmVyLFxuICAgICAgICAgIHBvc2l0aW9uc1VwZGF0ZWQ6IGRhdGEucG9zaXRpb25zVXBkYXRlZCAhPT0gdW5kZWZpbmVkID8gZGF0YS5wb3NpdGlvbnNVcGRhdGVkIDogdHJ1ZSxcbiAgICAgICAgICBvcmRlcnNVcGRhdGVkOiBkYXRhLm9yZGVyc1VwZGF0ZWQgIT09IHVuZGVmaW5lZCA/IGRhdGEub3JkZXJzVXBkYXRlZCA6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdID0gZGF0YS5zeW5jaHJvbml6YXRpb25JZDtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblN5bmNocm9uaXphdGlvblN0YXJ0ZWQoaW5zdGFuY2VJbmRleCxcbiAgICAgICAgICAgICAgZGF0YS5zcGVjaWZpY2F0aW9uc1VwZGF0ZWQgIT09IHVuZGVmaW5lZCA/IGRhdGEuc3BlY2lmaWNhdGlvbnNVcGRhdGVkIDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbnNVcGRhdGVkICE9PSB1bmRlZmluZWQgPyBkYXRhLnBvc2l0aW9uc1VwZGF0ZWQgOiB0cnVlLFxuICAgICAgICAgICAgICBkYXRhLm9yZGVyc1VwZGF0ZWQgIT09IHVuZGVmaW5lZCA/IGRhdGEub3JkZXJzVXBkYXRlZCA6IHRydWUsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblN5bmNocm9uaXphdGlvblN0YXJ0ZWRgKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdhY2NvdW50SW5mb3JtYXRpb24nKSB7XG4gICAgICAgIGlmIChkYXRhLnN5bmNocm9uaXphdGlvbklkICYmIGRhdGEuc3luY2hyb25pemF0aW9uSWQgIT09IHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5hY2NvdW50SW5mb3JtYXRpb24pIHtcbiAgICAgICAgICBjb25zdCBvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIGRhdGEuYWNjb3VudEluZm9ybWF0aW9uKSxcbiAgICAgICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0gJiYgXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXS5wb3NpdGlvbnNVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUG9zaXRpb25zU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUG9zaXRpb25zU3luY2hyb25pemVkYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICBpZighdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ub3JkZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgYWNjb3VudEluZm9ybWF0aW9uIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZFByb21pc2VzKTtcbiAgICAgICAgICBpZih0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSAmJiBcbiAgICAgICAgICAgICAgIXRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdLnBvc2l0aW9uc1VwZGF0ZWQgJiYgXG4gICAgICAgICAgICAgICF0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXS5vcmRlcnNVcGRhdGVkKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2RlYWxzJykge1xuICAgICAgICBpZiAoZGF0YS5zeW5jaHJvbml6YXRpb25JZCAmJiBkYXRhLnN5bmNocm9uaXphdGlvbklkICE9PSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZGVhbCBvZiAoZGF0YS5kZWFscyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvbkRlYWxBZGRlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbkRlYWxBZGRlZFByb21pc2VzLnB1c2godGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkRlYWxBZGRlZChpbnN0YW5jZUluZGV4LCBkZWFsKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkRlYWxBZGRlZGApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25EZWFsQWRkZWRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnb3JkZXJzJykge1xuICAgICAgICBpZiAoZGF0YS5zeW5jaHJvbml6YXRpb25JZCAmJiBkYXRhLnN5bmNocm9uaXphdGlvbklkICE9PSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25QZW5kaW5nT3JkZXJzUmVwbGFjZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICBvblBlbmRpbmdPcmRlcnNSZXBsYWNlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUGVuZGluZ09yZGVyc1JlcGxhY2VkKGluc3RhbmNlSW5kZXgsIGRhdGEub3JkZXJzIHx8IFtdKSxcbiAgICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUGVuZGluZ09yZGVyc1JlcGxhY2VkYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCksXG4gICAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWRgLCB0cnVlKTtcbiAgICAgICAgICAgIH0pKCkpXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgJ2Fib3V0IG9yZGVycyBldmVudCcsIGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblBlbmRpbmdPcmRlcnNSZXBsYWNlZFByb21pc2VzKTtcbiAgICAgICAgaWYodGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnaGlzdG9yeU9yZGVycycpIHtcbiAgICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgZGF0YS5zeW5jaHJvbml6YXRpb25JZCAhPT0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGhpc3RvcnlPcmRlciBvZiAoZGF0YS5oaXN0b3J5T3JkZXJzIHx8IFtdKSkge1xuICAgICAgICAgIGNvbnN0IG9uSGlzdG9yeU9yZGVyQWRkZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgb25IaXN0b3J5T3JkZXJBZGRlZFByb21pc2VzLnB1c2godGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkhpc3RvcnlPcmRlckFkZGVkKGluc3RhbmNlSW5kZXgsIGhpc3RvcnlPcmRlciksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25IaXN0b3J5T3JkZXJBZGRlZGApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25IaXN0b3J5T3JkZXJBZGRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdwb3NpdGlvbnMnKSB7XG4gICAgICAgIGlmIChkYXRhLnN5bmNocm9uaXphdGlvbklkICYmIGRhdGEuc3luY2hyb25pemF0aW9uSWQgIT09IHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvblBvc2l0aW9uc1JlcGxhY2VkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgb25Qb3NpdGlvbnNSZXBsYWNlZFByb21pc2VzLnB1c2goUHJvbWlzZS5yZXNvbHZlKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUG9zaXRpb25zUmVwbGFjZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5wb3NpdGlvbnMgfHwgW10pLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUG9zaXRpb25zUmVwbGFjZWRgLCB0cnVlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25Qb3NpdGlvbnNTeW5jaHJvbml6ZWRgLCB0cnVlKTtcbiAgICAgICAgICAgIGlmKHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdICYmIFxuICAgICAgICAgICAgICAhdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ub3JkZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkYCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKSlcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICdhYm91dCBwb3NpdGlvbnMgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25Qb3NpdGlvbnNSZXBsYWNlZFByb21pc2VzKTtcbiAgICAgICAgaWYodGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0gJiYgXG4gICAgICAgICAgIXRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdLm9yZGVyc1VwZGF0ZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAndXBkYXRlJykge1xuICAgICAgICBpZiAoZGF0YS5hY2NvdW50SW5mb3JtYXRpb24pIHtcbiAgICAgICAgICBjb25zdCBvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMucHVzaCh0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZChpbnN0YW5jZUluZGV4LCBkYXRhLmFjY291bnRJbmZvcm1hdGlvbiksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkYCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcG9zaXRpb24gb2YgKGRhdGEudXBkYXRlZFBvc2l0aW9ucyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvblBvc2l0aW9uVXBkYXRlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvblBvc2l0aW9uVXBkYXRlZFByb21pc2VzLnB1c2godGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblBvc2l0aW9uVXBkYXRlZChpbnN0YW5jZUluZGV4LCBwb3NpdGlvbiksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25Qb3NpdGlvblVwZGF0ZWRgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uUG9zaXRpb25VcGRhdGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHBvc2l0aW9uSWQgb2YgKGRhdGEucmVtb3ZlZFBvc2l0aW9uSWRzIHx8IFtdKSkge1xuICAgICAgICAgIGNvbnN0IG9uUG9zaXRpb25SZW1vdmVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uUG9zaXRpb25SZW1vdmVkUHJvbWlzZXMucHVzaCh0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUG9zaXRpb25SZW1vdmVkKGluc3RhbmNlSW5kZXgsIHBvc2l0aW9uSWQpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUG9zaXRpb25SZW1vdmVkYCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblBvc2l0aW9uUmVtb3ZlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvcmRlciBvZiAoZGF0YS51cGRhdGVkT3JkZXJzIHx8IFtdKSkge1xuICAgICAgICAgIGNvbnN0IG9uUGVuZGluZ09yZGVyVXBkYXRlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvblBlbmRpbmdPcmRlclVwZGF0ZWRQcm9taXNlcy5wdXNoKHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25QZW5kaW5nT3JkZXJVcGRhdGVkKGluc3RhbmNlSW5kZXgsIG9yZGVyKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBlbmRpbmdPcmRlclVwZGF0ZWRgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uUGVuZGluZ09yZGVyVXBkYXRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvcmRlcklkIG9mIChkYXRhLmNvbXBsZXRlZE9yZGVySWRzIHx8IFtdKSkge1xuICAgICAgICAgIGNvbnN0IG9uUGVuZGluZ09yZGVyQ29tcGxldGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uUGVuZGluZ09yZGVyQ29tcGxldGVkUHJvbWlzZXMucHVzaCh0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUGVuZGluZ09yZGVyQ29tcGxldGVkKGluc3RhbmNlSW5kZXgsIG9yZGVySWQpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUGVuZGluZ09yZGVyQ29tcGxldGVkYCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblBlbmRpbmdPcmRlckNvbXBsZXRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBoaXN0b3J5T3JkZXIgb2YgKGRhdGEuaGlzdG9yeU9yZGVycyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvbkhpc3RvcnlPcmRlckFkZGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uSGlzdG9yeU9yZGVyQWRkZWRQcm9taXNlcy5wdXNoKHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25IaXN0b3J5T3JkZXJBZGRlZChpbnN0YW5jZUluZGV4LCBoaXN0b3J5T3JkZXIpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uSGlzdG9yeU9yZGVyQWRkZWRgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uSGlzdG9yeU9yZGVyQWRkZWRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZGVhbCBvZiAoZGF0YS5kZWFscyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvbkRlYWxBZGRlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbkRlYWxBZGRlZFByb21pc2VzLnB1c2godGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkRlYWxBZGRlZChpbnN0YW5jZUluZGV4LCBkZWFsKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkRlYWxBZGRlZGApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25EZWFsQWRkZWRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudGltZXN0YW1wcykge1xuICAgICAgICAgIGRhdGEudGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nRmluaXNoZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IG9uVXBkYXRlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fbGF0ZW5jeUxpc3RlbmVycyB8fCBbXSkge1xuICAgICAgICAgICAgb25VcGRhdGVQcm9taXNlcy5wdXNoKHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25VcGRhdGUoZGF0YS5hY2NvdW50SWQsIGRhdGEudGltZXN0YW1wcyksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25VcGRhdGVgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uVXBkYXRlUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2RlYWxTeW5jaHJvbml6YXRpb25GaW5pc2hlZCcpIHtcbiAgICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgZGF0YS5zeW5jaHJvbml6YXRpb25JZCAhPT0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF0ZW5jeVNlcnZpY2Uub25EZWFsc1N5bmNocm9uaXplZChpbnN0YW5jZUlkKTtcbiAgICAgICAgY29uc3Qgb25EZWFsc1N5bmNocm9uaXplZFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIGlmKHNvY2tldEluc3RhbmNlKSB7XG4gICAgICAgICAgICBzb2NrZXRJbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIucmVtb3ZlU3luY2hyb25pemF0aW9uSWQoZGF0YS5zeW5jaHJvbml6YXRpb25JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uRGVhbHNTeW5jaHJvbml6ZWRQcm9taXNlcy5wdXNoKHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uRGVhbHNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCksXG4gICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uRGVhbHNTeW5jaHJvbml6ZWRgKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25EZWFsc1N5bmNocm9uaXplZFByb21pc2VzKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnb3JkZXJTeW5jaHJvbml6YXRpb25GaW5pc2hlZCcpIHtcbiAgICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgZGF0YS5zeW5jaHJvbml6YXRpb25JZCAhPT0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uSGlzdG9yeU9yZGVyc1N5bmNocm9uaXplZFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIG9uSGlzdG9yeU9yZGVyc1N5bmNocm9uaXplZFByb21pc2VzLnB1c2godGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkhpc3RvcnlPcmRlcnNTeW5jaHJvbml6ZWRgKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkUHJvbWlzZXMpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICBpZih0aGlzLl9zdGF0dXNUaW1lcnNbaW5zdGFuY2VJZF0gJiYgZGF0YS5hdXRoZW50aWNhdGVkICYmIFxuICAgICAgICAgICAgICAodGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5pc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZShkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpIHx8IFxuICAgICAgICAgICAgICAhdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5pc0FjY291bnRTdWJzY3JpYmluZyhkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpKSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5jYW5jZWxTdWJzY3JpYmUoZGF0YS5hY2NvdW50SWQgKyAnOicgKyBpbnN0YW5jZU51bWJlcik7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwKSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oJ2l0IHNlZW1zIGxpa2Ugd2UgYXJlIG5vdCBjb25uZWN0ZWQgdG8gYSBydW5uaW5nIEFQSSAnICtcbiAgICAgICAgICAgICAgJ3NlcnZlciB5ZXQsIHJldHJ5aW5nIHN1YnNjcmlwdGlvbiBmb3IgYWNjb3VudCAnICsgaW5zdGFuY2VJZCk7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZVN1YnNjcmliZShkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldERpc2Nvbm5lY3RUaW1lcigpO1xuICAgICAgICAgIGNvbnN0IG9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgb25Ccm9rZXJDb25uZWN0aW9uU3RhdHVzQ2hhbmdlZFByb21pc2VzLnB1c2godGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkKGluc3RhbmNlSW5kZXgsICEhZGF0YS5jb25uZWN0ZWQpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWRgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWRQcm9taXNlcyk7XG4gICAgICAgICAgaWYgKGRhdGEuaGVhbHRoU3RhdHVzKSB7XG4gICAgICAgICAgICBjb25zdCBvbkhlYWx0aFN0YXR1c1Byb21pc2VzID0gW107XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgICAgb25IZWFsdGhTdGF0dXNQcm9taXNlcy5wdXNoKHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkhlYWx0aFN0YXR1cyhpbnN0YW5jZUluZGV4LCBkYXRhLmhlYWx0aFN0YXR1cyksXG4gICAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkhlYWx0aFN0YXR1c2ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uSGVhbHRoU3RhdHVzUHJvbWlzZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdkb3duZ3JhZGVTdWJzY3JpcHRpb24nKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IE1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgZm9yIHN5bWJvbCBgICtcbiAgICAgICAgICBgJHtkYXRhLnN5bWJvbH0gd2VyZSBkb3duZ3JhZGVkIGJ5IHRoZSBzZXJ2ZXIgZHVlIHRvIHJhdGUgbGltaXRzLiBVcGRhdGVkIHN1YnNjcmlwdGlvbnM6IGAgK1xuICAgICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGRhdGEudXBkYXRlcyl9LCByZW1vdmVkIHN1YnNjcmlwdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YS51bnN1YnNjcmlwdGlvbnMpfS4gYCArXG4gICAgICAgICAgJ1BsZWFzZSByZWFkIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9yYXRlTGltaXRpbmcvIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICAgIGNvbnN0IG9uU3Vic2NyaXB0aW9uRG93bmdyYWRlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgb25TdWJzY3JpcHRpb25Eb3duZ3JhZGVQcm9taXNlcy5wdXNoKHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZChpbnN0YW5jZUluZGV4LCBkYXRhLnN5bWJvbCwgZGF0YS51cGRhdGVzLCBkYXRhLnVuc3Vic2NyaXB0aW9ucyksXG4gICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZGApKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN1YnNjcmlwdGlvbkRvd25ncmFkZVByb21pc2VzKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnc3BlY2lmaWNhdGlvbnMnKSB7XG4gICAgICAgIGlmIChkYXRhLnN5bmNocm9uaXphdGlvbklkICYmIGRhdGEuc3luY2hyb25pemF0aW9uSWQgIT09IHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIG9uU3ltYm9sU3BlY2lmaWNhdGlvbnNVcGRhdGVkUHJvbWlzZXMucHVzaCh0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZChpbnN0YW5jZUluZGV4LCBkYXRhLnNwZWNpZmljYXRpb25zIHx8IFtdLFxuICAgICAgICAgICAgICBkYXRhLnJlbW92ZWRTeW1ib2xzIHx8IFtdKSwgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZGApKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZFByb21pc2VzKTtcbiAgICAgICAgZm9yIChsZXQgc3BlY2lmaWNhdGlvbiBvZiAoZGF0YS5zcGVjaWZpY2F0aW9ucyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvblN5bWJvbFNwZWNpZmljYXRpb25VcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uU3ltYm9sU3BlY2lmaWNhdGlvblVwZGF0ZWRQcm9taXNlcy5wdXNoKHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZChpbnN0YW5jZUluZGV4LCBzcGVjaWZpY2F0aW9uKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblN5bWJvbFNwZWNpZmljYXRpb25VcGRhdGVkYCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN5bWJvbFNwZWNpZmljYXRpb25VcGRhdGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHJlbW92ZWRTeW1ib2wgb2YgKGRhdGEucmVtb3ZlZFN5bWJvbHMgfHwgW10pKSB7XG4gICAgICAgICAgY29uc3Qgb25TeW1ib2xTcGVjaWZpY2F0aW9uUmVtb3ZlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkUHJvbWlzZXMucHVzaCh0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uU3ltYm9sU3BlY2lmaWNhdGlvblJlbW92ZWQoaW5zdGFuY2VJbmRleCwgcmVtb3ZlZFN5bWJvbCksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25TeW1ib2xTcGVjaWZpY2F0aW9uUmVtb3ZlZGApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25TeW1ib2xTcGVjaWZpY2F0aW9uUmVtb3ZlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdwcmljZXMnKSB7XG4gICAgICAgIGlmIChkYXRhLnN5bmNocm9uaXphdGlvbklkICYmIGRhdGEuc3luY2hyb25pemF0aW9uSWQgIT09IHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJpY2VzID0gZGF0YS5wcmljZXMgfHwgW107XG4gICAgICAgIGxldCBjYW5kbGVzID0gZGF0YS5jYW5kbGVzIHx8IFtdO1xuICAgICAgICBsZXQgdGlja3MgPSBkYXRhLnRpY2tzIHx8IFtdO1xuICAgICAgICBsZXQgYm9va3MgPSBkYXRhLmJvb2tzIHx8IFtdO1xuICAgICAgICBjb25zdCBvblN5bWJvbFByaWNlc1VwZGF0ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICBpZiAocHJpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgb25TeW1ib2xQcmljZXNVcGRhdGVkUHJvbWlzZXMucHVzaCh0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uU3ltYm9sUHJpY2VzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBwcmljZXMsIGRhdGEuZXF1aXR5LCBkYXRhLm1hcmdpbiwgZGF0YS5mcmVlTWFyZ2luLFxuICAgICAgICAgICAgICAgIGRhdGEubWFyZ2luTGV2ZWwsIGRhdGEuYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblN5bWJvbFByaWNlc1VwZGF0ZWRgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgb25TeW1ib2xQcmljZXNVcGRhdGVkUHJvbWlzZXMucHVzaCh0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uQ2FuZGxlc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgY2FuZGxlcywgZGF0YS5lcXVpdHksIGRhdGEubWFyZ2luLCBkYXRhLmZyZWVNYXJnaW4sXG4gICAgICAgICAgICAgICAgZGF0YS5tYXJnaW5MZXZlbCwgZGF0YS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uQ2FuZGxlc1VwZGF0ZWRgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9uU3ltYm9sUHJpY2VzVXBkYXRlZFByb21pc2VzLnB1c2godGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblRpY2tzVXBkYXRlZChpbnN0YW5jZUluZGV4LCB0aWNrcywgZGF0YS5lcXVpdHksIGRhdGEubWFyZ2luLCBkYXRhLmZyZWVNYXJnaW4sXG4gICAgICAgICAgICAgICAgZGF0YS5tYXJnaW5MZXZlbCwgZGF0YS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uVGlja3NVcGRhdGVkYCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYm9va3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvblN5bWJvbFByaWNlc1VwZGF0ZWRQcm9taXNlcy5wdXNoKHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25Cb29rc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgYm9va3MsIGRhdGEuZXF1aXR5LCBkYXRhLm1hcmdpbiwgZGF0YS5mcmVlTWFyZ2luLFxuICAgICAgICAgICAgICAgIGRhdGEubWFyZ2luTGV2ZWwsIGRhdGEuYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkJvb2tzVXBkYXRlZGApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25TeW1ib2xQcmljZXNVcGRhdGVkUHJvbWlzZXMpO1xuICAgICAgICBmb3IgKGxldCBwcmljZSBvZiBwcmljZXMpIHtcbiAgICAgICAgICBjb25zdCBvblN5bWJvbFByaWNlVXBkYXRlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvblN5bWJvbFByaWNlVXBkYXRlZFByb21pc2VzLnB1c2godGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblN5bWJvbFByaWNlVXBkYXRlZChpbnN0YW5jZUluZGV4LCBwcmljZSksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25TeW1ib2xQcmljZVVwZGF0ZWRgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uU3ltYm9sUHJpY2VVcGRhdGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByaWNlIG9mIHByaWNlcykge1xuICAgICAgICAgIGlmIChwcmljZS50aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICBwcmljZS50aW1lc3RhbXBzLmNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBvblN5bWJvbFByaWNlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMgfHwgW10pIHtcbiAgICAgICAgICAgICAgb25TeW1ib2xQcmljZVByb21pc2VzLnB1c2godGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uU3ltYm9sUHJpY2UoZGF0YS5hY2NvdW50SWQsIHByaWNlLnN5bWJvbCwgcHJpY2UudGltZXN0YW1wcyksXG4gICAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblN5bWJvbFByaWNlYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25TeW1ib2xQcmljZVByb21pc2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgaW5jb21pbmcgc3luY2hyb25pemF0aW9uIHBhY2tldCcsIGVycik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX3Byb2Nlc3NFdmVudChjYWxsYWJsZSwgbGFiZWwsIHRocm93RXJyb3IpIHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBpc0xvbmdFdmVudCA9IGZhbHNlO1xuICAgIGxldCBpc0V2ZW50RG9uZSA9IGZhbHNlO1xuXG4gICAgY29uc3QgY2hlY2tMb25nRXZlbnQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMDApKTtcbiAgICAgIGlmICghaXNFdmVudERvbmUpIHtcbiAgICAgICAgaXNMb25nRXZlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgJHtsYWJlbH06IGV2ZW50IGlzIHRha2luZyBtb3JlIHRoYW4gMSBzZWNvbmQgdG8gcHJvY2Vzc2ApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjaGVja0xvbmdFdmVudCgpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjYWxsYWJsZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRocm93RXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke2xhYmVsfTogZXZlbnQgZmFpbGVkIHdpdGggZXJyb3JgLCBlcnIpO1xuICAgIH1cbiAgICBpc0V2ZW50RG9uZSA9IHRydWU7XG4gICAgaWYgKGlzTG9uZ0V2ZW50KSB7XG4gICAgICB0aGlzLl9sb2dnZXIud2FybihgJHtsYWJlbH06IGZpbmlzaGVkIGluICR7TWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwKX0gc2Vjb25kc2ApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9maXJlUmVjb25uZWN0ZWQoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZWNvbm5lY3RMaXN0ZW5lcnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3JlY29ubmVjdExpc3RlbmVycykge1xuICAgICAgICBpZiAodGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bbGlzdGVuZXIuYWNjb3VudElkXSA9PT0gc29ja2V0SW5zdGFuY2VJbmRleCAmJiBcbiAgICAgICAgICB0aGlzLmdldEFjY291bnRSZWdpb24obGlzdGVuZXIuYWNjb3VudElkKSA9PT0gcmVnaW9uKSB7XG4gICAgICAgICAgcmVjb25uZWN0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFncykuZm9yRWFjaChzeW5jaHJvbml6YXRpb25JZCA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnRJZCA9IHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW3N5bmNocm9uaXphdGlvbklkXS5hY2NvdW50SWQ7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdID09PSBzb2NrZXRJbnN0YW5jZUluZGV4XG4gICAgICAgICAgJiYgdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3Nbc3luY2hyb25pemF0aW9uSWRdLmluc3RhbmNlTnVtYmVyID09PSBpbnN0YW5jZU51bWJlclxuICAgICAgICAgICYmIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF1cbiAgICAgICAgICAmJiB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1thY2NvdW50SWRdLnJlZ2lvbiA9PT0gcmVnaW9uKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW3N5bmNocm9uaXphdGlvbklkXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZWNvbm5lY3RBY2NvdW50SWRzID0gcmVjb25uZWN0TGlzdGVuZXJzLm1hcChsaXN0ZW5lciA9PiBsaXN0ZW5lci5hY2NvdW50SWQpO1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5vblJlY29ubmVjdGVkKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWNvbm5lY3RBY2NvdW50SWRzKTtcbiAgICAgIHRoaXMuX3BhY2tldE9yZGVyZXIub25SZWNvbm5lY3RlZChyZWNvbm5lY3RBY2NvdW50SWRzKTtcblxuICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgcmVjb25uZWN0TGlzdGVuZXJzKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5saXN0ZW5lci5vblJlY29ubmVjdGVkKHJlZ2lvbiwgaW5zdGFuY2VOdW1iZXIpKVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gbm90aWZ5IHJlY29ubmVjdCBsaXN0ZW5lcicsIGVycikpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyByZWNvbm5lY3RlZCBldmVudCcsIGVycik7XG4gICAgfVxuICB9XG5cbiAgX2dldFNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpIHtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKTtcbiAgICByZXR1cm4gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3RoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF1dO1xuICB9XG5cbiAgYXN5bmMgZ2V0VXJsU2V0dGluZ3MoaW5zdGFuY2VOdW1iZXIsIHJlZ2lvbikge1xuICAgIGlmKHRoaXMuX3VybCkge1xuICAgICAgcmV0dXJuIHt1cmw6IHRoaXMuX3VybCwgaXNTaGFyZWRDbGllbnRBcGk6IHRydWV9O1xuICAgIH1cblxuICAgIGNvbnN0IHVybFNldHRpbmdzID0gYXdhaXQgdGhpcy5fZG9tYWluQ2xpZW50LmdldFNldHRpbmdzKCk7XG4gICAgY29uc3QgZ2V0VXJsID0gKGhvc3RuYW1lKSA9PiBcbiAgICAgIGBodHRwczovLyR7aG9zdG5hbWV9LiR7cmVnaW9ufS0ke1N0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBOdW1iZXIoaW5zdGFuY2VOdW1iZXIpKX0uJHt1cmxTZXR0aW5ncy5kb21haW59YDtcblxuICAgIGxldCB1cmw7XG4gICAgaWYodGhpcy5fdXNlU2hhcmVkQ2xpZW50QXBpKSB7XG4gICAgICB1cmwgPSBnZXRVcmwodGhpcy5faG9zdG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cmwgPSBnZXRVcmwodXJsU2V0dGluZ3MuaG9zdG5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBpc1NoYXJlZENsaWVudEFwaSA9IHVybCA9PT0gZ2V0VXJsKHRoaXMuX2hvc3RuYW1lKTtcbiAgICByZXR1cm4ge3VybCwgaXNTaGFyZWRDbGllbnRBcGl9O1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgYXN5bmMgX2dldFNlcnZlclVybChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKSB7XG4gICAgaWYodGhpcy5fdXJsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXJsO1xuICAgIH1cblxuICAgIHdoaWxlKHRoaXMuc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdLmNvbm5lY3RlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsU2V0dGluZ3MgPSBhd2FpdCB0aGlzLmdldFVybFNldHRpbmdzKGluc3RhbmNlTnVtYmVyLCByZWdpb24pO1xuICAgICAgICBjb25zdCB1cmwgPSB1cmxTZXR0aW5ncy51cmw7XG4gICAgICAgIGNvbnN0IGlzU2hhcmVkQ2xpZW50QXBpID0gdXJsU2V0dGluZ3MuaXNTaGFyZWRDbGllbnRBcGk7XG4gICAgICAgIGxldCBsb2dNZXNzYWdlID0gJ0Nvbm5lY3RpbmcgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IHRvIHRoZSBNZXRhQXBpIHNlcnZlciAnICtcbiAgICAgIGB2aWEgJHt1cmx9ICR7aXNTaGFyZWRDbGllbnRBcGkgPyAnc2hhcmVkJyA6ICdkZWRpY2F0ZWQnfSBzZXJ2ZXIuYDtcbiAgICAgICAgaWYodGhpcy5fZmlyc3RDb25uZWN0ICYmICFpc1NoYXJlZENsaWVudEFwaSkge1xuICAgICAgICAgIGxvZ01lc3NhZ2UgKz0gJyBQbGVhc2Ugbm90ZSB0aGF0IGl0IGNhbiB0YWtlIHVwIHRvIDMgbWludXRlcyBmb3IgeW91ciBkZWRpY2F0ZWQgc2VydmVyIHRvIHN0YXJ0IGZvciB0aGUgJyArXG4gICAgICAgICdmaXJzdCB0aW1lLiBEdXJpbmcgdGhpcyB0aW1lIGl0IGlzIE9LIGlmIHlvdSBzZWUgc29tZSBjb25uZWN0aW9uIGVycm9ycy4nO1xuICAgICAgICAgIHRoaXMuX2ZpcnN0Q29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGxvZ01lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignRmFpbGVkIHRvIHJldHJpZXZlIHNlcnZlciBVUkwnLCBlcnIpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMDApKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfdGhyb3R0bGVSZXF1ZXN0KHR5cGUsIGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHRpbWVJbk1zKSB7XG4gICAgdGhpcy5fbGFzdFJlcXVlc3RzVGltZVtpbnN0YW5jZU51bWJlcl0gPSB0aGlzLl9sYXN0UmVxdWVzdHNUaW1lW2luc3RhbmNlTnVtYmVyXSB8fCB7fTtcbiAgICB0aGlzLl9sYXN0UmVxdWVzdHNUaW1lW2luc3RhbmNlTnVtYmVyXVt0eXBlXSA9IHRoaXMuX2xhc3RSZXF1ZXN0c1RpbWVbaW5zdGFuY2VOdW1iZXJdW3R5cGVdIHx8IHt9O1xuICAgIGxldCBsYXN0VGltZSA9IHRoaXMuX2xhc3RSZXF1ZXN0c1RpbWVbaW5zdGFuY2VOdW1iZXJdW3R5cGVdW2FjY291bnRJZF07XG4gICAgaWYgKCFsYXN0VGltZSB8fCAobGFzdFRpbWUgPCBEYXRlLm5vdygpIC0gdGltZUluTXMpKSB7XG4gICAgICB0aGlzLl9sYXN0UmVxdWVzdHNUaW1lW2luc3RhbmNlTnVtYmVyXVt0eXBlXVthY2NvdW50SWRdID0gRGF0ZS5ub3coKTtcbiAgICAgIHJldHVybiAhIWxhc3RUaW1lO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfcmVmcmVzaEFjY291bnRSZWdpb24oYWNjb3VudElkKSB7XG4gICAgaWYodGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXSkge1xuICAgICAgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXS5sYXN0VXNlZCA9IERhdGUubm93KCk7XG4gICAgfVxuICB9XG5cbiAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBhc3luYyBfY3JlYXRlU29ja2V0SW5zdGFuY2VCeUFjY291bnQoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIGlmICh0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBzb2NrZXRJbnN0YW5jZUluZGV4ID0gbnVsbDtcbiAgICAgIHdoaWxlICh0aGlzLl9zdWJzY3JpYmVMb2NrICYmICgobmV3IERhdGUodGhpcy5fc3Vic2NyaWJlTG9jay5yZWNvbW1lbmRlZFJldHJ5VGltZSkuZ2V0VGltZSgpID4gRGF0ZS5ub3coKSAmJiBcbiAgICAgICAgICB0aGlzLnN1YnNjcmliZWRBY2NvdW50SWRzKGluc3RhbmNlTnVtYmVyLCB1bmRlZmluZWQsIHJlZ2lvbikubGVuZ3RoIDwgXG4gICAgICAgICAgdGhpcy5fc3Vic2NyaWJlTG9jay5sb2NrZWRBdEFjY291bnRzKSB8fCBcbiAgICAgICAgICAobmV3IERhdGUodGhpcy5fc3Vic2NyaWJlTG9jay5sb2NrZWRBdFRpbWUpLmdldFRpbWUoKSArIHRoaXMuX3N1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzICogMTAwMCA+IFxuICAgICAgICAgIERhdGUubm93KCkgJiYgdGhpcy5zdWJzY3JpYmVkQWNjb3VudElkcyhpbnN0YW5jZU51bWJlciwgdW5kZWZpbmVkLCByZWdpb24pLmxlbmd0aCA+PSBcbiAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVMb2NrLmxvY2tlZEF0QWNjb3VudHMpKSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMDApKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRDb3VudGVyID0gdGhpcy5nZXRBc3NpZ25lZEFjY291bnRzKGluc3RhbmNlTnVtYmVyLCBpbmRleCwgcmVnaW9uKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl1baW5kZXhdO1xuICAgICAgICBpZiAoaW5zdGFuY2Uuc3Vic2NyaWJlTG9jaykge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLnR5cGUgPT09ICdMSU1JVF9BQ0NPVU5UX1NVQlNDUklQVElPTlNfUEVSX1VTRVJfUEVSX1NFUlZFUicgJiYgXG4gICAgICAgICAgICAobmV3IERhdGUoaW5zdGFuY2Uuc3Vic2NyaWJlTG9jay5yZWNvbW1lbmRlZFJldHJ5VGltZSkuZ2V0VGltZSgpID4gRGF0ZS5ub3coKSB8fCBcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoaW5zdGFuY2VOdW1iZXIsIGluZGV4LCByZWdpb24pLmxlbmd0aCA+PSBcbiAgICAgICAgICAgIGluc3RhbmNlLnN1YnNjcmliZUxvY2subG9ja2VkQXRBY2NvdW50cykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3Vic2NyaWJlTG9jay50eXBlID09PSAnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9TRVJWRVInICYmIFxuICAgICAgICAgICAgbmV3IERhdGUoaW5zdGFuY2Uuc3Vic2NyaWJlTG9jay5yZWNvbW1lbmRlZFJldHJ5VGltZSkuZ2V0VGltZSgpID4gRGF0ZS5ub3coKSAmJlxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVkQWNjb3VudElkcyhpbnN0YW5jZU51bWJlciwgaW5kZXgsIHJlZ2lvbikubGVuZ3RoID49IFxuICAgICAgICAgICAgaW5zdGFuY2Uuc3Vic2NyaWJlTG9jay5sb2NrZWRBdEFjY291bnRzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoYWNjb3VudENvdW50ZXIgPCB0aGlzLl9tYXhBY2NvdW50c1Blckluc3RhbmNlKSB7XG4gICAgICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihzb2NrZXRJbnN0YW5jZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgIHNvY2tldEluc3RhbmNlSW5kZXggPSB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0ubGVuZ3RoO1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIHJlZ2lvbik7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdID0gc29ja2V0SW5zdGFuY2VJbmRleDtcbiAgICB9XG4gIH0gIFxuXG4gIF9jbGVhckFjY291bnRDYWNoZUpvYigpIHtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9yZWdpb25zQnlBY2NvdW50cykuZm9yRWFjaChhY2NvdW50SWQgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF07XG4gICAgICBpZihkYXRhLmNvbm5lY3Rpb25zID09PSAwICYmIGRhdGUgLSBkYXRhLmxhc3RVc2VkID4gMiAqIDYwICogNjAgKiAxMDAwKSB7XG4gICAgICAgIGNvbnN0IHByaW1hcnlBY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkW2FjY291bnRJZF07XG4gICAgICAgIGNvbnN0IHJlcGxpY2FzID0gT2JqZWN0LnZhbHVlcyh0aGlzLl9hY2NvdW50UmVwbGljYXNbcHJpbWFyeUFjY291bnRJZF0pO1xuICAgICAgICByZXBsaWNhcy5mb3JFYWNoKHJlcGxpY2EgPT4ge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkW3JlcGxpY2FdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1tyZXBsaWNhXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9hY2NvdW50UmVwbGljYXNbcHJpbWFyeUFjY291bnRJZF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuIl19