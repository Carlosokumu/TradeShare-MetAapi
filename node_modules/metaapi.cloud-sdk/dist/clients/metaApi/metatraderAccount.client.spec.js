'use strict';

var _httpClient = require('../httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _metatraderAccount = require('./metatraderAccount.client');

var _metatraderAccount2 = _interopRequireDefault(_metatraderAccount);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const provisioningApiUrl = 'https://mt-provisioning-api-v1.agiliumtrade.agiliumtrade.ai';

/**
 * @test {MetatraderAccountClient}
 */
// eslint-disable-next-line max-statements
describe('MetatraderAccountClient', () => {

  let accountClient;
  const token = 'header.payload.sign';
  let httpClient = new _httpClient2.default();
  let domainClient;
  let sandbox;
  let requestStub;

  before(() => {
    sandbox = _sinon2.default.createSandbox();
  });

  beforeEach(() => {
    domainClient = {
      token,
      domain: 'agiliumtrade.agiliumtrade.ai',
      getUrl: () => {}
    };
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    requestStub = sandbox.stub(httpClient, 'request');
  });

  afterEach(() => {
    sandbox.restore();
  });

  /**
   * @test {MetatraderAccountClient#getAccounts}
   */
  it('should retrieve MetaTrader accounts from API', async () => {
    let expected = [{
      _id: '1eda642a-a9a3-457c-99af-3bc5e8d5c4c9',
      login: '50194988',
      name: 'mt5a',
      server: 'ICMarketsSC-Demo',
      provisioningProfileId: 'f9ce1f12-e720-4b9a-9477-c2d4cb25f076',
      magic: 123456,
      application: 'MetaApi',
      connectionStatus: 'DISCONNECTED',
      state: 'DEPLOYED',
      type: 'cloud',
      tags: ['tag1', 'tag2']
    }];
    requestStub.resolves(expected);
    let accounts = await accountClient.getAccounts({
      provisioningProfileId: 'f9ce1f12-e720-4b9a-9477-c2d4cb25f076'
    });
    accounts.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts`,
      method: 'GET',
      qs: {
        provisioningProfileId: 'f9ce1f12-e720-4b9a-9477-c2d4cb25f076'
      },
      headers: {
        'auth-token': token
      },
      json: true
    }, 'getAccounts');
  });

  /**
   * @test {MetatraderAccountClient#getAccounts}
   */
  it('should not retrieve MetaTrader accounts from API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.getAccounts('f9ce1f12-e720-4b9a-9477-c2d4cb25f076');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke getAccounts method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#getAccount}
   */
  it('should retrieve MetaTrader account from API', async () => {
    let expected = {
      _id: 'id',
      login: '50194988',
      name: 'mt5a',
      server: 'ICMarketsSC-Demo',
      provisioningProfileId: 'f9ce1f12-e720-4b9a-9477-c2d4cb25f076',
      magic: 123456,
      application: 'MetaApi',
      connectionStatus: 'DISCONNECTED',
      state: 'DEPLOYED',
      type: 'cloud',
      tags: ['tag1', 'tag2']
    };
    requestStub.resolves(expected);
    let account = await accountClient.getAccount('id');
    account.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/id`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'getAccount');
  });

  /**
   * @test {MetatraderAccountClient#getAccountReplica}
   */
  it('should retrieve MetaTrader account replica from API', async () => {
    let expected = {
      _id: 'idReplica',
      login: '50194988',
      name: 'mt5a',
      server: 'ICMarketsSC-Demo',
      provisioningProfileId: 'f9ce1f12-e720-4b9a-9477-c2d4cb25f076',
      magic: 123456,
      application: 'MetaApi',
      connectionStatus: 'DISCONNECTED',
      state: 'DEPLOYED',
      type: 'cloud',
      tags: ['tag1', 'tag2']
    };
    requestStub.resolves(expected);
    let account = await accountClient.getAccountReplica('id', 'idReplica');
    account.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/id/replicas/idReplica`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'getAccountReplica');
  });

  /**
   * @test {MetatraderAccountClient#getAccountByToken}
   */
  it('should retrieve MetaTrader account by token from API', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    let expected = {
      _id: 'id',
      login: '50194988',
      name: 'mt5a',
      server: 'ICMarketsSC-Demo',
      provisioningProfileId: 'f9ce1f12-e720-4b9a-9477-c2d4cb25f076',
      magic: 123456,
      application: 'MetaApi',
      connectionStatus: 'DISCONNECTED',
      state: 'DEPLOYED',
      type: 'cloud'
    };
    requestStub.resolves(expected);
    let account = await accountClient.getAccountByToken();
    account.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/accessToken/token`,
      method: 'GET',
      json: true
    }, 'getAccountByToken');
  });

  /**
   * @test {MetatraderAccountClient#createAccount}
   */
  it('should not retrieve MetaTrader account by token via API with api token', async () => {
    domainClient.token = token;
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.getAccountByToken();
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke getAccountByToken method, because you have connected with API access token. ' + 'Please use account access token to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#createAccount}
   */
  it('should create MetaTrader account via API', async () => {
    let expected = {
      id: 'id'
    };
    let account = {
      login: '50194988',
      password: 'Test1234',
      name: 'mt5a',
      server: 'ICMarketsSC-Demo',
      provisioningProfileId: 'f9ce1f12-e720-4b9a-9477-c2d4cb25f076',
      magic: 123456,
      application: 'MetaApi',
      type: 'cloud',
      tags: ['tag1']
    };
    requestStub.resolves(expected);
    let id = await accountClient.createAccount(account);
    id.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts`,
      method: 'POST',
      body: account,
      headers: {
        'auth-token': token
      },
      json: true
    }, 'createAccount');
  });

  /**
   * @test {MetatraderAccountClient#createAccount}
   */
  it('should not create MetaTrader account via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.createAccount({});
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke createAccount method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#createAccountReplica}
   */
  it('should create MetaTrader account replica via API', async () => {
    let expected = {
      id: 'id'
    };
    let replica = {
      magic: 123456,
      symbol: 'EURUSD'
    };
    requestStub.resolves(expected);
    let id = await accountClient.createAccountReplica('accountId', replica);
    id.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/accountId/replicas`,
      method: 'POST',
      body: replica,
      headers: {
        'auth-token': token
      },
      json: true
    }, 'createAccountReplica');
  });

  /**
   * @test {MetatraderAccountClient#createAccountReplica}
   */
  it('should not create MetaTrader account replica via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.createAccountReplica('accountId', {});
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke createAccountReplica method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#deployAccount}
   */
  it('should deploy MetaTrader account via API', async () => {
    await accountClient.deployAccount('id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/id/deploy`,
      method: 'POST',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'deployAccount');
  });

  /**
   * @test {MetatraderAccountClient#deployAccount}
   */
  it('should not deploy MetaTrader account via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.deployAccount('id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke deployAccount method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#deployAccountReplica}
   */
  it('should deploy MetaTrader account replica via API', async () => {
    await accountClient.deployAccountReplica('accountId', 'id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/accountId/replicas/id/deploy`,
      method: 'POST',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'deployAccountReplica');
  });

  /**
   * @test {MetatraderAccountClient#deployAccountReplica}
   */
  it('should not deploy MetaTrader account replica via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.deployAccountReplica('accountId', 'id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke deployAccountReplica method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#undeployAccount}
   */
  it('should undeploy MetaTrader account via API', async () => {
    await accountClient.undeployAccount('id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/id/undeploy`,
      method: 'POST',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'undeployAccount');
  });

  /**
   * @test {MetatraderAccountClient#undeployAccount}
   */
  it('should not undeploy MetaTrader account via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.undeployAccount('id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke undeployAccount method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#undeployAccountReplica}
   */
  it('should undeploy MetaTrader account replica via API', async () => {
    await accountClient.undeployAccountReplica('accountId', 'id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/accountId/replicas/id/undeploy`,
      method: 'POST',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'undeployAccountReplica');
  });

  /**
   * @test {MetatraderAccountClient#undeployAccountReplica}
   */
  it('should not undeploy MetaTrader account replica via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.undeployAccountReplica('accountId', 'id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke undeployAccountReplica method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#redeployAccount}
   */
  it('should redeploy MetaTrader account via API', async () => {
    await accountClient.redeployAccount('id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/id/redeploy`,
      method: 'POST',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'redeployAccount');
  });

  /**
   * @test {MetatraderAccountClient#redeployAccount}
   */
  it('should not redeploy MetaTrader account via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.redeployAccount('id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke redeployAccount method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#redeployAccountReplica}
   */
  it('should redeploy MetaTrader account replica via API', async () => {
    await accountClient.redeployAccountReplica('accountId', 'id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/accountId/replicas/id/redeploy`,
      method: 'POST',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'redeployAccountReplica');
  });

  /**
   * @test {MetatraderAccountClient#redeployAccountReplica}
   */
  it('should not redeploy MetaTrader account replica via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.redeployAccountReplica('accountId', 'id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke redeployAccountReplica method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#deleteAccount}
   */
  it('should delete MetaTrader account via API', async () => {
    await accountClient.deleteAccount('id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/id`,
      method: 'DELETE',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'deleteAccount');
  });

  /**
   * @test {MetatraderAccountClient#deleteAccount}
   */
  it('should not delete MetaTrader account via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.deleteAccount('id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke deleteAccount method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#deleteAccountReplica}
   */
  it('should delete MetaTrader account replica via API', async () => {
    await accountClient.deleteAccountReplica('accountId', 'id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/accountId/replicas/id`,
      method: 'DELETE',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'deleteAccountReplica');
  });

  /**
   * @test {MetatraderAccountClient#deleteAccountReplica}
   */
  it('should not delete MetaTrader account replica via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.deleteAccountReplica('accountId', 'id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke deleteAccountReplica method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#updateAccount}
   */
  it('should update MetaTrader account via API', async () => {
    await accountClient.updateAccount('id', {
      name: 'new account name',
      password: 'new_password007',
      server: 'ICMarketsSC2-Demo',
      tags: ['tag1']
    });
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/id`,
      method: 'PUT',
      headers: {
        'auth-token': token
      },
      json: true,
      body: {
        name: 'new account name',
        password: 'new_password007',
        server: 'ICMarketsSC2-Demo',
        tags: ['tag1']
      }
    }, 'updateAccount');
  });

  /**
   * @test {MetatraderAccountClient#updateAccount}
   */
  it('should not update MetaTrader account via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.updateAccount('id', {});
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke updateAccount method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#updateAccountReplica}
   */
  it('should update MetaTrader account replica via API', async () => {
    await accountClient.updateAccountReplica('accountId', 'id', {
      magic: 0,
      tags: ['tag1']
    });
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/accountId/replicas/id`,
      method: 'PUT',
      headers: {
        'auth-token': token
      },
      json: true,
      body: {
        magic: 0,
        tags: ['tag1']
      }
    }, 'updateAccountReplica');
  });

  /**
   * @test {MetatraderAccountClient#updateAccountReplica}
   */
  it('should not update MetaTrader account replica via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.updateAccountReplica('accountId', 'id', {});
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke updateAccountReplica method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {MetatraderAccountClient#increaseReliability}
   */
  it('should increase MetaTrader account reliability via API', async () => {
    await accountClient.increaseReliability('id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/accounts/id/increase-reliability`,
      method: 'POST',
      headers: {
        'auth-token': token
      },
      json: true
    }, 'increaseReliability');
  });

  /**
     * @test {MetatraderAccountClient#increaseReliability}
     */
  it('should not increase MetaTrader account reliability via API with account token', async () => {
    domainClient.token = 'token';
    accountClient = new _metatraderAccount2.default(httpClient, domainClient);
    try {
      await accountClient.increaseReliability('id');
      _sinon2.default.assert.fail();
    } catch (error) {
      error.message.should.equal('You can not invoke increaseReliability method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvbWV0YXRyYWRlckFjY291bnQuY2xpZW50LnNwZWMuZXM2Il0sIm5hbWVzIjpbInByb3Zpc2lvbmluZ0FwaVVybCIsImRlc2NyaWJlIiwiYWNjb3VudENsaWVudCIsInRva2VuIiwiaHR0cENsaWVudCIsIkh0dHBDbGllbnQiLCJkb21haW5DbGllbnQiLCJzYW5kYm94IiwicmVxdWVzdFN0dWIiLCJiZWZvcmUiLCJzaW5vbiIsImNyZWF0ZVNhbmRib3giLCJiZWZvcmVFYWNoIiwiZG9tYWluIiwiZ2V0VXJsIiwiTWV0YXRyYWRlckFjY291bnRDbGllbnQiLCJzdHViIiwiYWZ0ZXJFYWNoIiwicmVzdG9yZSIsIml0IiwiZXhwZWN0ZWQiLCJfaWQiLCJsb2dpbiIsIm5hbWUiLCJzZXJ2ZXIiLCJwcm92aXNpb25pbmdQcm9maWxlSWQiLCJtYWdpYyIsImFwcGxpY2F0aW9uIiwiY29ubmVjdGlvblN0YXR1cyIsInN0YXRlIiwidHlwZSIsInRhZ3MiLCJyZXNvbHZlcyIsImFjY291bnRzIiwiZ2V0QWNjb3VudHMiLCJzaG91bGQiLCJlcXVhbCIsImFzc2VydCIsImNhbGxlZE9uY2VXaXRoRXhhY3RseSIsInJlcXVlc3QiLCJ1cmwiLCJtZXRob2QiLCJxcyIsImhlYWRlcnMiLCJqc29uIiwiZmFpbCIsImVycm9yIiwibWVzc2FnZSIsImFjY291bnQiLCJnZXRBY2NvdW50IiwiZ2V0QWNjb3VudFJlcGxpY2EiLCJnZXRBY2NvdW50QnlUb2tlbiIsImlkIiwicGFzc3dvcmQiLCJjcmVhdGVBY2NvdW50IiwiYm9keSIsInJlcGxpY2EiLCJzeW1ib2wiLCJjcmVhdGVBY2NvdW50UmVwbGljYSIsImRlcGxveUFjY291bnQiLCJkZXBsb3lBY2NvdW50UmVwbGljYSIsInVuZGVwbG95QWNjb3VudCIsInVuZGVwbG95QWNjb3VudFJlcGxpY2EiLCJyZWRlcGxveUFjY291bnQiLCJyZWRlcGxveUFjY291bnRSZXBsaWNhIiwiZGVsZXRlQWNjb3VudCIsImRlbGV0ZUFjY291bnRSZXBsaWNhIiwidXBkYXRlQWNjb3VudCIsInVwZGF0ZUFjY291bnRSZXBsaWNhIiwiaW5jcmVhc2VSZWxpYWJpbGl0eSJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxxQkFBcUIsNkRBQTNCOztBQUVBOzs7QUFHQTtBQUNBQyxTQUFTLHlCQUFULEVBQW9DLE1BQU07O0FBRXhDLE1BQUlDLGFBQUo7QUFDQSxRQUFNQyxRQUFRLHFCQUFkO0FBQ0EsTUFBSUMsYUFBYSxJQUFJQyxvQkFBSixFQUFqQjtBQUNBLE1BQUlDLFlBQUo7QUFDQSxNQUFJQyxPQUFKO0FBQ0EsTUFBSUMsV0FBSjs7QUFFQUMsU0FBTyxNQUFNO0FBQ1hGLGNBQVVHLGdCQUFNQyxhQUFOLEVBQVY7QUFDRCxHQUZEOztBQUlBQyxhQUFXLE1BQU07QUFDZk4sbUJBQWU7QUFDYkgsV0FEYTtBQUViVSxjQUFRLDhCQUZLO0FBR2JDLGNBQVEsTUFBTSxDQUFFO0FBSEgsS0FBZjtBQUtBWixvQkFBZ0IsSUFBSWEsMkJBQUosQ0FBNEJYLFVBQTVCLEVBQXdDRSxZQUF4QyxDQUFoQjtBQUNBRSxrQkFBY0QsUUFBUVMsSUFBUixDQUFhWixVQUFiLEVBQXlCLFNBQXpCLENBQWQ7QUFDRCxHQVJEOztBQVVBYSxZQUFVLE1BQU07QUFDZFYsWUFBUVcsT0FBUjtBQUNELEdBRkQ7O0FBSUE7OztBQUdBQyxLQUFHLDhDQUFILEVBQW1ELFlBQVk7QUFDN0QsUUFBSUMsV0FBVyxDQUFDO0FBQ2RDLFdBQUssc0NBRFM7QUFFZEMsYUFBTyxVQUZPO0FBR2RDLFlBQU0sTUFIUTtBQUlkQyxjQUFRLGtCQUpNO0FBS2RDLDZCQUF1QixzQ0FMVDtBQU1kQyxhQUFPLE1BTk87QUFPZEMsbUJBQWEsU0FQQztBQVFkQyx3QkFBa0IsY0FSSjtBQVNkQyxhQUFPLFVBVE87QUFVZEMsWUFBTSxPQVZRO0FBV2RDLFlBQU0sQ0FBQyxNQUFELEVBQVMsTUFBVDtBQVhR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R0FqQixLQUFHLHdEQUFILEVBQTZELFlBQVk7QUFDdkUsVUFBTWpCLGNBQWNtRSxtQkFBZCxDQUFrQyxJQUFsQyxDQUFOO0FBQ0EzRCxvQkFBTTJCLE1BQU4sQ0FBYUMscUJBQWIsQ0FBbUNsQyxXQUFXbUMsT0FBOUMsRUFBdUQ7QUFDckRDLFdBQU0sR0FBRXhDLGtCQUFtQixpREFEMEI7QUFFckR5QyxjQUFRLE1BRjZDO0FBR3JERSxlQUFTO0FBQ1Asc0JBQWN4QztBQURQLE9BSDRDO0FBTXJEeUMsWUFBTTtBQU4rQyxLQUF2RCxFQU9HLHFCQVBIO0FBUUQsR0FWRDs7QUFZQTs7O0FBR0F6QixLQUFHLCtFQUFILEVBQW9GLFlBQVk7QUFDOUZiLGlCQUFhSCxLQUFiLEdBQXFCLE9BQXJCO0FBQ0FELG9CQUFnQixJQUFJYSwyQkFBSixDQUE0QlgsVUFBNUIsRUFBd0NFLFlBQXhDLENBQWhCO0FBQ0EsUUFBSTtBQUNGLFlBQU1KLGNBQWNtRSxtQkFBZCxDQUFrQyxJQUFsQyxDQUFOO0FBQ0EzRCxzQkFBTTJCLE1BQU4sQ0FBYVEsSUFBYjtBQUNELEtBSEQsQ0FHRSxPQUFPQyxLQUFQLEVBQWM7QUFDZEEsWUFBTUMsT0FBTixDQUFjWixNQUFkLENBQXFCQyxLQUFyQixDQUNFLDBHQUNFLDhGQUZKO0FBSUQ7QUFDRixHQVpEO0FBY0QsQ0Fyb0JEIiwiZmlsZSI6Im1ldGF0cmFkZXJBY2NvdW50LmNsaWVudC5zcGVjLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgSHR0cENsaWVudCBmcm9tICcuLi9odHRwQ2xpZW50JztcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XG5pbXBvcnQgTWV0YXRyYWRlckFjY291bnRDbGllbnQgZnJvbSAnLi9tZXRhdHJhZGVyQWNjb3VudC5jbGllbnQnO1xuXG5jb25zdCBwcm92aXNpb25pbmdBcGlVcmwgPSAnaHR0cHM6Ly9tdC1wcm92aXNpb25pbmctYXBpLXYxLmFnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWknO1xuXG4vKipcbiAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudH1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG5kZXNjcmliZSgnTWV0YXRyYWRlckFjY291bnRDbGllbnQnLCAoKSA9PiB7XG5cbiAgbGV0IGFjY291bnRDbGllbnQ7XG4gIGNvbnN0IHRva2VuID0gJ2hlYWRlci5wYXlsb2FkLnNpZ24nO1xuICBsZXQgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50KCk7XG4gIGxldCBkb21haW5DbGllbnQ7XG4gIGxldCBzYW5kYm94O1xuICBsZXQgcmVxdWVzdFN0dWI7XG5cbiAgYmVmb3JlKCgpID0+IHtcbiAgICBzYW5kYm94ID0gc2lub24uY3JlYXRlU2FuZGJveCgpO1xuICB9KTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBkb21haW5DbGllbnQgPSB7XG4gICAgICB0b2tlbixcbiAgICAgIGRvbWFpbjogJ2FnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWknLFxuICAgICAgZ2V0VXJsOiAoKSA9PiB7fVxuICAgIH07XG4gICAgYWNjb3VudENsaWVudCA9IG5ldyBNZXRhdHJhZGVyQWNjb3VudENsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHJlcXVlc3RTdHViID0gc2FuZGJveC5zdHViKGh0dHBDbGllbnQsICdyZXF1ZXN0Jyk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgc2FuZGJveC5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjZ2V0QWNjb3VudHN9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIE1ldGFUcmFkZXIgYWNjb3VudHMgZnJvbSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGV4cGVjdGVkID0gW3tcbiAgICAgIF9pZDogJzFlZGE2NDJhLWE5YTMtNDU3Yy05OWFmLTNiYzVlOGQ1YzRjOScsXG4gICAgICBsb2dpbjogJzUwMTk0OTg4JyxcbiAgICAgIG5hbWU6ICdtdDVhJyxcbiAgICAgIHNlcnZlcjogJ0lDTWFya2V0c1NDLURlbW8nLFxuICAgICAgcHJvdmlzaW9uaW5nUHJvZmlsZUlkOiAnZjljZTFmMTItZTcyMC00YjlhLTk0NzctYzJkNGNiMjVmMDc2JyxcbiAgICAgIG1hZ2ljOiAxMjM0NTYsXG4gICAgICBhcHBsaWNhdGlvbjogJ01ldGFBcGknLFxuICAgICAgY29ubmVjdGlvblN0YXR1czogJ0RJU0NPTk5FQ1RFRCcsXG4gICAgICBzdGF0ZTogJ0RFUExPWUVEJyxcbiAgICAgIHR5cGU6ICdjbG91ZCcsXG4gICAgICB0YWdzOiBbJ3RhZzEnLCAndGFnMiddXG4gICAgfV07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCBhY2NvdW50cyA9IGF3YWl0IGFjY291bnRDbGllbnQuZ2V0QWNjb3VudHMoe1xuICAgICAgcHJvdmlzaW9uaW5nUHJvZmlsZUlkOiAnZjljZTFmMTItZTcyMC00YjlhLTk0NzctYzJkNGNiMjVmMDc2J1xuICAgIH0pO1xuICAgIGFjY291bnRzLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7cHJvdmlzaW9uaW5nQXBpVXJsfS91c2Vycy9jdXJyZW50L2FjY291bnRzYCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBxczoge1xuICAgICAgICBwcm92aXNpb25pbmdQcm9maWxlSWQ6ICdmOWNlMWYxMi1lNzIwLTRiOWEtOTQ3Ny1jMmQ0Y2IyNWYwNzYnXG4gICAgICB9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9LCAnZ2V0QWNjb3VudHMnKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCNnZXRBY2NvdW50c31cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHJldHJpZXZlIE1ldGFUcmFkZXIgYWNjb3VudHMgZnJvbSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudC50b2tlbiA9ICd0b2tlbic7XG4gICAgYWNjb3VudENsaWVudCA9IG5ldyBNZXRhdHJhZGVyQWNjb3VudENsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhY2NvdW50Q2xpZW50LmdldEFjY291bnRzKCdmOWNlMWYxMi1lNzIwLTRiOWEtOTQ3Ny1jMmQ0Y2IyNWYwNzYnKTtcbiAgICAgIHNpbm9uLmFzc2VydC5mYWlsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGdldEFjY291bnRzIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I2dldEFjY291bnR9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIE1ldGFUcmFkZXIgYWNjb3VudCBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXhwZWN0ZWQgPSB7XG4gICAgICBfaWQ6ICdpZCcsXG4gICAgICBsb2dpbjogJzUwMTk0OTg4JyxcbiAgICAgIG5hbWU6ICdtdDVhJyxcbiAgICAgIHNlcnZlcjogJ0lDTWFya2V0c1NDLURlbW8nLFxuICAgICAgcHJvdmlzaW9uaW5nUHJvZmlsZUlkOiAnZjljZTFmMTItZTcyMC00YjlhLTk0NzctYzJkNGNiMjVmMDc2JyxcbiAgICAgIG1hZ2ljOiAxMjM0NTYsXG4gICAgICBhcHBsaWNhdGlvbjogJ01ldGFBcGknLFxuICAgICAgY29ubmVjdGlvblN0YXR1czogJ0RJU0NPTk5FQ1RFRCcsXG4gICAgICBzdGF0ZTogJ0RFUExPWUVEJyxcbiAgICAgIHR5cGU6ICdjbG91ZCcsXG4gICAgICB0YWdzOiBbJ3RhZzEnLCAndGFnMiddXG4gICAgfTtcbiAgICByZXF1ZXN0U3R1Yi5yZXNvbHZlcyhleHBlY3RlZCk7XG4gICAgbGV0IGFjY291bnQgPSBhd2FpdCBhY2NvdW50Q2xpZW50LmdldEFjY291bnQoJ2lkJyk7XG4gICAgYWNjb3VudC5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy9pZGAsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9LCAnZ2V0QWNjb3VudCcpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I2dldEFjY291bnRSZXBsaWNhfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBNZXRhVHJhZGVyIGFjY291bnQgcmVwbGljYSBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXhwZWN0ZWQgPSB7XG4gICAgICBfaWQ6ICdpZFJlcGxpY2EnLFxuICAgICAgbG9naW46ICc1MDE5NDk4OCcsXG4gICAgICBuYW1lOiAnbXQ1YScsXG4gICAgICBzZXJ2ZXI6ICdJQ01hcmtldHNTQy1EZW1vJyxcbiAgICAgIHByb3Zpc2lvbmluZ1Byb2ZpbGVJZDogJ2Y5Y2UxZjEyLWU3MjAtNGI5YS05NDc3LWMyZDRjYjI1ZjA3NicsXG4gICAgICBtYWdpYzogMTIzNDU2LFxuICAgICAgYXBwbGljYXRpb246ICdNZXRhQXBpJyxcbiAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdESVNDT05ORUNURUQnLFxuICAgICAgc3RhdGU6ICdERVBMT1lFRCcsXG4gICAgICB0eXBlOiAnY2xvdWQnLFxuICAgICAgdGFnczogWyd0YWcxJywgJ3RhZzInXVxuICAgIH07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCBhY2NvdW50ID0gYXdhaXQgYWNjb3VudENsaWVudC5nZXRBY2NvdW50UmVwbGljYSgnaWQnLCAnaWRSZXBsaWNhJyk7XG4gICAgYWNjb3VudC5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy9pZC9yZXBsaWNhcy9pZFJlcGxpY2FgLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSwgJ2dldEFjY291bnRSZXBsaWNhJyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjZ2V0QWNjb3VudEJ5VG9rZW59XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIE1ldGFUcmFkZXIgYWNjb3VudCBieSB0b2tlbiBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBkb21haW5DbGllbnQudG9rZW4gPSAndG9rZW4nO1xuICAgIGFjY291bnRDbGllbnQgPSBuZXcgTWV0YXRyYWRlckFjY291bnRDbGllbnQoaHR0cENsaWVudCwgZG9tYWluQ2xpZW50KTtcbiAgICBsZXQgZXhwZWN0ZWQgPSB7XG4gICAgICBfaWQ6ICdpZCcsXG4gICAgICBsb2dpbjogJzUwMTk0OTg4JyxcbiAgICAgIG5hbWU6ICdtdDVhJyxcbiAgICAgIHNlcnZlcjogJ0lDTWFya2V0c1NDLURlbW8nLFxuICAgICAgcHJvdmlzaW9uaW5nUHJvZmlsZUlkOiAnZjljZTFmMTItZTcyMC00YjlhLTk0NzctYzJkNGNiMjVmMDc2JyxcbiAgICAgIG1hZ2ljOiAxMjM0NTYsXG4gICAgICBhcHBsaWNhdGlvbjogJ01ldGFBcGknLFxuICAgICAgY29ubmVjdGlvblN0YXR1czogJ0RJU0NPTk5FQ1RFRCcsXG4gICAgICBzdGF0ZTogJ0RFUExPWUVEJyxcbiAgICAgIHR5cGU6ICdjbG91ZCdcbiAgICB9O1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgYWNjb3VudCA9IGF3YWl0IGFjY291bnRDbGllbnQuZ2V0QWNjb3VudEJ5VG9rZW4oKTtcbiAgICBhY2NvdW50LnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7cHJvdmlzaW9uaW5nQXBpVXJsfS91c2Vycy9jdXJyZW50L2FjY291bnRzL2FjY2Vzc1Rva2VuL3Rva2VuYCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBqc29uOiB0cnVlXG4gICAgfSwgJ2dldEFjY291bnRCeVRva2VuJyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjY3JlYXRlQWNjb3VudH1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHJldHJpZXZlIE1ldGFUcmFkZXIgYWNjb3VudCBieSB0b2tlbiB2aWEgQVBJIHdpdGggYXBpIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudC50b2tlbiA9IHRva2VuO1xuICAgIGFjY291bnRDbGllbnQgPSBuZXcgTWV0YXRyYWRlckFjY291bnRDbGllbnQoaHR0cENsaWVudCwgZG9tYWluQ2xpZW50KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYWNjb3VudENsaWVudC5nZXRBY2NvdW50QnlUb2tlbigpO1xuICAgICAgc2lub24uYXNzZXJ0LmZhaWwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgZ2V0QWNjb3VudEJ5VG9rZW4gbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIEFQSSBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBhY2NvdW50IGFjY2VzcyB0b2tlbiB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjY3JlYXRlQWNjb3VudH1cbiAgICovXG4gIGl0KCdzaG91bGQgY3JlYXRlIE1ldGFUcmFkZXIgYWNjb3VudCB2aWEgQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IHtcbiAgICAgIGlkOiAnaWQnXG4gICAgfTtcbiAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgIGxvZ2luOiAnNTAxOTQ5ODgnLFxuICAgICAgcGFzc3dvcmQ6ICdUZXN0MTIzNCcsXG4gICAgICBuYW1lOiAnbXQ1YScsXG4gICAgICBzZXJ2ZXI6ICdJQ01hcmtldHNTQy1EZW1vJyxcbiAgICAgIHByb3Zpc2lvbmluZ1Byb2ZpbGVJZDogJ2Y5Y2UxZjEyLWU3MjAtNGI5YS05NDc3LWMyZDRjYjI1ZjA3NicsXG4gICAgICBtYWdpYzogMTIzNDU2LFxuICAgICAgYXBwbGljYXRpb246ICdNZXRhQXBpJyxcbiAgICAgIHR5cGU6ICdjbG91ZCcsXG4gICAgICB0YWdzOiBbJ3RhZzEnXVxuICAgIH07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCBpZCA9IGF3YWl0IGFjY291bnRDbGllbnQuY3JlYXRlQWNjb3VudChhY2NvdW50KTtcbiAgICBpZC5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50c2AsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IGFjY291bnQsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0sICdjcmVhdGVBY2NvdW50Jyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjY3JlYXRlQWNjb3VudH1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IGNyZWF0ZSBNZXRhVHJhZGVyIGFjY291bnQgdmlhIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgZG9tYWluQ2xpZW50LnRva2VuID0gJ3Rva2VuJztcbiAgICBhY2NvdW50Q2xpZW50ID0gbmV3IE1ldGF0cmFkZXJBY2NvdW50Q2xpZW50KGh0dHBDbGllbnQsIGRvbWFpbkNsaWVudCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGFjY291bnRDbGllbnQuY3JlYXRlQWNjb3VudCh7fSk7XG4gICAgICBzaW5vbi5hc3NlcnQuZmFpbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBjcmVhdGVBY2NvdW50IG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I2NyZWF0ZUFjY291bnRSZXBsaWNhfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBjcmVhdGUgTWV0YVRyYWRlciBhY2NvdW50IHJlcGxpY2EgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXhwZWN0ZWQgPSB7XG4gICAgICBpZDogJ2lkJ1xuICAgIH07XG4gICAgbGV0IHJlcGxpY2EgPSB7XG4gICAgICBtYWdpYzogMTIzNDU2LFxuICAgICAgc3ltYm9sOiAnRVVSVVNEJ1xuICAgIH07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCBpZCA9IGF3YWl0IGFjY291bnRDbGllbnQuY3JlYXRlQWNjb3VudFJlcGxpY2EoJ2FjY291bnRJZCcsIHJlcGxpY2EpO1xuICAgIGlkLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7cHJvdmlzaW9uaW5nQXBpVXJsfS91c2Vycy9jdXJyZW50L2FjY291bnRzL2FjY291bnRJZC9yZXBsaWNhc2AsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IHJlcGxpY2EsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0sICdjcmVhdGVBY2NvdW50UmVwbGljYScpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I2NyZWF0ZUFjY291bnRSZXBsaWNhfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgY3JlYXRlIE1ldGFUcmFkZXIgYWNjb3VudCByZXBsaWNhIHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudC50b2tlbiA9ICd0b2tlbic7XG4gICAgYWNjb3VudENsaWVudCA9IG5ldyBNZXRhdHJhZGVyQWNjb3VudENsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhY2NvdW50Q2xpZW50LmNyZWF0ZUFjY291bnRSZXBsaWNhKCdhY2NvdW50SWQnLCB7fSk7XG4gICAgICBzaW5vbi5hc3NlcnQuZmFpbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBjcmVhdGVBY2NvdW50UmVwbGljYSBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCNkZXBsb3lBY2NvdW50fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBkZXBsb3kgTWV0YVRyYWRlciBhY2NvdW50IHZpYSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgYWNjb3VudENsaWVudC5kZXBsb3lBY2NvdW50KCdpZCcpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy9pZC9kZXBsb3lgLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0sICdkZXBsb3lBY2NvdW50Jyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjZGVwbG95QWNjb3VudH1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IGRlcGxveSBNZXRhVHJhZGVyIGFjY291bnQgdmlhIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgZG9tYWluQ2xpZW50LnRva2VuID0gJ3Rva2VuJztcbiAgICBhY2NvdW50Q2xpZW50ID0gbmV3IE1ldGF0cmFkZXJBY2NvdW50Q2xpZW50KGh0dHBDbGllbnQsIGRvbWFpbkNsaWVudCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGFjY291bnRDbGllbnQuZGVwbG95QWNjb3VudCgnaWQnKTtcbiAgICAgIHNpbm9uLmFzc2VydC5mYWlsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGRlcGxveUFjY291bnQgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjZGVwbG95QWNjb3VudFJlcGxpY2F9XG4gICAqL1xuICBpdCgnc2hvdWxkIGRlcGxveSBNZXRhVHJhZGVyIGFjY291bnQgcmVwbGljYSB2aWEgQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGFjY291bnRDbGllbnQuZGVwbG95QWNjb3VudFJlcGxpY2EoJ2FjY291bnRJZCcsICdpZCcpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy9hY2NvdW50SWQvcmVwbGljYXMvaWQvZGVwbG95YCxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9LCAnZGVwbG95QWNjb3VudFJlcGxpY2EnKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCNkZXBsb3lBY2NvdW50UmVwbGljYX1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IGRlcGxveSBNZXRhVHJhZGVyIGFjY291bnQgcmVwbGljYSB2aWEgQVBJIHdpdGggYWNjb3VudCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBkb21haW5DbGllbnQudG9rZW4gPSAndG9rZW4nO1xuICAgIGFjY291bnRDbGllbnQgPSBuZXcgTWV0YXRyYWRlckFjY291bnRDbGllbnQoaHR0cENsaWVudCwgZG9tYWluQ2xpZW50KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYWNjb3VudENsaWVudC5kZXBsb3lBY2NvdW50UmVwbGljYSgnYWNjb3VudElkJywgJ2lkJyk7XG4gICAgICBzaW5vbi5hc3NlcnQuZmFpbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBkZXBsb3lBY2NvdW50UmVwbGljYSBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCN1bmRlcGxveUFjY291bnR9XG4gICAqL1xuICBpdCgnc2hvdWxkIHVuZGVwbG95IE1ldGFUcmFkZXIgYWNjb3VudCB2aWEgQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGFjY291bnRDbGllbnQudW5kZXBsb3lBY2NvdW50KCdpZCcpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy9pZC91bmRlcGxveWAsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSwgJ3VuZGVwbG95QWNjb3VudCcpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I3VuZGVwbG95QWNjb3VudH1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHVuZGVwbG95IE1ldGFUcmFkZXIgYWNjb3VudCB2aWEgQVBJIHdpdGggYWNjb3VudCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBkb21haW5DbGllbnQudG9rZW4gPSAndG9rZW4nO1xuICAgIGFjY291bnRDbGllbnQgPSBuZXcgTWV0YXRyYWRlckFjY291bnRDbGllbnQoaHR0cENsaWVudCwgZG9tYWluQ2xpZW50KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYWNjb3VudENsaWVudC51bmRlcGxveUFjY291bnQoJ2lkJyk7XG4gICAgICBzaW5vbi5hc3NlcnQuZmFpbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSB1bmRlcGxveUFjY291bnQgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjdW5kZXBsb3lBY2NvdW50UmVwbGljYX1cbiAgICovXG4gIGl0KCdzaG91bGQgdW5kZXBsb3kgTWV0YVRyYWRlciBhY2NvdW50IHJlcGxpY2EgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBhY2NvdW50Q2xpZW50LnVuZGVwbG95QWNjb3VudFJlcGxpY2EoJ2FjY291bnRJZCcsICdpZCcpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy9hY2NvdW50SWQvcmVwbGljYXMvaWQvdW5kZXBsb3lgLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0sICd1bmRlcGxveUFjY291bnRSZXBsaWNhJyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjdW5kZXBsb3lBY2NvdW50UmVwbGljYX1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHVuZGVwbG95IE1ldGFUcmFkZXIgYWNjb3VudCByZXBsaWNhIHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudC50b2tlbiA9ICd0b2tlbic7XG4gICAgYWNjb3VudENsaWVudCA9IG5ldyBNZXRhdHJhZGVyQWNjb3VudENsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhY2NvdW50Q2xpZW50LnVuZGVwbG95QWNjb3VudFJlcGxpY2EoJ2FjY291bnRJZCcsICdpZCcpO1xuICAgICAgc2lub24uYXNzZXJ0LmZhaWwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgdW5kZXBsb3lBY2NvdW50UmVwbGljYSBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCNyZWRlcGxveUFjY291bnR9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJlZGVwbG95IE1ldGFUcmFkZXIgYWNjb3VudCB2aWEgQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGFjY291bnRDbGllbnQucmVkZXBsb3lBY2NvdW50KCdpZCcpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy9pZC9yZWRlcGxveWAsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSwgJ3JlZGVwbG95QWNjb3VudCcpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I3JlZGVwbG95QWNjb3VudH1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHJlZGVwbG95IE1ldGFUcmFkZXIgYWNjb3VudCB2aWEgQVBJIHdpdGggYWNjb3VudCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBkb21haW5DbGllbnQudG9rZW4gPSAndG9rZW4nO1xuICAgIGFjY291bnRDbGllbnQgPSBuZXcgTWV0YXRyYWRlckFjY291bnRDbGllbnQoaHR0cENsaWVudCwgZG9tYWluQ2xpZW50KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYWNjb3VudENsaWVudC5yZWRlcGxveUFjY291bnQoJ2lkJyk7XG4gICAgICBzaW5vbi5hc3NlcnQuZmFpbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSByZWRlcGxveUFjY291bnQgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjcmVkZXBsb3lBY2NvdW50UmVwbGljYX1cbiAgICovXG4gIGl0KCdzaG91bGQgcmVkZXBsb3kgTWV0YVRyYWRlciBhY2NvdW50IHJlcGxpY2EgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBhY2NvdW50Q2xpZW50LnJlZGVwbG95QWNjb3VudFJlcGxpY2EoJ2FjY291bnRJZCcsICdpZCcpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy9hY2NvdW50SWQvcmVwbGljYXMvaWQvcmVkZXBsb3lgLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0sICdyZWRlcGxveUFjY291bnRSZXBsaWNhJyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjcmVkZXBsb3lBY2NvdW50UmVwbGljYX1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHJlZGVwbG95IE1ldGFUcmFkZXIgYWNjb3VudCByZXBsaWNhIHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudC50b2tlbiA9ICd0b2tlbic7XG4gICAgYWNjb3VudENsaWVudCA9IG5ldyBNZXRhdHJhZGVyQWNjb3VudENsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhY2NvdW50Q2xpZW50LnJlZGVwbG95QWNjb3VudFJlcGxpY2EoJ2FjY291bnRJZCcsICdpZCcpO1xuICAgICAgc2lub24uYXNzZXJ0LmZhaWwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgcmVkZXBsb3lBY2NvdW50UmVwbGljYSBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCNkZWxldGVBY2NvdW50fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBkZWxldGUgTWV0YVRyYWRlciBhY2NvdW50IHZpYSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgYWNjb3VudENsaWVudC5kZWxldGVBY2NvdW50KCdpZCcpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy9pZGAsXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9LCAnZGVsZXRlQWNjb3VudCcpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I2RlbGV0ZUFjY291bnR9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCBkZWxldGUgTWV0YVRyYWRlciBhY2NvdW50IHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudC50b2tlbiA9ICd0b2tlbic7XG4gICAgYWNjb3VudENsaWVudCA9IG5ldyBNZXRhdHJhZGVyQWNjb3VudENsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhY2NvdW50Q2xpZW50LmRlbGV0ZUFjY291bnQoJ2lkJyk7XG4gICAgICBzaW5vbi5hc3NlcnQuZmFpbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBkZWxldGVBY2NvdW50IG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I2RlbGV0ZUFjY291bnRSZXBsaWNhfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBkZWxldGUgTWV0YVRyYWRlciBhY2NvdW50IHJlcGxpY2EgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBhY2NvdW50Q2xpZW50LmRlbGV0ZUFjY291bnRSZXBsaWNhKCdhY2NvdW50SWQnLCAnaWQnKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZVdpdGhFeGFjdGx5KGh0dHBDbGllbnQucmVxdWVzdCwge1xuICAgICAgdXJsOiBgJHtwcm92aXNpb25pbmdBcGlVcmx9L3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvYWNjb3VudElkL3JlcGxpY2FzL2lkYCxcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0sICdkZWxldGVBY2NvdW50UmVwbGljYScpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I2RlbGV0ZUFjY291bnRSZXBsaWNhfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgZGVsZXRlIE1ldGFUcmFkZXIgYWNjb3VudCByZXBsaWNhIHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudC50b2tlbiA9ICd0b2tlbic7XG4gICAgYWNjb3VudENsaWVudCA9IG5ldyBNZXRhdHJhZGVyQWNjb3VudENsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhY2NvdW50Q2xpZW50LmRlbGV0ZUFjY291bnRSZXBsaWNhKCdhY2NvdW50SWQnLCAnaWQnKTtcbiAgICAgIHNpbm9uLmFzc2VydC5mYWlsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGRlbGV0ZUFjY291bnRSZXBsaWNhIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50I3VwZGF0ZUFjY291bnR9XG4gICAqL1xuICBpdCgnc2hvdWxkIHVwZGF0ZSBNZXRhVHJhZGVyIGFjY291bnQgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBhY2NvdW50Q2xpZW50LnVwZGF0ZUFjY291bnQoJ2lkJywge1xuICAgICAgbmFtZTogJ25ldyBhY2NvdW50IG5hbWUnLFxuICAgICAgcGFzc3dvcmQ6ICduZXdfcGFzc3dvcmQwMDcnLFxuICAgICAgc2VydmVyOiAnSUNNYXJrZXRzU0MyLURlbW8nLFxuICAgICAgdGFnczogWyd0YWcxJ11cbiAgICB9KTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZVdpdGhFeGFjdGx5KGh0dHBDbGllbnQucmVxdWVzdCwge1xuICAgICAgdXJsOiBgJHtwcm92aXNpb25pbmdBcGlVcmx9L3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvaWRgLFxuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIG5hbWU6ICduZXcgYWNjb3VudCBuYW1lJyxcbiAgICAgICAgcGFzc3dvcmQ6ICduZXdfcGFzc3dvcmQwMDcnLFxuICAgICAgICBzZXJ2ZXI6ICdJQ01hcmtldHNTQzItRGVtbycsXG4gICAgICAgIHRhZ3M6IFsndGFnMSddXG4gICAgICB9XG4gICAgfSwgJ3VwZGF0ZUFjY291bnQnKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCN1cGRhdGVBY2NvdW50fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgdXBkYXRlIE1ldGFUcmFkZXIgYWNjb3VudCB2aWEgQVBJIHdpdGggYWNjb3VudCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBkb21haW5DbGllbnQudG9rZW4gPSAndG9rZW4nO1xuICAgIGFjY291bnRDbGllbnQgPSBuZXcgTWV0YXRyYWRlckFjY291bnRDbGllbnQoaHR0cENsaWVudCwgZG9tYWluQ2xpZW50KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYWNjb3VudENsaWVudC51cGRhdGVBY2NvdW50KCdpZCcsIHt9KTtcbiAgICAgIHNpbm9uLmFzc2VydC5mYWlsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIHVwZGF0ZUFjY291bnQgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjdXBkYXRlQWNjb3VudFJlcGxpY2F9XG4gICAqL1xuICBpdCgnc2hvdWxkIHVwZGF0ZSBNZXRhVHJhZGVyIGFjY291bnQgcmVwbGljYSB2aWEgQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGFjY291bnRDbGllbnQudXBkYXRlQWNjb3VudFJlcGxpY2EoJ2FjY291bnRJZCcsICdpZCcsIHtcbiAgICAgIG1hZ2ljOiAwLFxuICAgICAgdGFnczogWyd0YWcxJ11cbiAgICB9KTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZVdpdGhFeGFjdGx5KGh0dHBDbGllbnQucmVxdWVzdCwge1xuICAgICAgdXJsOiBgJHtwcm92aXNpb25pbmdBcGlVcmx9L3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvYWNjb3VudElkL3JlcGxpY2FzL2lkYCxcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgICAgYm9keToge1xuICAgICAgICBtYWdpYzogMCxcbiAgICAgICAgdGFnczogWyd0YWcxJ11cbiAgICAgIH1cbiAgICB9LCAndXBkYXRlQWNjb3VudFJlcGxpY2EnKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCN1cGRhdGVBY2NvdW50UmVwbGljYX1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHVwZGF0ZSBNZXRhVHJhZGVyIGFjY291bnQgcmVwbGljYSB2aWEgQVBJIHdpdGggYWNjb3VudCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBkb21haW5DbGllbnQudG9rZW4gPSAndG9rZW4nO1xuICAgIGFjY291bnRDbGllbnQgPSBuZXcgTWV0YXRyYWRlckFjY291bnRDbGllbnQoaHR0cENsaWVudCwgZG9tYWluQ2xpZW50KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYWNjb3VudENsaWVudC51cGRhdGVBY2NvdW50UmVwbGljYSgnYWNjb3VudElkJywgJ2lkJywge30pO1xuICAgICAgc2lub24uYXNzZXJ0LmZhaWwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgdXBkYXRlQWNjb3VudFJlcGxpY2EgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjaW5jcmVhc2VSZWxpYWJpbGl0eX1cbiAgICovXG4gIGl0KCdzaG91bGQgaW5jcmVhc2UgTWV0YVRyYWRlciBhY2NvdW50IHJlbGlhYmlsaXR5IHZpYSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgYWNjb3VudENsaWVudC5pbmNyZWFzZVJlbGlhYmlsaXR5KCdpZCcpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy9pZC9pbmNyZWFzZS1yZWxpYWJpbGl0eWAsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSwgJ2luY3JlYXNlUmVsaWFiaWxpdHknKTtcbiAgfSk7XG4gIFxuICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjaW5jcmVhc2VSZWxpYWJpbGl0eX1cbiAgICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgaW5jcmVhc2UgTWV0YVRyYWRlciBhY2NvdW50IHJlbGlhYmlsaXR5IHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGRvbWFpbkNsaWVudC50b2tlbiA9ICd0b2tlbic7XG4gICAgYWNjb3VudENsaWVudCA9IG5ldyBNZXRhdHJhZGVyQWNjb3VudENsaWVudChodHRwQ2xpZW50LCBkb21haW5DbGllbnQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhY2NvdW50Q2xpZW50LmluY3JlYXNlUmVsaWFiaWxpdHkoJ2lkJyk7XG4gICAgICBzaW5vbi5hc3NlcnQuZmFpbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBpbmNyZWFzZVJlbGlhYmlsaXR5IG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG59KTtcbiJdfQ==