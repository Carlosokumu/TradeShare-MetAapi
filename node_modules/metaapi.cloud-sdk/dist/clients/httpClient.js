'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HttpClientMock = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _requestPromiseAny = require('request-promise-any');

var _requestPromiseAny2 = _interopRequireDefault(_requestPromiseAny);

var _errorHandler = require('./errorHandler');

var _optionsValidator = require('./optionsValidator');

var _optionsValidator2 = _interopRequireDefault(_optionsValidator);

var _timeoutError = require('./timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * HTTP client library based on request-promise
 */
class HttpClient {

  /**
   * @typedef {Object} RetryOptions retry options
   * @property {Number} [retries] the number of attempts to retry failed request, default 5
   * @property {Number} [minDelayInSeconds] minimum delay in seconds before retrying, default 1
   * @property {Number} [maxDelayInSeconds] maximum delay in seconds before retrying, default 30
   * @property {Number} [subscribeCooldownInSeconds] time to disable new subscriptions for
   */

  /**
   * Constructs HttpClient class instance
   * @param {Number} timeout request timeout in seconds
   * @param {RetryOptions} [retryOpts] retry options
   */
  constructor(timeout = 60, retryOpts = {}) {
    const validator = new _optionsValidator2.default();
    this._timeout = timeout * 1000;
    this._retries = validator.validateNumber(retryOpts.retries, 5, 'retryOpts.retries');
    this._minRetryDelay = validator.validateNonZero(retryOpts.minDelayInSeconds, 1, 'retryOpts.minDelayInSeconds') * 1000;
    this._maxRetryDelay = validator.validateNonZero(retryOpts.maxDelayInSeconds, 30, 'retryOpts.maxDelayInSeconds') * 1000;
    this._logger = _logger2.default.getLogger('HttpClient');
  }

  /**
   * Performs a request. Response errors are returned as ApiError or subclasses.
   * @param {Object} options request options
   * @returns {Object|String|any} request result
   */
  async request(options, type = '', retryCounter = 0, endTime = Date.now() + this._maxRetryDelay * this._retries) {
    options.timeout = this._timeout;
    let retryAfterSeconds = 0;
    options.callback = (e, res) => {
      if (res && res.statusCode === 202) {
        retryAfterSeconds = res.headers['retry-after'];
        if (isNaN(retryAfterSeconds)) {
          retryAfterSeconds = Math.max((new Date(retryAfterSeconds).getTime() - Date.now()) / 1000, 1);
        }
      }
    };
    let body;
    try {
      body = await this._makeRequest(options);
    } catch (err) {
      retryCounter = await this._handleError(err, type, retryCounter, endTime);
      return this.request(options, type, retryCounter, endTime);
    }
    if (retryAfterSeconds) {
      if (body && body.message) {
        this._logger.info(`Retrying request in ${Math.floor(retryAfterSeconds)} seconds because request ` + 'returned message:', body.message);
      }
      await this._handleRetry(endTime, retryAfterSeconds * 1000);
      body = await this.request(options, type, retryCounter, endTime);
    }
    return body;
  }

  _makeRequest(options) {
    return (0, _requestPromiseAny2.default)(options);
  }

  async _wait(pause) {
    await new _promise2.default(res => setTimeout(res, pause));
  }

  async _handleRetry(endTime, retryAfter) {
    if (endTime > Date.now() + retryAfter) {
      await this._wait(retryAfter);
    } else {
      throw new _timeoutError2.default('Timed out waiting for the response');
    }
  }

  async _handleError(err, type, retryCounter, endTime) {
    const error = this._convertError(err);
    if (['ConflictError', 'InternalError', 'ApiError', 'TimeoutError'].includes(error.name) && retryCounter < this._retries) {
      const pause = Math.min(Math.pow(2, retryCounter) * this._minRetryDelay, this._maxRetryDelay);
      await this._wait(pause);
      return retryCounter + 1;
    } else if (error.name === 'TooManyRequestsError') {
      const retryTime = Date.parse(error.metadata.recommendedRetryTime);
      if (retryTime < endTime) {
        this._logger.debug(`${type} request has failed with TooManyRequestsError (HTTP status code 429). ` + `Will retry request in ${Math.ceil((retryTime - Date.now()) / 1000)} seconds`);
        await this._wait(retryTime - Date.now());
        return retryCounter;
      }
    }
    throw error;
  }

  // eslint-disable-next-line complexity
  _convertError(err) {
    err.error = err.error || {};
    let status = err.statusCode || err.status;
    switch (status) {
      case 400:
        return new _errorHandler.ValidationError(err.error.message || err.message, err.error.details || err.details);
      case 401:
        return new _errorHandler.UnauthorizedError(err.error.message || err.message);
      case 403:
        return new _errorHandler.ForbiddenError(err.error.message || err.message);
      case 404:
        return new _errorHandler.NotFoundError(err.error.message || err.message);
      case 409:
        return new _errorHandler.ConflictError(err.error.message || err.message);
      case 429:
        return new _errorHandler.TooManyRequestsError(err.error.message || err.message, err.error.metadata || err.metadata);
      case 500:
        return new _errorHandler.InternalError(err.error.message || err.message);
      default:
        return new _errorHandler.ApiError(_errorHandler.ApiError, err.error.message || err.message, status);
    }
  }

}

exports.default = HttpClient; /**
                               * HTTP client service mock for tests
                               */

class HttpClientMock extends HttpClient {

  /**
   * Constructs HTTP client mock
   * @param {Function(options:Object):Promise} requestFn mocked request function
   * @param {Number} timeout request timeout in seconds
   * @param {RetryOptions} retryOpts retry options
   */
  constructor(requestFn, timeout, retryOpts) {
    super(timeout, retryOpts);
    this._requestFn = requestFn;
  }

  _makeRequest() {
    return this._requestFn.apply(this, arguments);
  }

}
exports.HttpClientMock = HttpClientMock;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jbGllbnRzL2h0dHBDbGllbnQuZXM2Il0sIm5hbWVzIjpbIkh0dHBDbGllbnQiLCJjb25zdHJ1Y3RvciIsInRpbWVvdXQiLCJyZXRyeU9wdHMiLCJ2YWxpZGF0b3IiLCJPcHRpb25zVmFsaWRhdG9yIiwiX3RpbWVvdXQiLCJfcmV0cmllcyIsInZhbGlkYXRlTnVtYmVyIiwicmV0cmllcyIsIl9taW5SZXRyeURlbGF5IiwidmFsaWRhdGVOb25aZXJvIiwibWluRGVsYXlJblNlY29uZHMiLCJfbWF4UmV0cnlEZWxheSIsIm1heERlbGF5SW5TZWNvbmRzIiwiX2xvZ2dlciIsIkxvZ2dlck1hbmFnZXIiLCJnZXRMb2dnZXIiLCJyZXF1ZXN0Iiwib3B0aW9ucyIsInR5cGUiLCJyZXRyeUNvdW50ZXIiLCJlbmRUaW1lIiwiRGF0ZSIsIm5vdyIsInJldHJ5QWZ0ZXJTZWNvbmRzIiwiY2FsbGJhY2siLCJlIiwicmVzIiwic3RhdHVzQ29kZSIsImhlYWRlcnMiLCJpc05hTiIsIk1hdGgiLCJtYXgiLCJnZXRUaW1lIiwiYm9keSIsIl9tYWtlUmVxdWVzdCIsImVyciIsIl9oYW5kbGVFcnJvciIsIm1lc3NhZ2UiLCJpbmZvIiwiZmxvb3IiLCJfaGFuZGxlUmV0cnkiLCJfd2FpdCIsInBhdXNlIiwic2V0VGltZW91dCIsInJldHJ5QWZ0ZXIiLCJUaW1lb3V0RXJyb3IiLCJlcnJvciIsIl9jb252ZXJ0RXJyb3IiLCJpbmNsdWRlcyIsIm5hbWUiLCJtaW4iLCJwb3ciLCJyZXRyeVRpbWUiLCJwYXJzZSIsIm1ldGFkYXRhIiwicmVjb21tZW5kZWRSZXRyeVRpbWUiLCJkZWJ1ZyIsImNlaWwiLCJzdGF0dXMiLCJWYWxpZGF0aW9uRXJyb3IiLCJkZXRhaWxzIiwiVW5hdXRob3JpemVkRXJyb3IiLCJGb3JiaWRkZW5FcnJvciIsIk5vdEZvdW5kRXJyb3IiLCJDb25mbGljdEVycm9yIiwiVG9vTWFueVJlcXVlc3RzRXJyb3IiLCJJbnRlcm5hbEVycm9yIiwiQXBpRXJyb3IiLCJIdHRwQ2xpZW50TW9jayIsInJlcXVlc3RGbiIsIl9yZXF1ZXN0Rm4iLCJhcHBseSIsImFyZ3VtZW50cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7QUFJQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7QUFHZSxNQUFNQSxVQUFOLENBQWlCOztBQUU5Qjs7Ozs7Ozs7QUFRQTs7Ozs7QUFLQUMsY0FBWUMsVUFBVSxFQUF0QixFQUEwQkMsWUFBWSxFQUF0QyxFQUEwQztBQUN4QyxVQUFNQyxZQUFZLElBQUlDLDBCQUFKLEVBQWxCO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQkosVUFBVSxJQUExQjtBQUNBLFNBQUtLLFFBQUwsR0FBZ0JILFVBQVVJLGNBQVYsQ0FBeUJMLFVBQVVNLE9BQW5DLEVBQTRDLENBQTVDLEVBQStDLG1CQUEvQyxDQUFoQjtBQUNBLFNBQUtDLGNBQUwsR0FBc0JOLFVBQVVPLGVBQVYsQ0FBMEJSLFVBQVVTLGlCQUFwQyxFQUF1RCxDQUF2RCxFQUNwQiw2QkFEb0IsSUFDYSxJQURuQztBQUVBLFNBQUtDLGNBQUwsR0FBc0JULFVBQVVPLGVBQVYsQ0FBMEJSLFVBQVVXLGlCQUFwQyxFQUF1RCxFQUF2RCxFQUNwQiw2QkFEb0IsSUFDYSxJQURuQztBQUVBLFNBQUtDLE9BQUwsR0FBZUMsaUJBQWNDLFNBQWQsQ0FBd0IsWUFBeEIsQ0FBZjtBQUNEOztBQUVEOzs7OztBQUtBLFFBQU1DLE9BQU4sQ0FBY0MsT0FBZCxFQUF1QkMsT0FBTyxFQUE5QixFQUFrQ0MsZUFBZSxDQUFqRCxFQUFvREMsVUFBVUMsS0FBS0MsR0FBTCxLQUFhLEtBQUtYLGNBQUwsR0FBc0IsS0FBS04sUUFBdEcsRUFBZ0g7QUFDOUdZLFlBQVFqQixPQUFSLEdBQWtCLEtBQUtJLFFBQXZCO0FBQ0EsUUFBSW1CLG9CQUFvQixDQUF4QjtBQUNBTixZQUFRTyxRQUFSLEdBQW1CLENBQUNDLENBQUQsRUFBSUMsR0FBSixLQUFZO0FBQzdCLFVBQUlBLE9BQU9BLElBQUlDLFVB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ZUFBTyxJQUFJNEIsa0NBQUosQ0FBeUI5QixJQUFJVyxLQUFKLENBQVVULE9BQVYsSUFBcUJGLElBQUlFLE9BQWxELEVBQTJERixJQUFJVyxLQUFKLENBQVVRLFFBQVYsSUFBc0JuQixJQUFJbUIsUUFBckYsQ0FBUDtBQUNGLFdBQUssR0FBTDtBQUNFLGVBQU8sSUFBSVksMkJBQUosQ0FBa0IvQixJQUFJVyxLQUFKLENBQVVULE9BQVYsSUFBcUJGLElBQUlFLE9BQTNDLENBQVA7QUFDRjtBQUNFLGVBQU8sSUFBSThCLHNCQUFKLENBQWFBLHNCQUFiLEVBQXVCaEMsSUFBSVcsS0FBSixDQUFVVCxPQUFWLElBQXFCRixJQUFJRSxPQUFoRCxFQUF5RHFCLE1BQXpELENBQVA7QUFoQkY7QUFrQkQ7O0FBckg2Qjs7a0JBQVg1RCxVLEVBeUhyQjs7OztBQUdPLE1BQU1zRSxjQUFOLFNBQTZCdEUsVUFBN0IsQ0FBd0M7O0FBRTdDOzs7Ozs7QUFNQUMsY0FBWXNFLFNBQVosRUFBdUJyRSxPQUF2QixFQUFnQ0MsU0FBaEMsRUFBMkM7QUFDekMsVUFBTUQsT0FBTixFQUFlQyxTQUFmO0FBQ0EsU0FBS3FFLFVBQUwsR0FBa0JELFNBQWxCO0FBQ0Q7O0FBRURuQyxpQkFBZTtBQUNiLFdBQU8sS0FBS29DLFVBQUwsQ0FBZ0JDLEtBQWhCLENBQXNCLElBQXRCLEVBQTRCQyxTQUE1QixDQUFQO0FBQ0Q7O0FBZjRDO1FBQWxDSixjLEdBQUFBLGMiLCJmaWxlIjoiaHR0cENsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHJlcXVlc3QgZnJvbSAncmVxdWVzdC1wcm9taXNlLWFueSc7XG5pbXBvcnQge1xuICBVbmF1dGhvcml6ZWRFcnJvciwgRm9yYmlkZGVuRXJyb3IsIEFwaUVycm9yLCBWYWxpZGF0aW9uRXJyb3IsIEludGVybmFsRXJyb3IsIFxuICBOb3RGb3VuZEVycm9yLCBUb29NYW55UmVxdWVzdHNFcnJvciwgQ29uZmxpY3RFcnJvclxufSBmcm9tICcuL2Vycm9ySGFuZGxlcic7XG5pbXBvcnQgT3B0aW9uc1ZhbGlkYXRvciBmcm9tICcuL29wdGlvbnNWYWxpZGF0b3InO1xuaW1wb3J0IFRpbWVvdXRFcnJvciBmcm9tICcuL3RpbWVvdXRFcnJvcic7XG5pbXBvcnQgTG9nZ2VyTWFuYWdlciBmcm9tICcuLi9sb2dnZXInO1xuXG4vKipcbiAqIEhUVFAgY2xpZW50IGxpYnJhcnkgYmFzZWQgb24gcmVxdWVzdC1wcm9taXNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEh0dHBDbGllbnQge1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXRyeU9wdGlvbnMgcmV0cnkgb3B0aW9uc1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3JldHJpZXNdIHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gcmV0cnkgZmFpbGVkIHJlcXVlc3QsIGRlZmF1bHQgNVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW21pbkRlbGF5SW5TZWNvbmRzXSBtaW5pbXVtIGRlbGF5IGluIHNlY29uZHMgYmVmb3JlIHJldHJ5aW5nLCBkZWZhdWx0IDFcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFttYXhEZWxheUluU2Vjb25kc10gbWF4aW11bSBkZWxheSBpbiBzZWNvbmRzIGJlZm9yZSByZXRyeWluZywgZGVmYXVsdCAzMFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzXSB0aW1lIHRvIGRpc2FibGUgbmV3IHN1YnNjcmlwdGlvbnMgZm9yXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIEh0dHBDbGllbnQgY2xhc3MgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgcmVxdWVzdCB0aW1lb3V0IGluIHNlY29uZHNcbiAgICogQHBhcmFtIHtSZXRyeU9wdGlvbnN9IFtyZXRyeU9wdHNdIHJldHJ5IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRpbWVvdXQgPSA2MCwgcmV0cnlPcHRzID0ge30pIHtcbiAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgT3B0aW9uc1ZhbGlkYXRvcigpO1xuICAgIHRoaXMuX3RpbWVvdXQgPSB0aW1lb3V0ICogMTAwMDtcbiAgICB0aGlzLl9yZXRyaWVzID0gdmFsaWRhdG9yLnZhbGlkYXRlTnVtYmVyKHJldHJ5T3B0cy5yZXRyaWVzLCA1LCAncmV0cnlPcHRzLnJldHJpZXMnKTtcbiAgICB0aGlzLl9taW5SZXRyeURlbGF5ID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZXRyeU9wdHMubWluRGVsYXlJblNlY29uZHMsIDEsXG4gICAgICAncmV0cnlPcHRzLm1pbkRlbGF5SW5TZWNvbmRzJykgKiAxMDAwO1xuICAgIHRoaXMuX21heFJldHJ5RGVsYXkgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKHJldHJ5T3B0cy5tYXhEZWxheUluU2Vjb25kcywgMzAsXG4gICAgICAncmV0cnlPcHRzLm1heERlbGF5SW5TZWNvbmRzJykgKiAxMDAwO1xuICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlck1hbmFnZXIuZ2V0TG9nZ2VyKCdIdHRwQ2xpZW50Jyk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSByZXF1ZXN0LiBSZXNwb25zZSBlcnJvcnMgYXJlIHJldHVybmVkIGFzIEFwaUVycm9yIG9yIHN1YmNsYXNzZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fFN0cmluZ3xhbnl9IHJlcXVlc3QgcmVzdWx0XG4gICAqL1xuICBhc3luYyByZXF1ZXN0KG9wdGlvbnMsIHR5cGUgPSAnJywgcmV0cnlDb3VudGVyID0gMCwgZW5kVGltZSA9IERhdGUubm93KCkgKyB0aGlzLl9tYXhSZXRyeURlbGF5ICogdGhpcy5fcmV0cmllcykge1xuICAgIG9wdGlvbnMudGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgbGV0IHJldHJ5QWZ0ZXJTZWNvbmRzID0gMDtcbiAgICBvcHRpb25zLmNhbGxiYWNrID0gKGUsIHJlcykgPT4ge1xuICAgICAgaWYgKHJlcyAmJiByZXMuc3RhdHVzQ29kZSA9PT0gMjAyKSB7XG4gICAgICAgIHJldHJ5QWZ0ZXJTZWNvbmRzID0gcmVzLmhlYWRlcnNbJ3JldHJ5LWFmdGVyJ107XG4gICAgICAgIGlmKGlzTmFOKHJldHJ5QWZ0ZXJTZWNvbmRzKSkge1xuICAgICAgICAgIHJldHJ5QWZ0ZXJTZWNvbmRzID0gTWF0aC5tYXgoKG5ldyBEYXRlKHJldHJ5QWZ0ZXJTZWNvbmRzKS5nZXRUaW1lKCkgLSBEYXRlLm5vdygpKSAvIDEwMDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHRoaXMuX21ha2VSZXF1ZXN0KG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0cnlDb3VudGVyID0gYXdhaXQgdGhpcy5faGFuZGxlRXJyb3IoZXJyLCB0eXBlLCByZXRyeUNvdW50ZXIsIGVuZFRpbWUpO1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChvcHRpb25zLCB0eXBlLCByZXRyeUNvdW50ZXIsIGVuZFRpbWUpO1xuICAgIH1cbiAgICBpZiAocmV0cnlBZnRlclNlY29uZHMpIHtcbiAgICAgIGlmKGJvZHkgJiYgYm9keS5tZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBSZXRyeWluZyByZXF1ZXN0IGluICR7TWF0aC5mbG9vcihyZXRyeUFmdGVyU2Vjb25kcyl9IHNlY29uZHMgYmVjYXVzZSByZXF1ZXN0IGAgK1xuICAgICAgICAgICdyZXR1cm5lZCBtZXNzYWdlOicsIGJvZHkubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl9oYW5kbGVSZXRyeShlbmRUaW1lLCByZXRyeUFmdGVyU2Vjb25kcyAqIDEwMDApO1xuICAgICAgYm9keSA9IGF3YWl0IHRoaXMucmVxdWVzdChvcHRpb25zLCB0eXBlLCByZXRyeUNvdW50ZXIsIGVuZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuXG4gIF9tYWtlUmVxdWVzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJlcXVlc3Qob3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBfd2FpdChwYXVzZSkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgcGF1c2UpKTtcbiAgfVxuXG4gIGFzeW5jIF9oYW5kbGVSZXRyeShlbmRUaW1lLCByZXRyeUFmdGVyKSB7XG4gICAgaWYoZW5kVGltZSA+IERhdGUubm93KCkgKyByZXRyeUFmdGVyKSB7XG4gICAgICBhd2FpdCB0aGlzLl93YWl0KHJldHJ5QWZ0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVGltZW91dEVycm9yKCdUaW1lZCBvdXQgd2FpdGluZyBmb3IgdGhlIHJlc3BvbnNlJyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2hhbmRsZUVycm9yKGVyciwgdHlwZSwgcmV0cnlDb3VudGVyLCBlbmRUaW1lKSB7XG4gICAgY29uc3QgZXJyb3IgPSB0aGlzLl9jb252ZXJ0RXJyb3IoZXJyKTtcbiAgICBpZihbJ0NvbmZsaWN0RXJyb3InLCAnSW50ZXJuYWxFcnJvcicsICdBcGlFcnJvcicsICdUaW1lb3V0RXJyb3InXS5pbmNsdWRlcyhlcnJvci5uYW1lKSBcbiAgICAgICYmIHJldHJ5Q291bnRlciA8IHRoaXMuX3JldHJpZXMpIHtcbiAgICAgIGNvbnN0IHBhdXNlID0gTWF0aC5taW4oTWF0aC5wb3coMiwgcmV0cnlDb3VudGVyKSAqIHRoaXMuX21pblJldHJ5RGVsYXksIHRoaXMuX21heFJldHJ5RGVsYXkpO1xuICAgICAgYXdhaXQgdGhpcy5fd2FpdChwYXVzZSk7XG4gICAgICByZXR1cm4gcmV0cnlDb3VudGVyICsgMTtcbiAgICB9IGVsc2UgaWYoZXJyb3IubmFtZSA9PT0gJ1Rvb01hbnlSZXF1ZXN0c0Vycm9yJykge1xuICAgICAgY29uc3QgcmV0cnlUaW1lID0gRGF0ZS5wYXJzZShlcnJvci5tZXRhZGF0YS5yZWNvbW1lbmRlZFJldHJ5VGltZSk7XG4gICAgICBpZiAocmV0cnlUaW1lIDwgZW5kVGltZSkge1xuICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dHlwZX0gcmVxdWVzdCBoYXMgZmFpbGVkIHdpdGggVG9vTWFueVJlcXVlc3RzRXJyb3IgKEhUVFAgc3RhdHVzIGNvZGUgNDI5KS4gYCArXG4gICAgICAgICAgYFdpbGwgcmV0cnkgcmVxdWVzdCBpbiAke01hdGguY2VpbCgocmV0cnlUaW1lIC0gRGF0ZS5ub3coKSkgLyAxMDAwKX0gc2Vjb25kc2ApO1xuICAgICAgICBhd2FpdCB0aGlzLl93YWl0KHJldHJ5VGltZSAtIERhdGUubm93KCkpO1xuICAgICAgICByZXR1cm4gcmV0cnlDb3VudGVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIF9jb252ZXJ0RXJyb3IoZXJyKSB7XG4gICAgZXJyLmVycm9yID0gZXJyLmVycm9yIHx8IHt9O1xuICAgIGxldCBzdGF0dXMgPSBlcnIuc3RhdHVzQ29kZSB8fCBlcnIuc3RhdHVzO1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSA0MDA6XG4gICAgICByZXR1cm4gbmV3IFZhbGlkYXRpb25FcnJvcihlcnIuZXJyb3IubWVzc2FnZSB8fCBlcnIubWVzc2FnZSwgZXJyLmVycm9yLmRldGFpbHMgfHwgZXJyLmRldGFpbHMpO1xuICAgIGNhc2UgNDAxOlxuICAgICAgcmV0dXJuIG5ldyBVbmF1dGhvcml6ZWRFcnJvcihlcnIuZXJyb3IubWVzc2FnZSB8fCBlcnIubWVzc2FnZSk7XG4gICAgY2FzZSA0MDM6XG4gICAgICByZXR1cm4gbmV3IEZvcmJpZGRlbkVycm9yKGVyci5lcnJvci5tZXNzYWdlIHx8IGVyci5tZXNzYWdlKTtcbiAgICBjYXNlIDQwNDpcbiAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihlcnIuZXJyb3IubWVzc2FnZSB8fCBlcnIubWVzc2FnZSk7XG4gICAgY2FzZSA0MDk6XG4gICAgICByZXR1cm4gbmV3IENvbmZsaWN0RXJyb3IoZXJyLmVycm9yLm1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2UpO1xuICAgIGNhc2UgNDI5OlxuICAgICAgcmV0dXJuIG5ldyBUb29NYW55UmVxdWVzdHNFcnJvcihlcnIuZXJyb3IubWVzc2FnZSB8fCBlcnIubWVzc2FnZSwgZXJyLmVycm9yLm1ldGFkYXRhIHx8IGVyci5tZXRhZGF0YSk7XG4gICAgY2FzZSA1MDA6XG4gICAgICByZXR1cm4gbmV3IEludGVybmFsRXJyb3IoZXJyLmVycm9yLm1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2UpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3IEFwaUVycm9yKEFwaUVycm9yLCBlcnIuZXJyb3IubWVzc2FnZSB8fCBlcnIubWVzc2FnZSwgc3RhdHVzKTtcbiAgICB9XG4gIH1cblxufVxuXG4vKipcbiAqIEhUVFAgY2xpZW50IHNlcnZpY2UgbW9jayBmb3IgdGVzdHNcbiAqL1xuZXhwb3J0IGNsYXNzIEh0dHBDbGllbnRNb2NrIGV4dGVuZHMgSHR0cENsaWVudCB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgSFRUUCBjbGllbnQgbW9ja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9uKG9wdGlvbnM6T2JqZWN0KTpQcm9taXNlfSByZXF1ZXN0Rm4gbW9ja2VkIHJlcXVlc3QgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgcmVxdWVzdCB0aW1lb3V0IGluIHNlY29uZHNcbiAgICogQHBhcmFtIHtSZXRyeU9wdGlvbnN9IHJldHJ5T3B0cyByZXRyeSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0Rm4sIHRpbWVvdXQsIHJldHJ5T3B0cykge1xuICAgIHN1cGVyKHRpbWVvdXQsIHJldHJ5T3B0cyk7XG4gICAgdGhpcy5fcmVxdWVzdEZuID0gcmVxdWVzdEZuO1xuICB9XG5cbiAgX21ha2VSZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0Rm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG59XG4iXX0=